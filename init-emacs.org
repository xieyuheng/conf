#+title:  init emacs ^-^

* lib

*** rgx

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defmacro rgx-opt (&rest lis)
      `(regexp-opt (quote ,lis)))
    ;; test:
    ;; (rgx-opt "aaa" "bbb" "ccc")

    (defun rgx-nested-groups-help (lis)
      (if lis
          (concat (car lis)
                  "\\("
                  (rx-groups-help (cdr lis))
                  "\\)")
        '()))
    (defmacro rgx-nested-groups (&rest lis)
      `(rgx-nested-groups-help (quote ,lis)))
    ;; test:
    ;; (rgx-nested-groups "aaa" "bbb" "ccc")
    ;; (rx (groups "aaa"
    ;;            (groups "bbb"
    ;;                   (groups "ccc"))))

    (defun rgx-groups (&rest lis)
      (apply (function concat)
             (apply (function append)
                    (mapcar (lambda (x) (list "\\(" x "\\)"))
                            lis))))
    ;; test:
    ;; (rgx-groups "1" "2" "3")
    ;; (rx (group "1") (group "2") (group "3"))
    #+end_src

*** make-syntaxes

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; a syntax-table is a char-table
    (defmacro make-syntaxes (name &rest lis)
      (list 'progn ;; need to control eva order
            `(setq ,name
                   (make-char-table 'syntax-table (string-to-syntax "w")))
            (cons 'progn
                  (mapcar (lambda (char-and-newentry)
                            (append (list 'modify-syntax-entry)
                                    char-and-newentry
                                    (list name)))
                          lis))))

    (make-syntaxes
     word-syntax-table
     ;; default is word constituent
     ;; whitespace characters:
     (   '(0 . 32)    "-"  )
     (      127       "-"  ))

    (make-syntaxes
     word-syntax-table-with-symbol&with-open/close-delimiter
     ;; note that, if modify one syntax entry twice
     ;; the second will shadow the first
     ;; whitespace characters:
     (   '(0 . 32)    "-"  )
     (      127       "-"  )
     ;; symbol constituent:
     ;; the following functions need this:
     ;; ``forward-word'' and so on ...
     (  '(33 . 47)    "_"  )
     (  '(58 . 64)    "_"  )
     (  '(91 . 96)    "_"  )
     ( '(123 . 126)   "_"  )
     ;; open/close delimiter:
     ;; the following functions need this:
     ;; ``forward-sexp'' ``backward-sexp''
     ;; ``mark-sexp'' and so on ...
     (  ?\(    "("  )
     (  ?\)    ")"  )
     (  ?\[    "("  )
     (  ?\]    ")"  )
     (  ?\{    "("  )
     (  ?\}    ")"  ))

    (make-syntaxes
     word-syntax-table-with-symbol
     ;; note that, if modify one syntax entry twice
     ;; the second will shadow the first
     ;; whitespace characters:
     (   '(0 . 32)    "-"  )
     (      127       "-"  )
     ;; symbol constituent:
     ;; the following functions need this:
     ;; ``forward-word'' and so on ...
     (  '(33 . 47)    "_"  )
     (  '(58 . 64)    "_"  )
     (  '(91 . 96)    "_"  )
     ( '(123 . 126)   "_"  ))

    (make-syntaxes
     word-syntax-table-with-open/close-delimiter
     ;; note that, if modify one syntax entry twice
     ;; the second will shadow the first
     ;; whitespace characters:
     (   '(0 . 32)    "-"  )
     (      127       "-"  )
     ;; open/close delimiter:
     ;; the following functions need this:
     ;; ``forward-sexp'' ``backward-sexp''
     ;; ``mark-sexp'' and so on ...
     (  ?\(    "("  )
     (  ?\)    ")"  )
     (  ?\[    "("  )
     (  ?\]    ")"  )
     (  ?\{    "("  )
     (  ?\}    ")"  ))
    #+end_src

*** make-faces

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun make-faces-help (alist)
      (mapcar (lambda (face-definiton)
                (eval (append '(defface)
                              (list (car face-definiton)
                                    (cons 'quote (cdr face-definiton)))
                              '("") )))
              alist))

    (defmacro make-faces (&rest alist)
      `(make-faces-help (quote ,alist)))





    (defun say-for-turn-off-indent ()
      (interactive)
      (back-to-indentation)
      (message "<tab> indentation has been turn off."))

    (setq function-before-turn-on-indent
          (lambda () (interactive)
            (message "<tab> indentation has not been turned off yet.")))
    (defun turn-off-indent ()
      (interactive)
      (setq function-before-turn-on-indent
            (lookup-key (current-local-map) (kbd "<tab>")))
      (local-set-key (kbd "<tab>") 'say-for-turn-off-indent)
      (message "turning off <tab> indentation."))

    (defun turn-on-indent ()
      (interactive)
      (local-set-key (kbd "<tab>") function-before-turn-on-indent)
      (message "turning on <tab> indentation."))

    (defun change-parentheses ()
      (interactive)
      (cond ((looking-at "\(")
             (message "( ) --> [ ]")
             (let ()
               (delete-char 1)
               (insert "[")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert "]")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            ((looking-at "\\[")
             (message "[ ] --> { }")
             (let ()
               (delete-char 1)
               (insert "{")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert "}")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            ((looking-at "\{")
             (message "{ } --> ( )")
             (let ()
               (delete-char 1)
               (insert "(")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert ")")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            (t ;;else
             (message "change-parentheses have nothing to do here !"))))
    #+end_src

*** change-parentheses

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "M-[") 'change-parentheses)
    #+end_src

*** member-string?

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun member-string? (x l)
      (cond ((null l) nil)
            ((string-equal x (car l))
             t)
            (:else
             (member-string? x (cdr l)))))
    #+end_src

*** <C-f1> & <C-f2>

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-<C-f1> ()
      (interactive)
      (forward-word)
      (delete-char 1)
      (insert "-"))
    (global-set-key (kbd "<C-f1>") 'my-<C-f1>)

    (defun my-<C-f2> ()
      (interactive)
      (forward-word)
      (delete-char 1)
      (insert "_"))
    (global-set-key (kbd "<C-f2>") 'my-<C-f2>)
    #+end_src

*** generator

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defvar number-generator:*counter* 0)
    (defun number-generator ()
      (setq number-generator:*counter* (+ number-generator:*counter* 1))
      number-generator:*counter*)
    #+end_src

*** needed

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/dash/")
    (require 'dash)

    (add-to-list 'load-path "~/.emacs.d/epl/")
    (require 'epl)

    (add-to-list 'load-path "~/.emacs.d/pkg-info/")
    (require 'pkg-info)

    (add-to-list 'load-path "~/.emacs.d/spinner.el/")
    (require 'spinner)

    (add-to-list 'load-path "~/.emacs.d/seq.el/")
    (require 'seq)
    #+end_src

*** load xrdb

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun xrdb ()
      (interactive)
      (eshell-command "xrdb ~/.Xresource"))
    #+end_src

* key binding

*** unbinding

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; orientally: transpose-words
    (global-set-key (kbd "M-t") 'nil)
    (global-set-key (kbd "M-j") 'nil)
    (global-set-key (kbd "M-k") 'nil)
    (global-set-key (kbd "M-`") 'nil)
    #+end_src

*** prefix-command

    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-prefix-command 'C-s-map)
    (global-set-key (kbd "C-s") 'C-s-map)
    ;; used by:
    ;; "C-s C-r" : rename-buffer
    ;; "C-s C-s" : org-edit-src-code
    ;; "C-s C-x" : switch-to-buffer-*scheme*
    ;; "C-s C-c" : switch-to-buffer-*haskell*
    ;; "C-s C-e" : my-switch-to-eshell
    #+end_src

*** cruise

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun window-> () (interactive) (other-window +1))
    (defun <-window () (interactive) (other-window -1))

    ;; 没有使用<C-tab>
    ;; 因为<C-tab>需要在 org-mode 中使用
    ;; 因为按<tab>的时候可以不放开 Ctrl 是方便的
    ;; (global-set-key (kbd "M-<tab>") 'window->)
    ;; (global-set-key (kbd "M-<tab>") (lambda () (interactive) (other-window +1)))
    (global-set-key (kbd "C-o") 'window->)

    (global-set-key (kbd "M-=") 'window->)
    (global-set-key (kbd "M--") '<-window)
    ;; (global-set-key (kbd "M-0") 'window->)
    ;; (global-set-key (kbd "M-9") '<-window)

    (global-set-key (kbd "C-x .") 'next-buffer)
    (global-set-key (kbd "C-x ,") 'previous-buffer)

    (global-set-key (kbd "C-M-.") 'next-buffer)
    (global-set-key (kbd "C-M-,") 'previous-buffer)

    (global-set-key (kbd "M-p") 'backward-paragraph)
    (global-set-key (kbd "M-n") 'forward-paragraph)
    #+end_src

*** window resizing

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-M-h") 'shrink-window-horizontally)
    (global-set-key (kbd "C-M-l") 'enlarge-window-horizontally)
    (global-set-key (kbd "C-M-j") 'shrink-window)
    (global-set-key (kbd "C-M-k") 'enlarge-window)
    #+end_src

*** path

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "<C-M-return>") 'pwd)
    #+end_src

*** line wrap

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-M-g") 'global-visual-line-mode)
    #+end_src

*** comment

    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-prefix-command '<menu>-map)
    (global-set-key (kbd "<menu>") '<menu>-map)
    (global-set-key (kbd "<menu> '") 'comment-region)
    (global-set-key (kbd "<menu> ;") 'uncomment-region)

    (global-set-key (kbd "C-.") 'comment-region)
    (global-set-key (kbd "C-,") 'uncomment-region)
    #+end_src

*** edit

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; backward-kill-sentence

    ;; (defun say-not-binding ()
    ;;   (interactive)
    ;;   (message "this key have not binding"))

    (global-set-key (kbd "C-x <backspace>") 'delete-backward-char)
    #+end_src

*** view

    - 如果不左右 scroll
      emacs 就会自动为把长的行折反到视野中来(org-mode 除外)
    - M-< : beginning-of-buffer
      M-> : end-of-buffer
      + 不要与下面的绑定混淆
        M-, : org-babel-previous-src-block
        M-. : org-babel-next-src-block
    - C-v : scroll-up-command
      M-v : scroll-down-command

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun scroll-right-as-my-wish ()
      (interactive)
      (scroll-left -1 1))
    (defun scroll-left-as-my-wish ()
      (interactive)
      (scroll-left 1 1))
    (global-set-key (kbd "<prior>") 'scroll-right-as-my-wish)
    (global-set-key (kbd "<next>") 'scroll-left-as-my-wish)
    (setq hscroll-step 1
          hscroll-margin 6)
    #+end_src

*** query-replace

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "M-i") 'query-replace)
    #+end_src

*** help

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-/") 'help)
    #+end_src

*** C-x C-h

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-x C-h") 'mark-whole-buffer)
    #+end_src

*** rename-buffer

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-s C-r") 'rename-buffer)
    #+end_src

*** insert (some trick here)

    can't bind C-M-i to new function in normal way

    and TAB == C-i

    one can find:
    (kbd "C-i") == (kbd "TAB") == "	"
    (kbd "C-M-i") == [134217737]
    in elisp-repl

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (define-key input-decode-map [?\C-i] [control-i])
    ;; (global-set-key [control-i] 'insert-newline-below)

    (define-key input-decode-map [134217737] [C-M-i])
    (global-set-key [C-M-i] 'insert-newline-below)

    (defun insert-newline-below ()
      (interactive)
      (insert "\n")
      (backward-char 1))
    #+end_src

*** whitespace

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key
     (kbd "C-M-w")
     (lambda ()
       (interactive)
       (message "* (whitespace-cleanup)")
       (whitespace-cleanup)))

    (global-set-key
     (kbd "M-W")
     (lambda ()
       (interactive)
       (message "* (whitespace-cleanup)")
       (whitespace-cleanup)))


    ;; 有了下面的設置 每次 C-x C-s 時 就會自動清除 whitespace
    ;; automatically clean up bad whitespace
    ;; (setq whitespace-action '(auto-cleanup))

    ;; only show bad whitespace
    (setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab))

    (whitespace-mode t)
    (global-whitespace-mode t)
    #+end_src

*** mania

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-s C-x") 'save-buffer)
    #+end_src

*** mouse

    #+begin_src emacs-lisp :tangle ~/.emacs
    (dolist (k '([mouse-1] [down-mouse-1] [drag-mouse-1] [double-mouse-1] [triple-mouse-1]
                 [mouse-2] [down-mouse-2] [drag-mouse-2] [double-mouse-2] [triple-mouse-2]
                 [mouse-3] [down-mouse-3] [drag-mouse-3] [double-mouse-3] [triple-mouse-3]
                 [mouse-4] [down-mouse-4] [drag-mouse-4] [double-mouse-4] [triple-mouse-4]
                 [mouse-5] [down-mouse-5] [drag-mouse-5] [double-mouse-5] [triple-mouse-5]
                 [mouse-6] [down-mouse-6] [drag-mouse-6] [double-mouse-6] [triple-mouse-6]
                 [mouse-7] [down-mouse-7] [drag-mouse-7] [double-mouse-7] [triple-mouse-7]))
      (global-set-key k (lambda () (interactive))))

    ;; (global-set-key (kbd "<mouse-5>") 'next-line)
    ;; (global-set-key (kbd "<mouse-4>") 'previous-line)

    ;; (global-set-key (kbd "<mouse-7>") 'next-line)
    ;; (global-set-key (kbd "<mouse-6>") 'previous-line)

    ;; (global-set-key (kbd "<mouse-7>") 'forward-char)
    ;; (global-set-key (kbd "<mouse-6>") 'backward-char)
    #+end_src

* general setting

*** variable

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq case-fold-search nil)
    (setq case-replace nil)
    (setq indent-tabs-mode nil)
    (setq-default indent-tabs-mode nil)
    ;; 全局设置上面的变量并没有用
    ;;   设想如果我能用一个树状图来清晰地描述 mode 之间的继承与依赖关系
    ;;   而不是只有简单的 major 和 minor 两个层次
    ;;   并且我能方便的浏览这个树
    ;;   能像操作一个列表一样方便的调整这个树
    ;; 写一个不光有更好配置语言的
    ;; 而且有更好的设计的文本编辑器也许并没有那么难
    (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))

    (fringe-mode '(6 . 6))

    (transient-mark-mode t)

    (setq column-number-mode t)

    (setq mouse-yank-at-point t)

    (setq kill-ring-max 200)

    ;; (setq enable-recursive-minibuffers t)

    (setq scroll-margin 4
          scroll-conservatively 10000)

    ;; (setq default-major-mode 'org-mode)

    (show-paren-mode t)
    (setq show-paren-style 'parentheses)
    #+end_src

*** enable disable

    #+begin_src emacs-lisp :tangle ~/.emacs
    (put 'set-goal-column 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    #+end_src

*** simple version control

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq make-backup-files nil
          delete-old-versions t)

    ;; (setq  backup-by-copying t
    ;;        version-control t
    ;;        kept-new-versions 10
    ;;        kept-old-versions 0
    ;;        dired-kept-versions 1)
    #+end_src

*** variable about mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq modes-about-lisp
          '(scheme-mode
            jojo-mode
            inferior-scheme-mode

            lisp-mode
            lisp-interaction-mode

            emacs-lisp-mode
            ielm-mode
            inferior-emacs-lisp-mode
            ))

    (setq modes-about-haskell
          '(haskell-mode
            inferior-haskell-mode
            ))

    (setq modes-about-C
          '(c-mode
            ))

    (setq modes-about-cicada
          '(cicada-mode
            inferior-cicada-mode
            ))
    #+end_src

*** kill-buffer-query-functions

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq kill-buffer-query-functions nil)
    #+end_src

*** tab-width

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq tab-width 2)
    #+end_src

* language

*** load progmodes
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/progmodes/")
    #+end_src

*** repl-space
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/repl-space/")
    (require 'repl-space)
    #+end_src

*** edit sexp

***** load-path
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/edit-sexp/")
      #+end_src

***** mark and cruise

      - the follow functions are belong to lisp.el

      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (global-set-key (kbd "s-z") 'mark-defun)
      ;; (global-set-key (kbd "s-a") 'mark-sexp)
      ;;
      ;; (global-set-key (kbd "s-w") 'backward-sexp)
      ;; (global-set-key (kbd "s-s") 'forward-sexp)
      ;;
      ;; (defun in-> () (interactive) (down-list))
      ;; (global-set-key (kbd "s-e") 'in->)
      ;;
      ;; (defun <-out () (interactive) (backward-up-list))
      ;; (global-set-key (kbd "s-q") '<-out)
      ;;
      ;; (defun out-> () (interactive) (up-list))
      ;; (global-set-key (kbd "s-d") 'out->)


      ;; (global-set-key (kbd "s-z") 'mark-defun)
      (global-set-key (kbd "M-a") 'mark-sexp)

      (global-set-key (kbd "M-e") 'backward-sexp)
      (global-set-key (kbd "M-s") 'forward-sexp)

      (defun in-> () (interactive) (down-list))
      ;; (global-set-key (kbd "M-e") 'in->)

      (defun <-out () (interactive) (backward-up-list))
      (global-set-key (kbd "M-q") '<-out)

      (defun out-> () (interactive) (up-list))
      ;; (global-set-key (kbd "s-d") 'out->)



      ;; the following is for emacs-nox which can not see s-
      (define-key input-decode-map [134217825] [M-a])
      (global-set-key [M-a] 'mark-sexp)



      ;; (global-set-key (kbd "C-M-p") 'backward-sexp)
      ;; (global-set-key (kbd "C-M-n") 'forward-sexp)

      ;; (global-set-key (kbd "C-M-f") 'in->)

      ;; (global-set-key (kbd "C-M-b") '<-out)
      #+end_src

***** paredit
      file:~/.emacs.d/edit-sexp/paredit.el
      #+begin_src emacs-lisp :tangle ~/.emacs
      (autoload 'enable-paredit-mode
          "paredit"
        "Turn on pseudo-structural editing of Lisp code." t)

      (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
      (add-hook 'jojo-mode-hook             #'enable-paredit-mode)
      (add-hook 'inferior-scheme-mode-hook  #'enable-paredit-mode)

      (add-hook 'racket-repl-mode-hook      #'enable-paredit-mode)
      (add-hook 'racket-mode-hook           #'enable-paredit-mode)


      (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
      (add-hook 'slime-repl-mode-hook       #'enable-paredit-mode)

      (add-hook 'lfe-mode-hook              #'enable-paredit-mode)
      (add-hook 'inferior-lfe-mode-hook     #'enable-paredit-mode)

      (add-hook 'shen-mode-hook             #'enable-paredit-mode)
      (add-hook 'inferior-shen-mode-hook    #'enable-paredit-mode)

      (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
      (add-hook 'cider-repl-mode-hook       #'enable-paredit-mode)


      ;; (add-hook 'ielm-mode-hook             #'enable-paredit-mode)

      ;; the following is about the *scratch* buffer
      ;; (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
      ;; 不知道为什么这里就算使用 maybe-map-paredit-newline 也总是绑定不到 RET
      ;; 只有在下面的 mode 中不使用 enable-paredit-mode
      ;; *scratch* buffer 中的 RET 才能正常
      (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)


      (add-hook 'coq-mode-hook              #'enable-paredit-mode)

      ;; (add-hook 'haskell-mode-hook          #'enable-paredit-mode)

      ;; (add-hook 'c-mode-hook                #'enable-paredit-mode)


      (defun maybe-map-paredit-newline ()
        (cond
          ((memq major-mode '(inferior-scheme-mode
                              inferior-shen-mode
                              inferior-emacs-lisp-mode
                              lisp-interaction-mode
                              inferior-haskell-mode))
           (local-set-key (kbd "RET") 'comint-send-input))
          ((memq major-mode '(scheme-mode
                              jojo-mode
                              emacs-lisp-mode
                              lisp-mode
                              lisp-interaction-mode))
           (local-set-key (kbd "RET") 'paredit-newline))
          ))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

      ;; for i want to use paredit a lot of place out of LISP
      ;; i comment out the binding of:
      ;; ";" -> paredit-semicolon
      ;; "M-;" -> paredit-comment-dwim
      ;; in the paredit.el
      (defun maybe-map-paredit-semicolon ()
        (cond
          ((memq major-mode modes-about-lisp)
           (progn
             (local-set-key (kbd ";") 'paredit-semicolon)
             (local-set-key (kbd "M-;") 'paredit-comment-dwim)))
          ))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-semicolon)
      #+end_src

***** >< a easier way to insert "(" ")" (not using)
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (defun my-insert-9 () (interactive) (insert "9"))
      (defun my-insert-0 () (interactive) (insert "0"))

      (add-hook 'scheme-mode-hook
                (lambda ()
                      (local-set-key (kbd "9") 'paredit-open-round)
                      (local-set-key (kbd "0") 'paredit-close-round)
                      (local-set-key (kbd "(") 'my-insert-9)
                      (local-set-key (kbd ")") 'my-insert-0)
                      ))
      #+end_src

***** mini-parentheses-editor
      parentheses /pəˈrɛnθəsiːz/
      is plural form of parenthesis /pəˈrɛnθəsɪs/
      #+begin_src emacs-lisp :tangle ~/.emacs
      (global-set-key (kbd "M-(")         'paredit-wrap-round)
      ;; (global-set-key (kbd "M-{")         'paredit-wrap-round)
      (global-set-key (kbd "C-M-9")       'paredit-wrap-round)
      (global-set-key (kbd "M-c")         'paredit-splice-sexp)
      (global-set-key (kbd "M-r")         'paredit-raise-sexp)
      (global-set-key (kbd "<C-right>")   'paredit-forward-slurp-sexp)
      (global-set-key (kbd "<C-left>")    'paredit-forward-barf-sexp)
      (global-set-key (kbd "M-\"")        'paredit-meta-doublequote)
      (global-set-key (kbd "<C-M-right>") 'paredit-backward-barf-sexp)
      (global-set-key (kbd "<C-M-left>")  'paredit-backward-slurp-sexp)
      ;; (global-set-key (kbd "C-d")         'paredit-forward-delete)
      ;; (global-set-key (kbd "<backspace>") 'paredit-backward-delete)
      ;; (global-set-key (kbd "C-k")         'paredit-kill)
      #+end_src

***** >< paredit-everywhere
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (require 'mini-paredit)

      (add-hook 'haskell-mode-hook            'mini-paredit-mode)
      (add-hook 'inferior-haskell-mode-hook   'mini-paredit-mode)

      (add-hook 'c-mode-hook                  'mini-paredit-mode)

      (add-hook 'coq-mode-hook                'mini-paredit-mode)

      (add-hook 'lua-mode-hook                'mini-paredit-mode)

      (add-hook 'sml-mode-hook                'mini-paredit-mode)

      (add-hook 'coffee-mode-hook             'mini-paredit-mode)
      #+end_src

***** >< experiment
      1. 从 simple.el 中可以学到很多
         file:/usr/local/share/emacs/24.3/lisp/simple.el.gz
         尤其是当找到一个函数是在这里定义的时候

      下面是三组有用的函数
      其中 what-cursor-position 是在 simple.el 中定义的
      #+begin_src emacs-lisp
      (looking-at "")
      (what-cursor-position)
      (insert (what-cursor-position))
      (setq kkk (what-cursor-position))
      (insert kkk)

      (following-char)
      (memq 67 '("C"))
      (char-to-string 67)

      (point)

      (message "kkk")
      #+end_src

*** scheme

***** load-path
      some scheme related files are under this dir
      for hack
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/scheme/")
      (add-to-list 'load-path "~/.emacs.d/scheme/cmuscheme-init-repl/")
      #+end_src

***** scheme-mode
      file used by cmuscheme to init a *scheme* buffer
      for a prescribed interpreter's repl

      one can change the directory to save these files
      by editing the function ``scheme-start-file'' in cmuscheme.el
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-ikarus.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-csi.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-guile.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-petite.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-racket.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-mit-scheme.scm
      #+begin_src emacs-lisp :tangle ~/.emacs
      (require 'cmuscheme)

      (setq scheme-program-name "scheme")
      (setq auto-mode-alist (cons `("\\.sld$" . scheme-mode) auto-mode-alist))
      (setq auto-mode-alist (cons `("\\.ss$" . scheme-mode) auto-mode-alist))
      (setq auto-mode-alist (cons `("\\.sls$" . scheme-mode) auto-mode-alist))

      (defun switch-to-buffer-*scheme* ()
        (interactive)
        (switch-to-scheme 1) ;; (switch-to-buffer "*scheme*")
        (local-set-key (kbd "C-s C-d") 'previous-buffer))
      (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*scheme*)

      (defun split-window-with-named-buffer (buffer-name-string)
        (interactive)
        (cond
         ((= 1 (count-windows))
              (progn
                ;; 下面这两个的组合总能行为正确
                (split-window-vertically (floor (* 0.68 (window-height))))
                (other-window 1)
                (switch-to-buffer buffer-name-string)
                (other-window -1)))

         ;; 只允许出现一个 scheme 窗口
         ;; 因此当发现有别的窗口的时候就在那个窗口中打开所需要的 buffer
         ((not (cl-find buffer-name-string
                    (mapcar (lambda (w) (buffer-name (window-buffer w)))
                            (window-list))
                    :test 'equal))
              (progn
                (other-window 1)
                (switch-to-buffer buffer-name-string)
                (other-window -1)))))

      (defun scheme-send-last-sexp-split-window ()
        (interactive)
        (scheme-send-last-sexp)
        (split-window-with-named-buffer "*scheme*"))

      (defun scheme-send-definition-split-window ()
        (interactive)
        (scheme-send-definition)
        (split-window-with-named-buffer "*scheme*"))

      (add-hook
       'inferior-scheme-mode-hook
       (lambda ()
         (local-set-key (kbd "C-c C-k")
                        (lambda ()
                          (interactive)
                          (kill-buffer)
                          (run-scheme scheme-program-name)))))

      (defun scheme-easy-to-eval ()
        (interactive)
        (if (>= (+ 1 (point))
                (point-max))
            (message "C-<tab> : last sexp is evaled")
            (let ()
              (forward-sexp)
              (scheme-send-last-sexp-split-window))))

      (add-hook
       'scheme-mode-hook
       (lambda ()
         (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
         (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
         (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)
         (local-set-key (kbd "{") (lambda () (interactive) (insert "{}") (backward-char 1)))
         (local-set-key (kbd "}") 'out->)
         ))
      #+end_src

***** scheme-here
      #+begin_src emacs-lisp :tangle ~/.emacs
      (require 'scheme-here)
      (add-hook 'inferior-scheme-mode-hook
                (lambda ()
                      (define-key scheme-mode-map (kbd "C-s C-a") 'scheme-here-send-sexp)))
      #+end_src

***** parenface (not using)
      i actually like these parentheses
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (require 'parenface)
      (set-face-foreground 'paren-face "DimGray")
      #+end_src

***** pretty-lambdas-for-lisp (not using)
      * not using
        for no good font
      #+begin_src emacs-lisp
      (defun pretty-lambdas-for-lisp ()
        (interactive)
        (font-lock-add-keywords
         nil `(("(\\(lambda\\>\\)"
                (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                              993
                                              ;; 923 : Λ
                                              ;; 955 : λ
                                              ;; 411 : ƛ
                                              ;; 654 : ʎ
                                              ;; 992 : Ϡ
                                              ;; 993 : ϡ
                                              )
                              nil))))))


      (add-hook 'scheme-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'inferior-scheme-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'emacs-lisp-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'ielm-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'lisp-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'lisp-interaction-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'org-mode-hook
                'pretty-lambdas-for-lisp)
      #+end_src

***** scheme-add-keywords
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; scheme-mode 中原本的实现不是如此
      (defun scheme-add-keywords (face-name keyword-rules)
        (let* ((keyword-list (mapcar #'(lambda (x)
                                         (symbol-name (cdr x)))
                                     keyword-rules))
               (keyword-regexp (concat "(\\("
                                       (regexp-opt keyword-list)
                                       "\\)[ \n]")))
          (font-lock-add-keywords 'scheme-mode
                                  `((,keyword-regexp 1 ',face-name))))
        (mapc #'(lambda (x)
                  (put (cdr x)
                       'scheme-indent-function
                       (car x)))
              keyword-rules))

      ;; 前面的数字被认为是参数项的个数
      ;; 参数项完全换行时强缩进 其他项弱缩进
      ;; 非语法关键词 所有项在完全换行时都不缩进
      (scheme-add-keywords
       'font-lock-keyword-face
       '(
         ;; the little prover
         (2 . dethm)
         (1 . J-Bob/step)
         (1 . J-Bob/prove)
         (1 . J-Bob/define)

         ;; 下面 scheme 中需要高亮的词
         (0 . set!)
         (0 . set-car!)
         (0 . set-cdr!)
         (0 . vector-set!)
         (1 . quote)
         (1 . quasiquote)
         (1 . unquote)
         (1 . if)
         (1 . apply)
         (1 . letrec*)
         (1 . while)
         ;; 来自扩展的
         (1 . letcc)
         (1 . pmatch)
         (2 . pmatch-who)
         (0 . guard)
         (0 . add-to-list!)
         (0 . add-to-list-end!)
         (0 . append!)
         (0 . insert-a-val-to-a-field-of-a-wlist!)
         (0 . to-a-field-of-a-wlist--let-us-insert-a-val!)

         ;; 来自 ikarus
         (1 . make-parameter)
         (1 . parameterize)

         ;; 下面 scheme 中我还没用到以后可能需要高亮的词
         (1 . when)
         (1 . unless)
         (2 . let1)
         (1 . error)

         ;; 下面是我的解释器中需要高亮的词
         (1 . λ)
         (0 . begin*)
         (1 . def)
         (1 . doc)
         (2 . rewrite-doc)

         ;;
         (2 . ==)
         (1 . fresh)
         (0 . conde)
         (0 . condi)
         (1 . run*)
         (1 . ando+)
         (1 . oro+)
         (0 . ando)
         (0 . oro)
         (0 . trunk)
         (1 . case-inf)

         ;; 下面是 mk 的元代码中需要高亮的词
         ;; [(lambdag@ (p) e) (lambda (p) e)]
         ;; (1 . lambdag@)
         ;; [(lambdaf@ () e) (lambda () e)]
         ;; (1 . lambdaf@)

         (1 . λᴳ)
         (1 . λ~)

         ;;
         (0 . set-pointer!)
         (1 . define-pointer)
         ;; 下面是 vvv-mimic-ccc.scm 中需要高亮的词
         (0 . vons)
         (0 . vnr)
         (0 . v0r)
         (0 . v1r)
         (0 . v2r)
         (0 . v3r)
         (0 . v4r)
         (0 . v5r)
         (0 . v6r)
         (0 . v7r)
         (0 . v8r)
         (0 . v9r)
         (0 . set-vnr!)
         (0 . set-v0r!)
         (0 . set-v1r!)
         (0 . set-v2r!)
         (0 . set-v3r!)
         (0 . set-v4r!)
         (0 . set-v5r!)
         (0 . set-v6r!)
         (0 . set-v7r!)
         (0 . set-v8r!)
         (0 . set-v9r!)

         (0 . vonz)
         (0 . vnz)
         (0 . v0z)
         (0 . v1z)
         (0 . v2z)
         (0 . v3z)
         (0 . v4z)
         (0 . v5z)
         (0 . v6z)
         (0 . v7z)
         (0 . v8z)
         (0 . v9z)
         (0 . set-vnz!)
         (0 . set-v0z!)
         (0 . set-v1z!)
         (0 . set-v2z!)
         (0 . set-v3z!)
         (0 . set-v4z!)
         (0 . set-v5z!)
         (0 . set-v6z!)
         (0 . set-v7z!)
         (0 . set-v8z!)
         (0 . set-v9z!)

         (0 . conz)
         (0 . caz)
         (0 . cdz)
         (0 . set-caz!)
         (0 . set-cdz!)

         ;; 其它可能临时用到的高亮
         (0 . *λ)
         (0 . *l)

         (1 . define-primitive)

         ;; racket
         ;; (1 . require)
         ;; (1 . provide)
         (1 . module)
         (1 . module+)
         (1 . module*)

         (1 . class)
         (2 . class*)
         (1 . interface)
         (2 . mixin)
         (1 . define/public)
         (1 . define/override)
         (1 . new)
         (1 . send)
         (0 . :)
         (0 . ::)
         (1 . super)
         (1 . test-case)
         (0 . check-expect)
         (2 . check-error)

         (1 . match)
         (1 . match*)
         (0 . match-lambda**)
         (0 . fun)
         (1 . just-fun)
         (1 . define/match)

         (2 . syntax-case)
         (1 . syntax-parse)

         (1 . orz)
         (0 . note)

         (1 . type)
         (1 . data)
         (0 . example)
         (0 . effect)
         (2 . oer)

         (1 . create)
         (1 . apply-creator-list)
         (1 . process)
         (1 . apply-processor-list)
         (1 . settle)
         (1 . apply-settler-list)

         (1 . with-handlers)
         (1 . raise)

         (0 . try)
         (1 . back-to-last-try)

         ;; cicada
         (1 . create-primitive-function)

         (2 . define-function)
         (2 . define-variable)
         (2 . define-primitive-function)

         (0 . here)
         (0 . !td)
         (0 . @t)
         (0 . @d)

         (1 . vector-map)

         (1 . match-let)
         (1 . match-let*)

         (2 . deftype)
         (0 . app)
         (1 . with-syntax)

         (0 . ret)
         (0 . return)
         (1 . do/monad)
         (1 . define-monad)

         (0 . ~)
         ;; (0 . +)
         (0 . /)
         (0 . \?)
         (0 . *)
         (0 . !)
         (0 . @)
         (0 . $)
         (0 . \#)
         (0 . &)
         (0 . ^)
         (0 . -)
         (0 . %)
         (0 . =)

         (0 . <)
         (0 . >)

         (0 . =>)
         (0 . =<)
         (0 . <=)
         (0 . >=)

         (1 . define-type)
         (1 . define-data)
         (1 . define-jojo)
         (1 . define-function)

         (1 . map!)

         (0 . var)
         (0 . set)
         (1 . get)

         (0 . tail-call)
         (0 . string)

         (2 . defun)
         (2 . declare)
         (1 . defvar)
         (0 . run)
         (0 . clib)

         (0 . ifte)
         (0 . if3)

         (1 . debug0)

         (1 . with)

         (0 . part)

         (0 . extend-from)

         (0 . lhs)
         (0 . rhs)

         (1 . in)
         (0 . map)

         (0 . use-modules)

         (1 . connect-db)

         (2 . define-class)

         ))
      #+end_src

*** racket
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/racket-mode/")

    (require 'racket-mode)

    ;; (setq auto-mode-alist (cons `("\\.rkt$" . scheme-mode) auto-mode-alist))
    (setq auto-mode-alist (cons `("\\.rkt$" . racket-mode) auto-mode-alist))

    ;; (defun switch-to-buffer-*racket* ()
    ;;   (interactive)
    ;;   (let ()
    ;;     (switch-to-buffer racket--repl-buffer-name t)
    ;;     (with-current-buffer racket--repl-buffer-name
    ;;       (goto-char (point-max))))
    ;;   (local-set-key (kbd "C-s C-d") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*racket*)
    #+end_src

*** dylan
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/dylan-mode/")
    (require 'dime)
    #+end_src


*** lisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (setq inferior-lisp-program "lisp")
    (setq inferior-lisp-program "sbcl")
    ;; (setq inferior-lisp-program "ecl")
    ;; (setq inferior-lisp-program "ccl")

    (defun lisp-easy-to-eval ()
      (interactive)
      (if (>= (+ 1 (point))
              (point-max))
          (message "C-<tab> : last sexp is evaled")
        (let ()
          (forward-sexp)
          (slime-eval-last-expression))))

    (add-hook
     'lisp-mode-hook
     (lambda ()
       (local-set-key (kbd "M-i") 'query-replace)
       (local-set-key (kbd "C-<tab>") 'lisp-easy-to-eval)))
    #+end_src

*** lisp-add-keywords
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun lisp-add-keywords (face-name keyword-rules)
      (let* ((keyword-list
              (mapcar #'(lambda (x)
                          (symbol-name (cdr x)))
                      keyword-rules))
             (keyword-regexp
              (concat "(\\("
                      (regexp-opt keyword-list)
                      "\\)[ \n]")))
        (font-lock-add-keywords
         'lisp-mode
         `((,keyword-regexp 1 ',face-name))))
      (mapc #'(lambda (x)
                (put (cdr x)
                     'lisp-indent-function
                     (car x)))
            keyword-rules))

    ;; note that
    ;; a macro will be turned into keyword by slime
    ;; slime will override the following definition
    ;; but slime does not help some of the colors
    (lisp-add-keywords
     'font-lock-keyword-face
     '(
       (0 . quote)
       (0 . function)
       (0 . values)

       (1 . defin)
       (1 . with)

       (1 . apply)
       (1 . funcall)

       (2 . deftest)
       (3 . ensure)

       (1 . cat)
       (1 . orz)

       (1 . add1!)
       (1 . sub1!)
       (2 . set!)
       (2 . set-car!)
       (2 . set-cdr!)
       (2 . set-end-car!)
       (2 . set-end-cdr!)

       (1 . multiple-value-let)
       ;; (1 . let-fun)
       (1 . help)

       (0 . put)
       (1 . match)
       ))
    #+end_src

*** slime

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; setup load-path and autoloads
    ;; (add-to-list 'load-path "~/.emacs.d/slime-2.17/")
    (add-to-list 'load-path "~/.emacs.d/slime/")

    (setq slime-contribs '(slime-fancy))

    (require 'slime)

    (setf common-lisp-hyperspec-root "/home/xyh/sd0/lang/lisp/docs/hyperspec/"
          slime-complete-symbol-function 'slime-fuzzy-complete-symbol
          lisp-indent-function 'common-lisp-indent-function)

    (add-hook 'slime-repl-mode-hook
              (lambda ()
                (local-set-key (kbd "C-M-.") 'next-buffer)
                (local-set-key (kbd "C-M-,") 'previous-buffer)
                (local-set-key (kbd "C-c C-k") 'slime-restart-inferior-lisp)))
    #+end_src

*** chicken-slime                     :no:

    #+begin_src emacs-lisp :tangle no
    ;; (add-to-list 'load-path "/home/xyh/chicken/lib/chicken/8/")
    ;; (autoload 'chicken-slime "chicken-slime" "SWANK backend for Chicken" t)
    ;; (setq slime-csi-path "/home/xyh/chicken/bin/csi")

    ;; (add-hook 'scheme-mode-hook
    ;;           (lambda ()
    ;;             (slime-mode t)))

    #+end_src

*** elisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-elisp-mode-keywords()
      (font-lock-add-keywords
       nil
       '(("\\<\\(setq\\)" . 'font-lock-keyword-face))))
    (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode-keywords)
    #+end_src

*** emacs-lisp-add-keywords
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun emacs-lisp-add-keywords (face-name keyword-rules)
      (let* ((keyword-list
              (mapcar #'(lambda (x)
                          (symbol-name (cdr x)))
                      keyword-rules))
             (keyword-regexp
              (concat "(\\("
                      (regexp-opt keyword-list)
                      "\\)[ \n]")))
        (font-lock-add-keywords
         'emacs-lisp-mode
         `((,keyword-regexp 1 ',face-name))))
      (mapc #'(lambda (x)
                (put (cdr x)
                     'emacs-lisp-indent-function
                     (car x)))
            keyword-rules))

    (emacs-lisp-add-keywords
     'font-lock-keyword-face
     '(
       (1 . add-hook)
       ))
    #+end_src

*** general seting
    Non-nil means print recursive structures using #N= and #N# syntax.
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq print-circle t)
    #+end_src

*** ielm = run-elisp
    * 不知道哪个傻逼起的 ielm 这个名字
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun run-elisp ()
      (interactive)
      (ielm))

    (defun switch-to-buffer-*elisp-repl* ()
      (interactive)
      (if (member-string? "*elisp-repl*" (mapcar 'buffer-name (buffer-list)))
              (switch-to-buffer "*elisp-repl*")
            (progn
              (ielm)
              (rename-buffer "*elisp-repl*")))
      (local-set-key (kbd "C-s e") 'previous-buffer))
    (global-set-key (kbd "C-s e") 'switch-to-buffer-*elisp-repl*)
    #+end_src


*** shen
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/shen-mode/")
    (require 'shen-mode)
    (require 'inf-shen) ; <- for interaction with an external shen process

    ;; (defun switch-to-buffer-*inferior-shen* ()
    ;;   (interactive)
    ;;   (if (member-string? "*inferior-shen*" (mapcar 'buffer-name (buffer-list)))
    ;;           (switch-to-buffer "*inferior-shen*")
    ;;         (switch-to-shen t))
    ;;   (local-set-key (kbd "C-s C-w") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-w") 'switch-to-buffer-*inferior-shen*)
    #+end_src


*** jojo

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/jojo/")
    (require 'jojo)

    (setq auto-mode-alist (cons `("\\.jo$" . jojo-mode) auto-mode-alist))

    (add-hook
     'jojo-mode-hook
     (lambda ()
       (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
       (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
       (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)
       (local-set-key (kbd "{") (lambda ()
                                  (interactive)
                                  (insert "{}") (backward-char 1)))
       (local-set-key (kbd "}") 'out->)))
    #+end_src

*** egison-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/egison-mode/")
    (require 'egison-mode)
    (autoload 'egison-mode "egison-mode" "Major mode for editing Egison code." t)
    (setq auto-mode-alist (cons `("\\.egi$" . egison-mode) auto-mode-alist))
    #+end_src

*** js

***** js-mode

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-hook
       'js-mode-hook
       (lambda ()
         (setq comment-style 'extra)
         (setq js-indent-level 2)
         (setq js2-basic-offset 2)))
      #+end_src

***** nodejs-repl

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/nodejs-repl/")
      (require 'nodejs-repl)
      ;; (global-set-key (kbd "C-s C-n") 'nodejs-repl)
      (setq nodejs-repl-command "node")
      #+end_src

***** flycheck

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/flycheck/")
      (require 'let-alist)
      (require 'flycheck)

      (add-hook 'js-mode-hook
                (lambda () (flycheck-mode t)))
      ;; (global-flycheck-mode)
      #+end_src

***** simple-httpd                    :no:
      #+begin_src emacs-lisp :tangle no
      ;; (add-to-list 'load-path "~/.emacs.d/emacs-web-server/")
      ;; (require 'simple-httpd)
      #+end_src

***** coffee-mode
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/coffee-mode/")
      (require 'coffee-mode)
      (add-to-list 'auto-mode-alist '("\\.coffee\\'" . coffee-mode))
      (custom-set-variables '(coffee-tab-width 2))

      (add-to-list 'load-path "~/.emacs.d/literate-coffee-mode/")
      (require 'literate-coffee-mode)

      (add-hook
       'coffee-mode-hook
       (lambda ()
         (turn-off-indent)
         (local-set-key (kbd "<return>") 'newline)
         ))
      #+end_src

*** sibilant-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/sibilant-mode/")
    (require 'sibilant-mode)
    #+end_src


*** markdown
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/markdown-mode/")
    (autoload 'markdown-mode "markdown-mode"
           "Major mode for editing Markdown files" t)
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

    (add-hook
     'markdown-mode-hook
     (lambda ()
       (local-set-key (kbd "M-p") 'backward-paragraph)
       (local-set-key (kbd "M-n") 'forward-paragraph)
       ;; (turn-off-indent)
       ))
    #+end_src

*** [not using] DOS
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/DOS/")
    (require 'ntcmd)
    (add-to-list 'auto-mode-alist '("\\.cmd$" . ntcmd-mode))
    (add-to-list 'auto-mode-alist '("\\.bas$" . ntcmd-mode))
    (add-to-list 'auto-mode-alist '("\\.bat$" . ntcmd-mode))

    ;; (require 'dos)
    ;; (require 'batch-mode)
    ;; (require 'cmd-mode)
    #+end_src


*** lfe
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/lfe/")
    (require 'lfe-mode)
    (require 'inferior-lfe)
    (require 'lfe-start)
    #+end_src



*** cicada-nymph
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cicada-nymph-mode/")
    (require 'cicada-nymph-mode)
    (require 'inferior-cicada-nymph-mode)

    ;; (define-prefix-command 'C-s-map)
    ;; (global-set-key (kbd "C-s") 'C-s-map)

    ;; (defun switch-to-buffer-*cicada-nymph* ()
    ;;   (interactive)
    ;;   (if (member-string? "*cicada-nymph*" (mapcar 'buffer-name (buffer-list)))
    ;;       (let ()
    ;;         (switch-to-buffer "*cicada-nymph*")
    ;;         (local-set-key (kbd "C-s C-c") 'previous-buffer))
    ;;       (run-cicada-nymph
    ;;        (read-string "* run cicada-nymph : "
    ;;                     cicada-nymph-program-name))))
    ;; (global-set-key (kbd "C-s C-c") 'switch-to-buffer-*cicada-nymph*)

    (add-hook 'cicada-nymph-mode-hook
     (lambda ()
       (local-set-key (kbd "C-h") 'hippie-expand)
       (local-set-key (kbd "M-i") 'query-replace)
       (local-set-key (kbd "C-c C-e")
                      'cicada-nymph-send-region-and-split-window)
       (local-set-key (kbd "C-<tab>")
                      'cicada-nymph-send-line-and-split-window-and-goto-next-line)))
    #+end_src

*** cicada-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cicada-language-mode/")
    (require 'cicada-language-mode)
    (require 'inferior-cicada-language-mode)

    ;; (define-prefix-command 'C-s-map)
    ;; (global-set-key (kbd "C-s") 'C-s-map)

    (defun switch-to-buffer-*cicada-language* ()
      (interactive)
      (if (member-string? "*cicada-language*" (mapcar 'buffer-name (buffer-list)))
          (let ()
            (switch-to-buffer "*cicada-language*")
            (local-set-key (kbd "C-s C-c") 'previous-buffer))
          (run-cicada-language
           (read-string "* run cicada-language : "
                        cicada-language-program-name))))
    (global-set-key (kbd "C-s C-c") 'switch-to-buffer-*cicada-language*)

    (add-hook 'cicada-language-mode-hook
     (lambda ()
       (local-set-key (kbd "C-h") 'hippie-expand)
       (local-set-key (kbd "M-i") 'query-replace)
       (local-set-key (kbd "C-c C-e")
                      'cicada-language-send-region-and-split-window)
       (local-set-key (kbd "C-<tab>")
                      'cicada-language-send-line-and-split-window-and-goto-next-line)))
    #+end_src

*** return-stack
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/return-stack-mode/")
    (require 'return-stack-mode)
    #+end_src


*** rust
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rust-mode/")
    (autoload 'rust-mode "rust-mode" nil t)
    (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
    (setq rust-indent-offset 2)
    #+end_src

*** go
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/go-mode/")
    (require 'go-mode)

    (add-hook
     'go-mode-hook
     (lambda ()
       (setq tab-width 2)
       (setq indent-tabs-mode nil)))
    #+end_src

*** retro
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/retro/")

    (autoload 'retro-mode "retro-mode.el" "retro mode" t)
    (add-to-list 'auto-mode-alist '("\\.rx\\'" . retro-mode))
    #+end_src



*** forth
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/forth-mode/")
    ;; (require 'forth-mode)

    (defun switch-to-buffer-*forth* ()
      (interactive)
      (if (member-string? "*forth*" (mapcar 'buffer-name (buffer-list)))
          (switch-to-buffer "*forth*")
          (let ((forth-name (read-from-minibuffer "run which forth? : ")))
            (run-forth forth-name)))
      (local-set-key (kbd "C-s C-f") 'previous-buffer))
    (global-set-key (kbd "C-s C-f") 'switch-to-buffer-*forth*)

    (add-to-list 'auto-mode-alist '("\\.frt$" . forth-mode))
    (add-to-list 'auto-mode-alist '("\\.fth$" . forth-mode))
    #+end_src

*** gforth
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/gforth.el/")

    (require 'forth-mode)

    (autoload 'forth-mode "gforth.el")
    (setq auto-mode-alist (cons '("\\.f\\'" . forth-mode)
                                    auto-mode-alist))

    (defun forth-send-paragraph-split-window ()
      (interactive)
      (split-window-with-named-buffer "*forth*")
      (forth-send-paragraph))

    ;; 利用 forth-send-region 来实现 forth-send-line
    ;; 因为不想使用 forth-send-paragraph
    (defun forth-send-line ()
      (interactive)
      (move-beginning-of-line nil)
      (cua-set-mark)
      (move-end-of-line nil)
      (forth-send-region (region-beginning) (region-end))
      (cua-set-mark))

    (defun forth-send-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*forth*")
      (forth-send-line))

    (defun forth-send-line-and-goto-next-line ()
      (interactive)
      (forth-send-line)
      (next-line))


    (add-hook
     'forth-mode-hook
     (function (lambda ()

                     (setq forth-indent-level 4)
                     (setq forth-minor-indent-level 2)
                     (setq forth-hilight-level 3)

                     (local-set-key (kbd "C-h") 'hippie-expand)

                     (local-set-key (kbd "C-x C-e") 'forth-send-line-split-window)
                     (local-set-key (kbd "C-<tab>") 'forth-send-line-and-goto-next-line)
                     (local-set-key (kbd "<return>") 'newline)

                     ;; (turn-off-indent)
                     (local-set-key (kbd "M-i") 'query-replace)

                     ;; (setq comment-start "("!;\ )
                     ;; (setq comment-end " !;\"!;\ )
                     ;; (setq comment-padding" "!;\ )

                     )))
    #+end_src

*** tcl
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq tcl-application "tclsh")


    (defun tcl-eval-defun-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-eval-defun))

    (defun tcl-send-line ()
      (interactive)
      (move-beginning-of-line nil)
      (cua-set-mark)
      (move-end-of-line nil)
      (tcl-eval-region (region-beginning) (region-end))
      (cua-set-mark))

    (defun tcl-send-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-send-line))

    (defun tcl-send-line-and-goto-next-line ()
      (interactive)
      (tcl-send-line)
      (next-line))

    (defun tcl-send-line-and-goto-next-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-send-line)
      (next-line))

    (add-hook
     'tcl-mode-hook
     (function (lambda ()
       ;; note that how a function definition in tcl is viewed as a line
       (local-set-key (kbd "C-<tab>") 'tcl-send-line-and-goto-next-line-split-window)
       (local-set-key (kbd "C-x C-e") 'tcl-send-line-split-window)
       (local-set-key (kbd "C-c C-e") 'tcl-eval-defun-split-window)
       )))
    #+end_src


*** sml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/sml/")
    ;; (defun switch-to-buffer-about-sml ()
    ;;   (interactive)
    ;;   (cond ((member-string? "*hamlet*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*hamlet*"))
    ;;         ((member-string? "*mosml*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*mosml*"))
    ;;         ((member-string? "*poly*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*poly*"))
    ;;         ((member-string? "*sml*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*sml*"))
    ;;         (else
    ;;          ;; (run-sml "sml" "")
    ;;          (run-sml "hamlet" "")
    ;;          ))
    ;;   ;; 然后总能通过向左一个 buffer 回到之前的 buffer
    ;;   ;; 这是笨的解决方法，某些情况下一定会出问题
    ;;   (local-set-key (kbd "C-s C-q") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-q") 'switch-to-buffer-about-sml)

    (autoload 'sml-mode "sml-mode" "Major mode for editing SML." t)
    (autoload 'run-sml "sml-proc" "Run an inferior SML process." t)
    (add-to-list 'auto-mode-alist '("\\.\\(sml\\|sig\\)\\'" . sml-mode))

    (setq sml-program-name "sml")
    ;; (setq sml-program-name "hamlet")

    (require 'sml-mode)

    (add-hook
     'sml-mode-hook
     (lambda ()
       (define-key sml-mode-map (kbd "C-x C-e") 'sml-send-function)
       (turn-off-indent)))
    #+end_src

*** ocaml-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/ocaml-mode/")

    (add-to-list 'auto-mode-alist '("\\.ml[iylp]?$" . caml-mode))
    (autoload 'caml-mode "caml" "Major mode for editing OCaml code." t)
    (autoload 'run-caml "inf-caml" "Run an inferior OCaml process." t)
    (autoload 'camldebug "camldebug" "Run ocamldebug on program." t)
    (add-to-list 'interpreter-mode-alist '("ocamlrun" . caml-mode))
    (add-to-list 'interpreter-mode-alist '("ocaml" . caml-mode))


    ;; (if window-system (require 'caml-hilit))
    (if window-system (require 'caml-font))

    (defun switch-to-buffer-*inferior-caml* ()
       (interactive)
      (if (member-string? "*inferior-caml*" (mapcar 'buffer-name (buffer-list)))
           (switch-to-buffer "*inferior-caml*")
         (run-caml "ocaml"))
       (local-set-key (kbd "C-s C-q") 'previous-buffer))
     (global-set-key (kbd "C-s C-q") 'switch-to-buffer-*inferior-caml*)

    (defun caml-eval-phrase-split-window ()
      (interactive)
      (caml-eval-phrase 1)
      (split-window-with-named-buffer "*inferior-caml*"))

    (add-hook
     'caml-mode-hook
     (lambda ()
       (local-set-key (kbd "C-x C-e") 'caml-eval-phrase-split-window)
       (local-set-key (kbd "C-<tab>") 'caml-eval-phrase-split-window)
       (local-set-key (kbd "<return>") 'electric-newline-and-maybe-indent)
       (turn-off-indent)
       (setq comment-style 'multi-line)))
    #+end_src

*** asm
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; may set this variable in `asm-mode-set-comment-hook',
    ;; which is called near the beginning of mode initialization.
    (add-hook 'asm-mode-set-comment-hook
              (lambda ()
                    (setq asm-comment-char ?\#)
                    ))

    (defun asm-indent-line-by-line ()
      (interactive)
      (asm-indent-line)
      (next-line))

    (add-hook 'asm-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-<tab>") 'asm-indent-line-by-line)
                    ))
    #+end_src

*** gas                               :no:

    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/gas-mode/")

    (require 'gas-mode)
    (add-to-list 'auto-mode-alist '("\\.S\\'" . gas-mode))
    #+end_src

*** fasm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/fasm-mode/")
    (require 'fasm-mode)
    (add-to-list 'auto-mode-alist '("\\.fasm$" . fasm-mode))
    (add-to-list 'auto-mode-alist '("\\.inc$"  . fasm-mode))
    (add-to-list 'auto-mode-alist '("\\.s$"    . fasm-mode))

    (defun fasm-indent-line-and-next-line ()
      (interactive)
      (fasm-indent-line)
      (next-line))

    (add-hook 'fasm-mode-hook
              (lambda ()
                    ;; (setq tab-width 13)
                    ;; (setq indent-tabs-mode t)
                    ;; (local-set-key (kbd "<tab>") 'fasm-indent-line)
                    ;; (local-set-key (kbd "C-<tab>") 'fasm-indent-line-and-next-line)
                    ;; (turn-off-indent)
                    ))
    #+end_src

*** nasm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/nasm/")
    (autoload 'nasm-mode "~/.emacs.d/nasm/nasm-mode.el" "" t)

    (add-to-list 'auto-mode-alist '("\\.asm\\'" . nasm-mode))
    (add-to-list 'auto-mode-alist '("\\.nasm\\'" . nasm-mode))

    ;; To set your own indentation level to LEVEL:
    ;; (add-hook 'nasm-mode-hook
    ;;           (lambda () (setq-default nasm-basic-offset LEVEL)))
    (add-hook 'nasm-mode-hook
              (lambda ()
                    (setq-default nasm-basic-offset 13)
                    (turn-off-indent)
                    ))
    #+end_src


*** clean

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/clean-mode/")
    (setq auto-mode-alist
          (append auto-mode-alist
                  '(("\\.icl$"  . clean-mode)
                    ("\\.dcl$"  . clean-mode)
                    ("\\.prj$"  . clean-project-mode))))

    (autoload 'clean-mode "clean-mode"
       "Major mode for editing Clean scripts." t)
    (autoload 'clean-project-mode "clean-project-mode"
       "Major mode for editing Clean Project Scripts." t)

    (add-hook 'clean-mode-hook
              (lambda ()
                ;; (local-set-key (kbd "M-n") 'forward-paragraph)
                ;; (local-set-key (kbd "M-p") 'backward-paragraph)
                ;; (local-set-key (kbd "<return>") 'newline)
                (turn-off-indent)
                ))
    #+end_src

*** haskell

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/haskell-mode/")
    (require 'haskell-mode)
    (add-to-list 'Info-default-directory-list "~/.emacs.d/haskell-mode/")
    (setq haskell-program-name "ghci")

    ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
    ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
    ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)

    (add-hook 'haskell-mode-hook
              (lambda ()
                ;; (local-set-key (kbd "M-n") 'forward-paragraph)
                ;; (local-set-key (kbd "M-p") 'backward-paragraph)
                ;; (local-set-key (kbd "<return>") 'newline)
                (turn-off-indent)
                ))

    (defun haskell-split-window ()
      (interactive)
      (cond
       ((= 1 (count-windows))
            (split-window-vertically (floor (* 0.68 (window-height))))
            (other-window 1)
            (switch-to-buffer "*haskell*")
            (other-window 1))
       ((not (cl-find "*haskell*"
                       (mapcar (lambda (w) (buffer-name (window-buffer w)))
                               (window-list))
                       :test 'equal))
            (other-window 1)
            (switch-to-buffer "*haskell*")
            (other-window -1))))


    (defun switch-to-buffer-*haskell* ()
      (interactive)
      (progn
            (setq the-buffer-before-switch-to-buffer-*haskell*
              (current-buffer))
            (if (cl-find "*haskell*"
                     (mapcar (lambda (w) (buffer-name w))
                             (buffer-list))
                     :test 'equal)
            (switch-to-buffer "*haskell*")
              (progn (run-haskell) (delete-other-windows)))
            (local-set-key (kbd "C-s C-h") (lambda ()
                                             (interactive)
                                             (switch-to-buffer the-buffer-before-switch-to-buffer-*haskell*)))))
    (global-set-key (kbd "C-s C-h") 'switch-to-buffer-*haskell*)
    #+end_src

*** agda
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/agda-mode/")

    (autoload 'agda2-mode "agda2-mode"
      "Major mode for editing Agda files (version ≥ 2)." t)

    (add-to-list 'auto-mode-alist '("\\.l?agda\\'" . agda2-mode))
    (modify-coding-system-alist 'file "\\.l?agda\\'" 'utf-8)

    (require 'agda2)

    (add-hook 'agda2-mode-hook
              (lambda ()
                ;; (add-to-list 'agda2-include-dirs "/home/xyh/friend/xieyuheng/agda-prelude/src/")
                ))
    #+end_src

*** idris-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/prop-menu-el/")
    (require 'prop-menu)
    (add-to-list 'load-path "~/.emacs.d/idris-mode/")
    (require 'idris-mode)

    (add-hook
     'idris-mode-hook
     (lambda ()
       (local-set-key (kbd "C-M-n") 'idris-next-error)
       (local-set-key (kbd "C-M-p") 'idris-previous-error)
       (local-set-key (kbd "M-n") 'forward-paragraph)
       (local-set-key (kbd "M-p") 'backward-paragraph)
       (local-set-key (kbd "<return>") 'newline)

       (turn-off-indent)))

    (eval-after-load 'idris-mode
      '(progn
        (local-set-key (kbd "<tab>") 'turn-off-indent)))
    #+end_src

*** jonprl
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/yasnippet/")
    (require 'yasnippet)

    (add-to-list 'load-path "~/.emacs.d/jonprl-mode/")
    (require 'jonprl-mode)
    #+end_src

*** twelf

    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/twelf/")
    (require 'twelf)
    (setq twelf-root "/home/xyh/lang/twelf/twelf/")
    (load (concat twelf-root "emacs/twelf-init.el"))
    #+end_src

*** clojure

***** clojure

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/clojure-mode/")
      (require 'clojure-mode)

      ;; (defun clojure-easy-to-eval ()
      ;;   (interactive)
      ;;   (if (>= (+ 1 (point))
      ;;           (point-max))
      ;;       (message "C-<tab> : last sexp is evaled")
      ;;       (let ()
      ;;         (forward-sexp)
      ;;         (cider-eval-last-sexp))))

      (add-hook
       'clojure-mode-hook
       (lambda ()
         (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
         (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
         (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)))

      (defun run-clojure ()
        (interactive)
        ;; (run-scheme "java -cp /home/xyh/lang/clojure/clojure-1.8.0/clojure-1.8.0.jar clojure.main")
        (run-scheme "lein repl"))
      #+end_src

***** queue                           :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/queue/")
      (require 'queue)
      #+end_src

***** cider                           :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/cider/")
      (require 'cider)

      ;; cider-mode (complementing clojure-mode)
      ;; that allows you to evaluate code in your Clojure source files
      ;; and load it directly in the REPL
      ;; (eval-after-load "clojure-mode" '(cider-mode t))
      (add-hook 'clojure-mode-hook (lambda () (cider-mode t)))

      ;; Enable eldoc in Clojure buffers:
      (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)


      ;; You can control the TAB key behavior in the REPL via
      ;; cider-repl-tab-command
      ;; default is command cider-repl-indent-and-complete-symbol
      ;; to only indent:
      ;; (setq cider-repl-tab-command 'indent-for-tab-command)

      ;; Prevent the auto-display of the REPL buffer in a separate window
      ;; after connection is established:
      ;; (setq cider-repl-pop-to-buffer-on-connect nil)

      ;; Stop the error buffer from popping up
      ;; while working in buffers other than the REPL
      (setq cider-popup-stacktraces nil)

      ;; Enable error buffer popping also in the REPL:
      ;; (setq cider-repl-popup-stacktraces t)

      ;; To auto-select the error buffer when it's displayed:
      ;; (setq cider-auto-select-error-buffer t)

      ;; in The REPL buffer name
      ;; display the port on which the nREPL server is running
      ;; Buffer name will look like cider-repl project-name:port
      (setq nrepl-buffer-name-show-port t)

      ;; Make C-c C-z switch to the CIDER REPL buffer in the current window:
      ;; (setq cider-repl-display-in-current-window t)

      ;; Limit the number of items of each collection the printer will print to 100:
      ;; (setq cider-repl-print-length 100) ; the default is nil, no limit

      ;; Change the result prefix for REPL evaluation (by default there's no prefix):
      ;; (set cider-repl-result-prefix ";; => ")
      ;; And here's the result of that change:
      ;; user> (+ 1 2)
      ;; ;; => 3

      ;; Change the result prefix for interactive evaluation (by default it's =>):
      ;; (set cider-interactive-eval-result-prefix ";; => ")
      ;; To remove the prefix altogether just set it to an empty string("").

      ;; Normally code you input in the REPL is
      ;; font-locked with cider-repl-input-face (after you press RET)
      ;; and results are font-locked with cider-repl-output-face
      ;; If you want them to be font-locked as in clojure-mode use the following:
      ;; (setq cider-repl-use-clojure-font-lock t)

      ;; You can control the C-c C-z key behavior of switching to the REPL buffer
      ;; with the cider-switch-to-repl-command variable.
      ;; default command cider-switch-to-relevant-repl-buffer
      ;; cider-switch-to-current-repl-buffer offers a simpler alternative
      ;; where CIDER will not attempt to match the correct REPL buffer
      ;; based on underlying project directories:
      ;; (setq cider-switch-to-repl-command 'cider-switch-to-current-repl-buffer)


      ;; to make the REPL history wrap around when its end is reached:
      (setq cider-repl-wrap-history t)

      ;; To adjust the maximum number of items kept in the REPL history:
      (setq cider-repl-history-size 1000) ; the default is 500

      ;; To store the REPL history in a file:
      ;; (setq cider-repl-history-file "path/to/file")
      ;; Note that the history is written to the file when you kill the REPL buffer
      ;; (which includes invoking cider-quit) or you quit Emacs
      #+end_src

*** erlang

    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/erlmode/")
    (require 'erlmode-start)
    #+end_src

*** elixir
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/elixir-mode/")
    (require 'elixir-mode)
    (require 'inferior-elixir-mode)
    #+end_src

*** prolog

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/prolog/prolog-mode/")
    (require 'prolog)

    (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
    (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
    (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)

    (setq prolog-system 'swi)
    (setq prolog-indent-width 2)

    (setq auto-mode-alist
          (append '(("\\.pl$" . prolog-mode)
                    ("\\.m$" . mercury-mode))
                  auto-mode-alist))
    (add-hook
     'prolog-mode-hook
     (lambda ()
       (local-set-key (kbd "M-i") 'query-replace)
       (local-set-key (kbd "C-c C-k")
                      (lambda ()
                        (interactive)
                        (run-prolog t)
                        (other-window -1)))))

    (add-hook
     'prolog-inferior-mode-hook
     (lambda ()
       (local-set-key (kbd "C-c C-k")
                      (lambda ()
                        (interactive)
                        (run-prolog t)))))
    #+end_src

*** free-pascal
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/freepascal-mode/")
    (require 'pascal)
    (setq pascal-indent-level       3
              pascal-case-indent        2
              pascal-auto-newline       nil
              pascal-tab-always-indent  t
              pascal-auto-endcomments   t
              pascal-auto-lineup        '(all)
              pascal-type-keywords      '("array" "file" "packed" "char"
                                      "integer" "real" "string" "record")
              pascal-start-keywords     '("begin" "end" "function" "procedure"
                                      "repeat" "until" "while" "read" "readln"
                                      "reset" "rewrite" "write" "writeln")
              pascal-separator-keywords '("downto" "else" "mod" "div" "then"))
    #+end_src

*** c

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq-default c-basic-offset 2)
    (add-hook
     'c-mode-hook
     (lambda ()
       ;; (setq comment-style 'extra)
       (setq comment-start "//")
       (setq comment-end "")))
    #+end_src

*** python
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq py-install-directory "~/.emacs.d/python-mode/")
    (add-to-list 'load-path py-install-directory)
    (require 'python-mode)


    (defun python-easy-to-eval ()
      (interactive)
      (if (>= (+ 1 (point))
              (point-max))
          (message "C-<tab> : last sexp is evaled")
          (let ()
            (py-forward-statement)
            (py-execute-statement))))

    (add-hook
     'python-mode-hook
     (lambda ()
       (local-set-key (kbd "C-<tab>") 'python-easy-to-eval)))

    (add-hook
     'py-python-shell-mode-hook
     (lambda ()
       (local-set-key (kbd "M-<tab>") 'window->)))
    #+end_src

*** hy
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/hy-mode/")
    (require 'hy-mode)
    #+end_src


*** java
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-indent-setup ()
      (c-set-offset 'arglist-intro '+))

    (add-hook 'java-mode-hook 'my-indent-setup)
    #+end_src

*** vala
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/vala-mode/")
    (autoload 'vala-mode "vala-mode" "Major mode for editing Vala code." t)
    (add-to-list 'auto-mode-alist '("\\.vala$" . vala-mode))
    (add-to-list 'auto-mode-alist '("\\.vapi$" . vala-mode))
    (add-to-list 'file-coding-system-alist '("\\.vala$" . utf-8))
    (add-to-list 'file-coding-system-alist '("\\.vapi$" . utf-8))
    #+end_src


*** nimrod
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/nimrod-mode/")
    (require 'nimrod-mode)
    #+end_src


*** ProofGeneral                      :no:
    #+begin_src emacs-lisp :tangle no
    ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral-4.2/ProofGeneral/generic/")
    ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral/generic/")
    (load-file "~/.emacs.d/ProofGeneral/generic/proof-site.elc")

    ;; (require 'proof-site) must be away after org-mode is turned on
    ;; i don't know way

    ;; (defun org/prepare-for-coq-code-block ()
    ;;   (interactive)
    ;;   (require 'proof-site))

    ;; (eval-after-load "coq-mode"
    ;;   '(define-key coq-mode-map (kbd ";") 'c-electric-semi&comma))
    #+end_src

*** coq                               :no:
    #+begin_src emacs-lisp :tangle no
    ;; (add-to-list 'load-path "~/.emacs.d/coq/")

    ;; rebinding keys for interactively proof
    (add-hook 'coq-mode-hook
              (lambda ()
                (set (make-local-variable
                      'comment-style)  'extra-line)

                (local-set-key (kbd "M-p") 'backward-paragraph)
                (local-set-key (kbd "M-n") 'forward-paragraph)
                ;; M-p used to runs the command pg-previous-matching-input-from-input
                (local-set-key (kbd "C-M-n") 'proof-assert-next-command-interactive)
                (local-set-key (kbd "C-M-p") 'proof-undo-last-successful-command)
                ))

    ;; pretty-lambdas-for-coq

    ;; i do not fully understand
    ;; how the arg:KEYWORDS of font-lock-add-keywords works
    ;; which is very complicated
    ;; but the following returns what i want
    ;; which is so very cool !!!

    ;; (defun pretty-display-for-coq ()
    ;;   (interactive)
    ;;   ;; (font-lock-add-keywords
    ;;   ;;  nil
    ;;   ;;  `(("fun " (0
    ;;   ;;             (progn
    ;;   ;;               (compose-region (match-beginning 0)
    ;;   ;;                               (+ (match-beginning 0) 3)
    ;;   ;;                               "λ")
    ;;   ;;               nil)))))
    ;;   ;; (font-lock-add-keywords
    ;;   ;;  nil
    ;;   ;;  `(("=> " (0
    ;;   ;;            (progn
    ;;   ;;              (compose-region (match-beginning 0)
    ;;   ;;                              (+ (match-beginning 0) 2)
    ;;   ;;                              ".")
    ;;   ;;              nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("fun .*? =>" (0
    ;;                    (progn
    ;;                          ;; \x->f(g x) change to λx.f(g x)
    ;;                          (compose-region (match-beginning 0)
    ;;                                          (+ (match-beginning 0) 3)
    ;;                                          "λ")
    ;;                          (compose-region (- (match-end 0) 2)
    ;;                                          (match-end 0)
    ;;                                          ".")
    ;;                          nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("\\\\/" (0
    ;;                  (progn
    ;;                    (compose-region (match-beginning 0)
    ;;                                    (+ (match-beginning 0) 2)
    ;;                                    "∨")
    ;;                    nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("/\\\\" (0
    ;;                  (progn
    ;;                    (compose-region (match-beginning 0)
    ;;                                    (+ (match-beginning 0) 2)
    ;;                                    "∧")
    ;;                    nil)))))
    ;;   ;; use "forall " to match the word
    ;;   ;; and use "∀" to compose-region [0-6]
    ;;   ;; but not "∀ " to compose-region [0-7]
    ;;   ;; this is very important !!!
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("forall " (0
    ;;                 (progn
    ;;                   (compose-region (match-beginning 0)
    ;;                                   (+ (match-beginning 0) 6)
    ;;                                   "∀")
    ;;                   nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("exists " (0
    ;;                 (progn
    ;;                   (compose-region (match-beginning 0)
    ;;                                   (+ (match-beginning 0) 6)
    ;;                                   "∃")
    ;;                   nil))))))

    ;; (add-hook 'coq-mode-hook
    ;;           'pretty-display-for-coq)
    ;; (add-hook 'coq-goals-mode-hook
    ;;           'pretty-display-for-coq)
    ;; (add-hook 'coq-response-mode-hook
    ;;           'pretty-display-for-coq)
    #+end_src

*** ruby

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/inf-ruby/")
    (require 'inf-ruby)
    (autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
    (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

    (add-to-list 'load-path "~/.emacs.d/enhanced-ruby-mode/")
    (require 'enh-ruby-mode)
    (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
    (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
    (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))

    ;; (defun ruby-send-line ()
    ;;   (interactive)
    ;;   (move-beginning-of-line nil)
    ;;   (cua-set-mark)
    ;;   (move-end-of-line nil)
    ;;   (ruby-send-region (region-beginning) (region-end))
    ;;   (cua-set-mark)
    ;;   (move-end-of-line nil))

    ;; (defun ruby-easy-to-eval ()
    ;;   (interactive)
    ;;   (if (>= (+ 1 (point))
    ;;           (point-max))
    ;;       (message "C-<tab> : last sexp is evaled")
    ;;       (let ()
    ;;         (ruby-send-line)
    ;;         (next-line)
    ;;         (move-end-of-line nil))))

    ;; (add-hook
    ;;  'ruby-mode-hook
    ;;  (lambda ()
    ;;    (local-set-key (kbd "C-<tab>") 'ruby-easy-to-eval)))
    #+end_src


*** lua

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/lua-mode/")

    (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))

    (add-hook 'lua-mode-hook  (lambda ()
            (define-key lua-mode-map (kbd "C-<tab>") 'lua-send-current-line)
            (define-key lua-mode-map (kbd "C-x C-e") 'lua-send-defun)
            (define-key lua-mode-map (kbd "C-x C-r") 'lua-send-region)
            (define-key lua-mode-map (kbd "C-c C-e") 'lua-send-defun)
            (define-key lua-mode-map (kbd "C-c C-r") 'lua-send-region)
            ))
    #+end_src


*** yaml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/yaml-mode/")
    (require 'yaml-mode)
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))

    (add-hook 'yaml-mode-hook
                          '(lambda ()
                                 (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
    #+end_src


*** makefile
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun insert-tab ()
      (interactive)
      (insert 9))


    (add-hook 'makefile-mode-hook
              '(lambda ()
                     (local-set-key (kbd "<tab>") 'insert-tab)))
    #+end_src

*** cmake
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cmake-mode/")
    (require 'cmake-mode)
    #+end_src


*** BNF
    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-generic-mode 'bnf-mode
     () ;; comment char: inapplicable because # must be at start of line
     nil ;; keywords
     '(
       ("^#.*" . 'font-lock-comment-face) ;; comments at start of line
       ;; ("^<[^ \t\n]*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
       ;; ("<[^ \t\n]*?>" . 'font-lock-builtin-face) ;; other nonterminals
       ;; 下面的版本中<>里可以有空格
       ("^<.*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
       ("<.*?>" . 'font-lock-builtin-face) ;; other nonterminals
       ("::=" . 'font-lock-const-face) ;; "goes-to" symbol
       ("\|" . 'font-lock-warning-face) ;; "OR" symbol
       )
     '("\\.bnf\\'") ;; filename suffixes
     nil ;; extra function hooks
     "Major mode for BNF highlighting.")
    #+end_src


*** liquid-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;;; NOTES:
    ;;;   - two syntax matching types:
    ;;;     1) "regex" . font-lock-name
    ;;;     2) "regex" (capture-group-id font-lock-name)
    ;;;   - variable name regex: \\(?:\\w\\|\\.\\|_\\)+
    ;;;
    ;;; TODO:
    ;;;   - strings can be in single quotes
    ;;;   - detect string vs. object value types
    ;;;   - detect boolean operators (and|or)
    ;;;   - add groups for cycle tags
    ;;;   - for:
    ;;;     - add limit:n, offset:n
    ;;;     - add reversed
    ;;;     - add support for ranges

    (setq liquidKeywords
                  '(
                    ;;; core stuff
                    ("{%\\|%}\\|{{\\|}}" . font-lock-comment-face) ;;; liquid tag delimiters
                    ("{%\s*\\(assign\\|capture\\|endcapture\\|for\\|endfor\\|if\\|endif\\|comment\\|endcomment\\|else\\|elsif\\|unless\\|endunless\\|case\\|when\\|endcase\\|cycle\\)" (1 font-lock-keyword-face)) ;;; liquid construct tags
                    ("forloop" . font-lock-keyword-face)
                    ("forloop.\\(length\\|index0\\|index\\|rindex0\\|rindex\\|first\\|last\\)" (1 font-lock-variable-name-face))
                    ("{%\s*\\(?:assign\\|capture\\|for\\|if\\|unless\\|case\\|when\\)\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable after assign|capture|for|if

                    ("{{\s*\\(\\(?:\\w\\|\\.\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable/object being outputted

                    ;;; filter stuff (hack, only supports 2 chained filters)
                    ("\s+|\s+" . font-lock-comment-face) ;;; liquid tag delimiters
                    ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if
                    ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\w+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if

                    ;;; if/else stuff
                    ("{%\s*\\(?:if\\|unless\\)\s+\\(?:\\w\\|\\.\\)+\s+\\(contains\\|>\\|<\\|==\\|!=\\)" (1 font-lock-keyword-face)) ;;; liquid operators

                    ;;; for loop stuff
                    ("{%\s*for\s+\\w+\s+\\(in\\)" (1 font-lock-keyword-face)) ;;; the 'in' in "for temp in collection"
                    ("{%\s*for\s+\\w+\s+in\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; the 'collection' in "for temp in collection"
                    )
                  )
    (define-derived-mode liquid-mode html-mode
          (setq font-lock-defaults '(liquidKeywords))
          (setq mode-name "liquid mode")
          )
    #+end_src


*** fish
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/fish-mode/")
    (require 'fish-mode)
    #+end_src

* org-mode

*** change                            :no:

    - (org-escape-code-in-region (point-min) (point-max))
      in org-edit-src-code
      in lisp/org-src.el

*** path

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/org/lisp/")
    (require 'org)
    #+end_src

*** export

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-html-head-include-default-style nil)

    (setq org-html-preamble t)
    (setq org-html-preamble-format
          '(("en" ".")))

    (setq org-html-postamble t)
    (setq org-html-postamble-format
          '(("en" ".")))
    #+end_src

*** publishing

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-publish-project-alist
          '(("the-little-language-designer"
             :base-directory "~/cicada-nymph/"
             :publishing-directory "~/cicada-nymph/"
             :publishing-function org-html-publish-to-html
             :section-numbers nil
             :with-toc nil
             :html-head "<link rel=\"stylesheet\"
                        href=\"../other/mystyle.css\"
                        type=\"text/css\"/>")))
    #+end_src

*** **-in-org
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun **-in-org ()
      "abc ==> *abc*"
      (interactive)
      (progn
            (insert "*")
            (org-end-of-line)
            (insert "*")))
    #+end_src

*** key binding
    #+begin_src emacs-lisp :tangle ~/.emacs
    (eval-after-load 'org
      '(progn

        ;; **-in-org
        (define-key org-mode-map (kbd "M-*") '**-in-org)

        ;; cruise
        (define-key org-mode-map (kbd "M-n") 'outline-next-visible-heading)
        (define-key org-mode-map (kbd "M-p") 'outline-previous-visible-heading)
        ;; (define-key org-mode-map (kbd "M-n") 'org-forward-paragraph)
        ;; (define-key org-mode-map (kbd "M-p") 'org-backward-paragraph)
        (define-key org-mode-map (kbd "<M-up>") nil)
        (define-key org-mode-map (kbd "<M-down>") nil)

        (define-key org-mode-map (kbd "M-e") 'backward-sexp)

        ;; text migration
        ;; ``org-metaup'' and ``org-metadown''
        ;; are really dangerous functions
        ;; so it should be as hard as possible to mis-type it
        (define-key org-mode-map (kbd "C-M-p") 'org-metaup)
        (define-key org-mode-map (kbd "C-M-n") 'org-metadown)

        ;; in babel
        (define-key org-mode-map (kbd "M-.") 'org-babel-next-src-block)
        (define-key org-mode-map (kbd "M-,") 'org-babel-previous-src-block)
        (define-key org-mode-map (kbd "C-s C-s") 'org-edit-src-code)
        ;; (turn-off-indent)
        ))

    ;; (add-hook
    ;;  'org-mode-hook
    ;;  (lambda ()

    ;;    ;; **-in-org
    ;;    (local-set-key (kbd "M-*") '**-in-org)

    ;;    ;; cruise
    ;;    (local-set-key (kbd "M-n") 'outline-next-visible-heading)
    ;;    (local-set-key (kbd "M-p") 'outline-previous-visible-heading)
    ;;    (local-set-key (kbd "<M-up>") nil)
    ;;    (local-set-key (kbd "<M-down>") nil)

    ;;    ;; text migration
    ;;    ;; ``org-metaup'' and ``org-metadown''
    ;;    ;; are really dangerous functions
    ;;    ;; so it should be as hard as possible to mis-type it
    ;;    (local-set-key (kbd "C-M-p") 'org-metaup)
    ;;    (local-set-key (kbd "C-M-n") 'org-metadown)

    ;;    ;; in babel
    ;;    (local-set-key (kbd "M-.") 'org-babel-next-src-block)
    ;;    (local-set-key (kbd "M-,") 'org-babel-previous-src-block)
    ;;    (local-set-key (kbd "C-s C-s") 'org-edit-src-code)
    ;;    ))

    (add-hook
     'org-src-mode-hook
     (lambda ()
       (local-set-key (kbd "C-s C-s") 'org-edit-src-exit)
       ))
    #+end_src

*** variable
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'org-mode-hook
          (lambda ()
            (setq case-fold-search nil)))

    (setq org-startup-indented nil)
    (setq org-babel-no-eval-on-ctrl-c-ctrl-c t)
    ;; (setq org-agenda-window-setup )
    ;; (setq org-agenda-restore-windows-after-quit )

    (setq org-hide-leading-stars t)
    (setq org-odd-levels-only t)
    #+end_src

*** todo-keyword
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-todo-keywords
          '((sequence "><" "|" "><><" "|" "><><><")
            (sequence "[todo-list]" "|" "[todo-stack]" "|" "[maybe]")
            (sequence "[note]" "|" "[test]")))
    #+end_src

*** tag
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-tags-column 38)
    #+end_src

*** [babel] load-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (org-babel-do-load-languages
       'org-babel-load-languages
       '())
    #+end_src

*** [babel] edit
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'org-mode-hook
              (lambda ()
                (setq org-src-preserve-indentation nil)
                (setq org-src-do-not-insert-comma t)
                (setq org-edit-src-content-indentation 0)
                (setq org-src-fontify-natively t)
                ;; if turn on the above variable, structure-template-alist will be unable to use
                ;; (setq org-src-tab-acts-natively t)
                (setq org-src-window-setup 'current-window)
                (setq org-src-ask-before-returning-to-edit-buffer nil)))
    #+end_src

*** [babel] structure-template-alist

***** [note]
      1. C-c C-v d
         org-babel-demarcate-block
      2. begin_src <lang-name> 会去搜索<lang-name>的 major-mode
         只要能搜索到就都能用编辑功能
      3. ob-<lang-name>.el 是用来提供更多的关于语言的其他功能的

***** basic
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-basic
            '(
              ;; just src
              ("sf" "#+end_src\n?\n#+begin_src" "<src lang=\"?\">\n\n</src>")
              ("s" "#+begin_src\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; picture
              ("picturef" "#+end_src\n?\n#+begin_src picture" "<src lang=\"?\">\n\n</src>")
              ("picture" "#+begin_src picture\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; not using
              ;; ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
              ;; ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
              ;; ("C" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
              ;; ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
              ;; ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
              ;; ("l" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>")
              ;; ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
              ;; ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
              ;; ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
              ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII")
              ;; ("A" "#+ASCII: ")
              ;; ("i" "#+INDEX: ?" "#+INDEX: ?")
              ;; ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")

              ))
      #+end_src

***** erlang-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-erlang-family
            '(
              ;; perl
              ("plf" "#+end_src\n?\n#+begin_src prolog" "<src lang=\"?\">\n\n</src>")
              ("pl" "#+begin_src prolog\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; erlang
              ("erlangf" "#+end_src\n?\n#+begin_src erlang" "<src lang=\"?\">\n\n</src>")
              ("erlang" "#+begin_src erlang\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lfe
              ("lfef" "#+end_src\n?\n#+begin_src lfe" "<src lang=\"?\">\n\n</src>")
              ("lfe" "#+begin_src lfe\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** lisp-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-lisp-family
            '(
              ;; scheme
              ("ssf" "#+end_src\n?\n#+begin_src scheme" "<src lang=\"?\">\n\n</src>")
              ("ss" "#+begin_src scheme\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; jojo
              ("jof" "#+end_src\n?\n#+begin_src jojo" "<src lang=\"?\">\n\n</src>")
              ("jo" "#+begin_src jojo\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; racket
              ("srf" "#+end_src\n?\n#+begin_src racket" "<src lang=\"?\">\n\n</src>")
              ("sr" "#+begin_src racket\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lisp
              ("lispf" "#+end_src\n?\n#+begin_src lisp" "<src lang=\"?\">\n\n</src>")
              ("lisp" "#+begin_src lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; shen
              ("shenf" "#+end_src\n?\n#+begin_src shen" "<src lang=\"?\">\n\n</src>")
              ("shen" "#+begin_src shen\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; clojure
              ("clojuref" "#+end_src\n?\n#+begin_src clojure" "<src lang=\"?\">\n\n</src>")
              ("clojure" "#+begin_src clojure\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; emacs-lisp
              ("seef" "#+end_src\n?\n#+begin_src emacs-lisp :tangle ~/.emacs" "<src lang=\"?\">\n\n</src>")
              ("see" "#+begin_src emacs-lisp :tangle ~/.emacs\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("sef" "#+end_src\n?\n#+begin_src emacs-lisp" "<src lang=\"?\">\n\n</src>")
              ("se" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** forth-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-forth-family
            '(
              ;; cicada-nymph
              ("cnf" "#+end_src\n?\n#+begin_src cicada-nymph" "<src lang=\"?\">\n\n</src>")
              ("cn" "#+begin_src cicada-nymph\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; cicada-language
              ("clf" "#+end_src\n?\n#+begin_src cicada-language" "<src lang=\"?\">\n\n</src>")
              ("cl" "#+begin_src cicada-language\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; forth
              ("forthf" "#+end_src\n?\n#+begin_src forth" "<src lang=\"?\">\n\n</src>")
              ("forth" "#+begin_src forth\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** ml-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-ml-family
            '(
              ;; sml
              ("smlf" "#+end_src\n?\n#+begin_src sml" "<src lang=\"?\">\n\n</src>")
              ("sml" "#+begin_src sml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; caml
              ("camlf" "#+end_src\n?\n#+begin_src caml" "<src lang=\"?\">\n\n</src>")
              ("caml" "#+begin_src caml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** asm-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-asm-family
            '(
              ;; fasm
              ("fasmf" "#+end_src\n?\n#+begin_src fasm" "<src lang=\"?\">\n\n</src>")
              ("fasm" "#+begin_src fasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; nasm
              ("nasmf" "#+end_src\n?\n#+begin_src nasm" "<src lang=\"?\">\n\n</src>")
              ("nasm" "#+begin_src nasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** mark-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-mark-language
            '(
              ;; yaml
              ("yamlf" "#+end_src\n?\n#+begin_src yaml" "<src lang=\"?\">\n\n</src>")
              ("yaml" "#+begin_src yaml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; css
              ("cssf" "#+end_src\n?\n#+begin_src css" "<src lang=\"?\">\n\n</src>")
              ("css" "#+begin_src css\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; bnf
              ("bnff" "#+end_src\n?\n#+begin_src bnf" "<src lang=\"?\">\n\n</src>")
              ("bnf" "#+begin_src bnf\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** c-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-c-family
            '(
              ;; c
              ("cf" "#+end_src\n?\n#+begin_src c" "<src lang=\"?\">\n\n</src>")
              ("c" "#+begin_src c\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; java
              ("javaf" "#+end_src\n?\n#+begin_src java" "<src lang=\"?\">\n\n</src>")
              ("java" "#+begin_src java\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; js
              ("jsf" "#+end_src\n?\n#+begin_src js" "<src lang=\"?\">\n\n</src>")
              ("js" "#+begin_src js\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; coffeescript
              ("cof" "#+end_src\n?\n#+begin_src coffee" "<src lang=\"?\">\n\n</src>")
              ("co" "#+begin_src coffee\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; py
              ("pyf" "#+end_src\n?\n#+begin_src python" "<src lang=\"?\">\n\n</src>")
              ("py" "#+begin_src python\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lua
              ("luaf" "#+end_src\n?\n#+begin_src lua" "<src lang=\"?\">\n\n</src>")
              ("lua" "#+begin_src lua\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; perl
              ("perlf" "#+end_src\n?\n#+begin_src perl" "<src lang=\"?\">\n\n</src>")
              ("perl" "#+begin_src perl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; shell
              ("shf" "#+end_src\n?\n#+begin_src sh" "<src lang=\"?\">\n\n</src>")
              ("sh" "#+begin_src sh\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** human-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-human-language
            '(
              ;; lojban
              ("ljf" "#+end_src\n?\n#+begin_src lojban" "<src lang=\"?\">\n\n</src>")
              ("lj" "#+begin_src lojban\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** proof-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-proof-language
            '(
              ;; coq
              ("coqf" "#+end_src\n?\n#+begin_src coq" "<src lang=\"?\">\n\n</src>")
              ("coq" "#+begin_src coq\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** haskell
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-haskell-family
            '(
              ;; haskell
              ("hsf" "#+end_src\n?\n#+begin_src haskell" "<src lang=\"?\">\n\n</src>")
              ("hs" "#+begin_src haskell\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; agda
              ("agf" "#+end_src\n?\n#+begin_src agda2" "<src lang=\"?\">\n\n</src>")
              ("ag" "#+begin_src agda2\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; idris
              ("idf" "#+end_src\n?\n#+begin_src idris" "<src lang=\"?\">\n\n</src>")
              ("id" "#+begin_src idris\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** other-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-other-family
            '(
              ;; fish
              ("fishf" "#+end_src\n?\n#+begin_src fish" "<src lang=\"?\">\n\n</src>")
              ("fish" "#+begin_src fish\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; sql
              ("sqlf" "#+end_src\n?\n#+begin_src sql" "<src lang=\"?\">\n\n</src>")
              ("sql" "#+begin_src sql\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; ruby
              ("rubyf" "#+end_src\n?\n#+begin_src ruby" "<src lang=\"?\">\n\n</src>")
              ("ruby" "#+begin_src ruby\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; tcl
              ("tclf" "#+end_src\n?\n#+begin_src tcl" "<src lang=\"?\">\n\n</src>")
              ("tcl" "#+begin_src tcl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; for many kinds of conf-modes
              ("conff" "#+end_src\n?\n#+begin_src conf :tangle " "<src lang=\"?\">\n\n</src>")
              ("conf" "#+begin_src conf :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("confuf" "#+end_src\n?\n#+begin_src conf-unix :tangle " "<src lang=\"?\">\n\n</src>")
              ("confu" "#+begin_src conf-unix :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("confxf" "#+end_src\n?\n#+begin_src conf-xdefaults :tangle " "<src lang=\"?\">\n\n</src>")
              ("confx" "#+begin_src conf-xdefaults :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ))
      #+end_src

***** main
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-alist
            (append
             org-structure-template-basic

             org-structure-template-mark-language
             org-structure-template-proof-language
             org-structure-template-human-language

             org-structure-template-lisp-family
             org-structure-template-forth-family
             org-structure-template-ml-family
             org-structure-template-erlang-family

             org-structure-template-asm-family
             org-structure-template-c-family

             org-structure-template-haskell-family

             org-structure-template-other-family

             ))
      #+end_src

*** [babel] evaluation
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-hook 'org-mode-hook
    ;;           (lambda ()
    ;;             (setq org-confirm-babel-evaluate nil)))

    ;; default arguments to use when evaluating a source block
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache   . "no")
            (:noweb   . "yes")
            (:hlines  . "no")
            (:tangle  . "no")

            ;; shebang `#!' needs the following
            ;; (:padline . "no")

            (:padline . "yes")
            ))
    #+end_src

*** [agenda] setting

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-agenda-files "~/.emacs.d/agenda/file-name-list")
    (global-set-key (kbd "C-M-o") 'org-cycle-agenda-files)
    (global-set-key (kbd "C-c a") 'org-agenda)

    ;; (define-prefix-command 'C-o-map)
    ;; (global-set-key (kbd "C-o") 'C-o-map)
    ;; (global-set-key (kbd "C-o C-b") 'org-iswitchb)

    (eval-after-load 'org
      '(progn
        (define-key org-mode-map (kbd "C-c C-l") 'org-toggle-link-display)))
    #+end_src

*** [agenda] org-agenda-files
    tangle take too long so just edit
    file:~/.org-agenda-files

* my org-mode

*** org-get-code-block-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun org-get-code-block-path ()
      (let* ((element (org-element-at-point))
             (type (org-element-type element))
             (parameters (org-element-property :parameters element))
             (tangle-begin
              (string-match (rx (seq
                                 ":tangle"
                                 (one-or-more " ")))
                            parameters))
             (tangle-end
              (string-match (rx (seq
                                 (one-or-more " ")))
                            parameters
                            tangle-begin))
             (path-begin
              (string-match (rx (seq
                                 (one-or-more (not (in " ")))))
                            parameters
                            tangle-end))
             (path-end
              (string-match (rx (seq
                                 (one-or-more (in " "))))
                            parameters
                            path-begin)))
        (unless (and (memq type '(example-block src-block))
                     (org-src--on-element-p element))
          (user-error "Not in a source or example block"))
        (substring parameters path-begin path-end)))

    (defun really-kill-buffer ()
      (interactive)
      (kill-buffer (current-buffer)))

    (defun org-switch-to-code-block-file ()
      (interactive)
      (find-file (org-get-code-block-path))
      (local-set-key (kbd "C-s C-a") 'really-kill-buffer))
    (global-set-key (kbd "C-s C-a") 'org-switch-to-code-block-file)
    #+end_src

* app

*** command-log-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/command-log-mode/")
    (require 'command-log-mode)

    (add-hook 'org-mode-hook 'command-log-mode)

    (add-hook 'elisp-mode-hook 'command-log-mode)
    (add-hook 'lisp-mode-hook 'command-log-mode)
    (add-hook 'scheme-mode-hook 'command-log-mode)

    (add-hook 'agda2-mode-hook 'command-log-mode)
    (add-hook 'cicada-nymph-mode-hook 'command-log-mode)
    #+end_src

*** w3m

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/emacs-w3m/")
    (require 'w3m-load)

    (setq w3m-home-page "file:///home/xyh/.w3m/bookmark.html")

    ;; (setq browse-url-browser-function 'w3m-browse-url)
    ;; (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)

    ;; optional keyboard short-cut

    (add-hook
     'w3m-mode-hook
     (lambda ()
       ;; link
       (local-set-key (kbd "j") 'w3m-view-previous-page)
       (local-set-key (kbd "l") 'w3m-view-next-page)
       (local-set-key (kbd "i") 'w3m-previous-anchor)
       (local-set-key (kbd "k") 'w3m-next-anchor)
       (local-set-key (kbd "RET") 'w3m-view-this-url)
       (local-set-key (kbd "M-RET") 'w3m-view-this-url-new-session)
       ;; in page
       (local-set-key (kbd "M-n") 'forward-paragraph)
       (local-set-key (kbd "M-p") 'backward-paragraph)
       ;; bookmark
       (local-set-key (kbd "b") 'w3m-bookmark-view-new-session)
       (local-set-key (kbd "C-M-b") 'w3m-bookmark-edit)
       ;; tab
       (local-set-key (kbd "<C-tab>") 'w3m-next-buffer)
       (local-set-key (kbd "<C-iso-lefttab>") 'w3m-previous-buffer)
       ;; 獲取當前光標下的 url
       ;; 光標下沒有就獲取當前的 url
       ;; 點擊回車編輯 html
       (local-set-key (kbd "e") 'w3m-edit-url)

       ;; give back keys
       (local-set-key (kbd "C-t") 'isearch-forward)
       (local-set-key (kbd "<left>") 'backward-char)
       (local-set-key (kbd "<right>") 'forward-char)
       (local-set-key (kbd "<down>") 'forward-paragraph)
       (local-set-key (kbd "<up>") 'backward-paragraph)
       (local-set-key (kbd "M-s") 'forward-sexp)))
    #+end_src

*** hippie-expand
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-h") 'hippie-expand)
    (setq hippie-expand-try-functions-list
          '(try-expand-dabbrev
            try-expand-dabbrev-visible
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill
            try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-list
            try-expand-line
            pcomplete
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol
            ))
    #+end_src

*** primary-clipboard-yank
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; ;; (eshell-command &optional COMMAND ARG)
    ;; ;; Execute the Eshell command string COMMAND
    ;; ;; With prefix ARG, insert output into the current buffer at point

    ;; (shell-command "xterm &")
    ;; (eshell-command "xterm &")

    ;; ;; 下面这句会开一个 out-put-buffer 然后显示输出的东西
    ;; (eshell-command "parcellite -p")
    ;; ;; == (eshell-command "parcellite -p" nil)


    ;; ;; 下面这个不开 out-put-buffer 会把光标停在粘贴的东西前面
    ;; (eshell-command "parcellite -p" nil)


    ;; ;; (eshell-command-result "parcellite -p")
    ;; ;; 下面这个会把光标停在粘贴的东西后面
    ;; (insert (eshell-command-result "parcellite -p"))

    ;; ;; 下面这个函数虽然跑的快
    ;; ;; 但是从 emacs 的 kill-ring 中粘贴东西的时候却会死掉
    ;; ;; (insert (shell-command-to-string "parcellite -p"))

    (defun primary-clipboard-yank ()
      (interactive)
      ;; (insert (eshell-command-result "clipit -p"))
      (insert (eshell-command-result "xclip -o"))
      )
    (global-set-key (kbd "C-M-y") 'primary-clipboard-yank)
    #+end_src

*** gc optimization
    * gc-cons-threshold
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq gc-cons-threshold 20000000)
      #+end_src
    * Emacs's garbage collector is fairly primitive stop the world type.
      GC time can contribute significantly to the run-time of computation that allocates and frees a lot of memory.
    * Consider the following example:
      #+begin_src emacs-lisp
      (defun uuid ()
        (format "%08x-%08x-%08x-%08x"
                (random (expt 16 4))
                (random (expt 16 4))
                (random (expt 16 4))
                (random (expt 16 4))))

      (benchmark-run 1
        (let ((cache (flx-make-filename-cache)))
              (dolist (i (number-sequence 0 10000))
                (flx-process-cache (uuid) cache))))
              ;;; ⇒ (0.899678 9 0.33650300000000044)
      #+end_src
    * This means that roughly 30% of time is spent just doing garbage-collection.
    * flx can benefit significantly from garbage collection tuning.
    * By default Emacs will initiate GC every 0.76 MB allocated (gc-cons-threshold == 800000).
      If we increase this to 20 MB (gc-cons-threshold == 20000000) we get:
      #+begin_src emacs-lisp
      (benchmark-run 1
        (setq gc-cons-threshold 20000000)
        (let ((cache (flx-make-filename-cache)))
              (dolist (i (number-sequence 0 10000))
                (flx-process-cache (uuid) cache))))
              ;;; ⇒ (0.62035 1 0.05461100000000041)
      #+end_src

*** auto-overlay                      :no:
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/auto-overlays/")
    (require 'auto-overlays)
    (require 'auto-overlay-common)
    (require 'auto-overlay-flat)
    (require 'auto-overlay-line)
    (require 'auto-overlay-nested)
    (require 'auto-overlay-self)
    (require 'auto-overlay-word)
    (require 'auto-overlays-compat)
    #+end_src

***** test
      #+begin_src emacs-lisp
      (auto-overlay-load-definition
                'latex
                '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)"
                        (face . (background-color . "blue")))))
      #+end_src

*** ido

***** [note]

      - ido is part of emacs

***** main

      - use C-f during file selection to switch to regular find-file

      #+begin_src emacs-lisp :tangle ~/.emacs
      (ido-mode t)
      (ido-everywhere t)
      (setq ido-enable-flex-matching t)
      (setq ido-use-filename-at-point nil)
      (setq ido-auto-merge-work-directories-length 0)
      (setq ido-use-virtual-buffers t)
      (setq ido-default-buffer-method 'switch-buffer)
      #+end_src

***** ido-switch-buffer

      - default key-binding
        | RET     |                         | Select the buffer at the front of the list of matches.            |
        |         |                         | If the list is empty, possibly prompt to create new buffer.       |
        | C-j     | ido-select-text         | Use the current input string verbatim.                            |
        | C-s     | ido-next-match          | Put the first element at the end of the list.                     |
        | C-r     | ido-prev-match          | Put the last element at the start of the list.                    |
        | TAB     | ido-complete            | Complete a common suffix to the current string that matches       |
        |         |                         | all buffers.  If there is only one match, select that buffer.     |
        |         |                         | If there is no common suffix, show a list of all matching buffers |
        |         |                         | in a separate window.                                             |
        | C-e     | ido-edit-input          | Edit input string.                                                |
        | C-x C-b | ido-fallback-command    | Fallback to non-ido version of current command.                   |
        | C-t     | ido-toggle-regexp       | Toggle regexp searching.                                          |
        | C-p     | ido-toggle-prefix       | Toggle between substring and prefix matching.                     |
        | C-c     | ido-toggle-case         | Toggle case-sensitive searching of buffer names.                  |
        | ?       | ido-completion-help     | Show list of matching buffers in separate window.                 |
        | C-x C-f | ido-enter-find-file     | Drop into `ido-find-file'.                                        |
        | C-k     | ido-kill-buffer-at-head | Kill buffer at head of buffer list.                               |
        | C-a     | ido-toggle-ignore       | Toggle ignoring buffers listed in `ido-ignore-buffers'.           |

      #+begin_src emacs-lisp :tangle ~/.emacs
      (global-set-key (kbd "C-x b") 'list-buffers)
      (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
      (add-hook 'ido-minibuffer-setup-hook
                (lambda ()
                  (local-set-key (kbd "C-s") 'ido-toggle-prefix)
                  (local-set-key (kbd "C-r") 'ido-toggle-regexp)
                  (local-set-key (kbd "C-n") 'ido-next-match)
                  (local-set-key (kbd "C-p") 'ido-prev-match)))
      #+end_src

***** ido-ubiquitions                 :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/ido-ubiquitous/")
      (require 'ido-ubiquitous)
      (ido-ubiquitous-mode t)
      #+end_src

***** ido-at-point
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/ido-at-point/")
      (require 'ido-at-point)
      (ido-at-point-mode)
      #+end_src

***** ido-vertical-mode

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/ido-vertical-mode/")
      (require 'ido-vertical-mode)
      (ido-mode 1)
      (ido-vertical-mode 1)
      #+end_src

*** cua-selection-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (cua-selection-mode 1)
    #+end_src

*** muse
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/muse/lisp/")

    (require 'muse-mode); load authoring mode
    (require 'muse-html); load publishing styles I use
    (require 'muse-latex)
    (require 'muse-texinfo)
    (require 'muse-docbook)
    (require 'muse-project); publish files in projects


    (setq muse-html-content-coding "utf-8")
    (setq muse-html-charset-default "utf-8")
    (setq muse-html-coding-default "utf-8")

    ;; (custom-set-variables
    ;;  '(muse-file-extension nil)
    ;;  '(muse-mode-auto-p t)
    ;;  '(muse-file-extension "muse")
    ;;  '(muse-html-meta-content-encoding (quote utf-8))
    ;;  '(muse-html-charset-default "utf-8")
    ;;  '(muse-html-encoding-default (quote utf-8))
    ;;  '(muse-html-encoding-map "utf8")
    ;;  '(muse-colors-autogen-headings (quote outline))
    ;;  '(muse-html-meta-content-encoding (quote utf-8))
    ;;  '(muse-html-meta-content-type "text/xhtml; charset=utf-8"))

    (add-hook 'muse-mode-hook
     (lambda ()
       (local-set-key (kbd "M-<tab>") 'window->)
       (local-set-key (kbd "C-c C-c") 'muse-project-publish)
       ))
    #+end_src

*** muse-project-alist
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq muse-project-alist
              '(

            ("cicada"
             ("~/cicada/readings"
              :default "cicada")
             (:base "xelatex"
              :path "~/cicada/readings/xelatex"))

            ("cicada--cn"
             ("~/cicada/readings-chinese"
              :default "cicada-chinese")
             (:base "xelatex"
              :path "~/cicada/readings-chinese/xelatex"))

            ))
    #+end_src

*** htmlize                           :no:
    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/htmlize/")

    (require 'htmlize)
    (setq htmlize-output-type 'css)
    ;; (setq htmlize-output-type 'inline-css)
    ;; (setq htmlize-output-type 'font)
    #+end_src

*** uniquify
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'uniquify)
    ;(setq uniquify-buffer-name-style 'reverse)
    (setq uniquify-buffer-name-style 'forward)
    #+end_src

*** send mail
    * Gmail SMTP server address: smtp.gmail.com
      Gmail SMTP user name: Your full Gmail address (e.g. example@gmail.com)
      Gmail SMTP password: Your Gmail password
      Gmail SMTP port: 465
      Gmail SMTP TLS/SSL required: yes
    * Gmail IMAP server address: imap.gmail.com
      Gmail IMAP user name: Your full Gmail address (e.g. "me@gmail.com")
      Gmail IMAP password: Your Gmail password
      Gmail IMAP port: 993
      Gmail IMAP TLS/SSL required: yes
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (setq send-mail-function 'mailclient-send-it)
    (setq send-mail-function 'smtpmail-send-it)
    (setq smtpmail-smtp-server "smtp.gmail.com")
    (setq smtpmail-smtp-service 25)
    #+end_src

*** message
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq user-full-name "XIE Yuheng"
          user-mail-address "xyheme@gmail.com"
          message-auto-save-directory "~/mail/draft")
    #+end_src

*** region-state
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/region-state/")
    (require 'region-state)
    (region-state-mode)
    (setq region-state-display-place 'echo-area)
    ;; (setq region-state-display-place 'header-line)
    ;; (setq region-state-display-place 'mode-line)
    #+end_src

* M-x

*** default

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (global-set-key (kbd "M-x") 'execute-extended-command)
    #+end_src

*** smex
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/smex/")
    ;; (require 'smex)

    ;; (global-set-key (kbd "M-x") 'smex)
    ;; (global-set-key (kbd "M-z") 'smex-major-mode-commands)
    #+end_src

*** helm

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/emacs-async/")
    (require 'async)

    (add-to-list 'load-path "~/.emacs.d/helm/")
    (require 'helm-config)
    (helm-mode 1)

    (global-set-key (kbd "M-x") 'helm-M-x)
    (global-set-key (kbd "C-x C-y") 'helm-show-kill-ring)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)
    (global-set-key (kbd "C-x C-b") 'helm-mini)

    (setq helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match    t)

    (add-hook
     'helm-after-initialize-hook
     (lambda ()
       (define-key helm-map (kbd "C-h") 'helm-execute-persistent-action)))
    #+end_src

* search

*** default

    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-t") 'isearch-forward)

    (add-hook
     'isearch-mode-hook
     (lambda ()
       (define-key isearch-mode-map (kbd "C-t") 'isearch-repeat-forward)
       ;; (define-key isearch-mode-map (kbd "C-o") 'occur)
       (define-key isearch-mode-map (kbd "C-o") 'helm-occur)
       ))
    #+end_src

* irc

*** rcirc
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq rcirc-default-nick "xyh")
    (setq rcirc-default-port "6666")
    (setq rcirc-default-user-name "xieyuheng")
    (setq rcirc-default-full-name "XIE Yuheng")

    (eval-after-load 'rcirc '(rcirc-track-minor-mode 1))

    (setq rcirc-notify+-open nil)

    (setq rcirc-server-alist
          '(("irc.freenode.net" :port 6666
             :channels ("#schemecn"
                        "#cicada-language"
                        "#szdiy"))))
    #+end_src

*** rcirc-groups
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-groups/")
    (require 'rcirc-groups)
    (require 'rcirc-notify-mode)
    #+end_src

*** rcirc-notify+
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-notify-plus/")
    (require 'rcirc-notify+)
    (setq rcirc-notify+-open t)
    #+end_src

*** rcirc-autoreconnect
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-autoreconnect/")
    (require 'rcirc-autoreconnect)
    (setq rcirc-autoreconnect t)
    #+end_src

*** circe                             :no:
    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/circe/")
    (require 'circe)

    (setq circe-network-options
          `(("Freenode"
             :nick "xyh"
             :port 6667
             :channels ("#schemecn"
                        "#cicada-language"
                        "#szdiy"))))
    #+end_src

*** erc

    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun irc ()
      (interactive)
      (erc :server "irc.freenode.net"
           :port 6666
           :full-name "XIE Yuheng"
           :nick "xieyuheng"))

    (setq erc-autojoin-channels-alist
          '(("freenode.net"
             "#szdiy"
             "#archlinux-cn"
             "#archlinux-cn-offtopic"
             "#linux-cn"
             "#cicada-language")))
    #+end_src

* file viewer

*** ranger                            :no:

    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/ranger-git/")
    (require 'ranger)

    ;; zp for minimal ranger mode (deer)

    (setq ranger-cleanup-on-disable t)
    (setq ranger-cleanup-eagerly t)

    ;; toggled by zh
    (setq ranger-show-dotfiles nil)

    ;; function used to output header of primary ranger window
    ;;   must return a string that is placed in the header-line
    (setq ranger-header-func 'ranger-header-line)

    (setq ranger-parent-depth 1) ;; adjusted by z- and z+

    ;; toggled by zi
    ;;   literal v.s. find-file
    (setq ranger-show-literal nil)

    (setq ranger-ignored-extensions
          '("mkv" "iso" "mp4" "pdf" "djvu"))

    ;; 1 MB
    (setq ranger-max-preview-size 1)
    #+end_src

*** warden

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/warden/")
    (require 'warden)

    (global-set-key (kbd "C-s C-w") 'warden)
    #+end_src

* tabbar

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (add-to-list 'load-path "~/.emacs.d/tabbar/")
  ;; (require 'tabbar)
  ;; (tabbar-mode)

  ;; (global-set-key (kbd "C-`") 'tabbar-forward)
  ;; (global-set-key (kbd "C-~") 'tabbar-backward)
  #+end_src

* window manager

*** eyebrowse

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/eyebrowse/")
    (require 'eyebrowse)
    (eyebrowse-mode 1)

    ;; ((kbd "<") 'eyebrowse-prev-window-config)
    ;; ((kbd ">") 'eyebrowse-next-window-config)
    ;; ((kbd "'") 'eyebrowse-last-window-config)
    ;; ((kbd "\"") 'eyebrowse-close-window-config)
    ;; ((kbd ",") 'eyebrowse-rename-window-config)
    ;; ((kbd ".") 'eyebrowse-switch-to-window-config)
    ;; ((kbd "0") 'eyebrowse-switch-to-window-config-0)
    ;; ((kbd "1") 'eyebrowse-switch-to-window-config-1)
    ;; ((kbd "2") 'eyebrowse-switch-to-window-config-2)
    ;; ((kbd "3") 'eyebrowse-switch-to-window-config-3)
    ;; ((kbd "4") 'eyebrowse-switch-to-window-config-4)
    ;; ((kbd "5") 'eyebrowse-switch-to-window-config-5)
    ;; ((kbd "6") 'eyebrowse-switch-to-window-config-6)
    ;; ((kbd "7") 'eyebrowse-switch-to-window-config-7)
    ;; ((kbd "8") 'eyebrowse-switch-to-window-config-8)
    ;; ((kbd "9") 'eyebrowse-switch-to-window-config-9)
    #+end_src

* sdcv

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/popup-el/")
  (require 'popup)

  (add-to-list 'load-path "~/.emacs.d/sdcv.el/")
  (require 'sdcv)

  (global-set-key (kbd "M-t") 'sdcv-search-pointer)
  #+end_src

* looks like

*** window

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq default-frame-alist '((fullscreen . maximized)))
    (setq initial-frame-alist '((fullscreen . maximized)))
    ;; (custom-set-variables '(default-frame-alist (quote ((fullscreen . maximized)))))
    ;; (custom-set-variables '(initial-frame-alist (quote ((fullscreen . maximized)))))
    #+end_src

*** hl

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/hl-line/")
    (require 'hl-line)
    (global-hl-line-mode 1)
    #+end_src

*** font

***** <f7>                            :no:

      #+begin_src emacs-lisp :tangle no
      (defvar *toggle-font-for-the-show* nil)
      (defun toggle-font-for-the-show ()
        (interactive)
        (if (eq *toggle-font-for-the-show* t)
            (progn
              ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 20))
              ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
              ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 20))
              (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
              ;; (set-face-attribute 'default nil :family "monofur" :height 140)
              (set-face-attribute 'default nil :family "Envy Code R" :height 140)
              (setq *toggle-font-for-the-show* nil))
            (progn
              ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 32))
              ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 32))
              ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 34))
              (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 34))
              ;; (set-face-attribute 'default nil :family "monofur" :height 240)
              (set-face-attribute 'default nil :family "Envy Code R" :height 240)
              (setq *toggle-font-for-the-show* t))))
      (global-set-key (kbd "<f7>") 'toggle-font-for-the-show)
      #+end_src

***** [note]
      用下面所使用的连个函数配置 emacs 的字体的时候
      其他一些程序(比如 firefox)的字体配置也会跟着改变

      "AR PL SungtiL GB" 文鼎 PL 简报宋
      "AR PL KaitiM GB" 文鼎 PL 简中楷

      "AR PL UKai" 文鼎 PL 中楷
      "AR PL UMing" 文鼎 PL 细上海宋

      "WenQuanYi Micro Hei" 文泉驿微米黑
      "WenQuanYi Zen Hei" 文泉驿正黑
      "WenQuanYi Bitmap Song" 文泉驿点阵宋体

      (set-fontset-font NAME TARGET FONT-SPEC &optional FRAME ADD)
      + NAME is a fontset name string
        nil for the fontset of FRAME
        or t for the default fontset
      + TARGET
        1. may be a cons: (FROM . TO)
           where FROM and TO are characters
           In that case
           use FONT-SPEC for all characters
           in the range FROM and TO (inclusive)
        2. may be a script name symbol
           In that case
           use FONT-SPEC for all characters
           that belong to the script
        3. may be a charset
           In that case
           use FONT-SPEC for all characters in the charset
        4. may be nil
           In that case
           use FONT-SPEC for any characters
           for that no FONT-SPEC is specified
      use the following function in *ielm* buffer
      to print script name symbol in emacs
      #+begin_src emacs-lisp
      (char-table-extra-slot char-script-table 0)
      #+end_src

***** 楷
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "H\-宮書" :size 20))
      #+end_src

***** 宋
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "HanaMinA" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "HAN NOM A" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "H-秀月" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "H-SiuNiu" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "simsun" :size 24))
      ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 24))
      #+end_src

***** 黑
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "H-雲林呉竹体" :size 24))

      ;; (set-fontset-font t 'han (font-spec :name "H-明蘭" :size 24))
      (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Regular" :size 24))

      ;; (set-fontset-font t 'han (font-spec :name "H-minglan" :size 20))

      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans Mono CJK TC" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Light" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC DemiLight" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Medium" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "SourceHanSans" :size 32))
      ;; (set-fontset-font t 'han (font-spec :name "WenQuanYi Micro Hei Mono" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-儷黑" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-新雅蘭" :size 20))
      #+end_src

***** test 等宽测试

      中英等宽测试|
      sdasddassaas|
      iiiiiiiiiiii|
      λλλλλλλλλλλλ|

***** 英

      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-face-attribute 'default nil :family "monaco" :height 140)
      ;; (set-face-attribute 'default nil :family "Envy Code R" :height 140)
      ;; (set-face-attribute 'default nil :family "Source Code Pro" :height 130)
      ;; (set-face-attribute 'default nil :family "Sauce Code Powerline" :height 130)

      ;; (set-face-attribute 'default nil :family "Source Code Pro for Powerline" :height 140)

      (set-face-attribute 'default nil :family "Input" :height 140)
      ;; (set-face-attribute 'default nil :family "monofur" :height 170)

      ;; (set-face-attribute 'default nil :family "Droid Sans Mono" :height 130)
      ;; (set-face-attribute 'default nil :family "FiraMono" :height 130)
      ;; (set-face-attribute 'default nil :family "mono" :height 140)

      ;; (set-face-attribute 'default nil :family "lmmono10" :height 140)
      ;; (set-face-attribute 'default nil :family "lmmonocaps10" :height 140)
      ;; (set-face-attribute 'default nil :family "lmmonolt10" :height 140)
      ;; (set-face-attribute 'default nil :family "Inconsolata" :height 140)
      ;; (set-face-attribute 'default nil :family "Cousine" :height 140)
      ;; (set-face-attribute 'default nil :family "PT Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Anonymous Pro" :height 140)
      ;; (set-face-attribute 'default nil :family "Nova Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Fira Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Cutive Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Oxygen Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Share Tech Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Anonymous Pro" :height 140)
      #+end_src

***** 符
      #+begin_src emacs-lisp :tangle ~/.emacs
      (set-fontset-font t 'symbol (font-spec :name "mono"))
      ;; (set-fontset-font t 'symbol (font-spec :name "STIXGeneral"))
      #+end_src

***** 希臘
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'greek (font-spec :name "Porson"))
      ;; (set-fontset-font t 'greek (font-spec :name "mono"))
      ;; (set-fontset-font t 'greek (font-spec :name "STIXGeneral"))
      ;; (set-fontset-font t 'greek (font-spec :name "Code2000"))
      ;; (set-fontset-font t 'greek (font-spec :name "ALPHA\-Demo"))
      (set-fontset-font t 'greek (font-spec :name "FreeMono"))
      #+end_src

***** test 希臘

      α  Α     β  Β     γ  Γ     δ  Δ     ε  Ε
      ζ  Ζ     η  Η     θ  Θ     ι  Ι     κ  Κ
      λ  Λ     μ  Μ     ν  Ν     ξ  Ξ     ο  Ο
      π  Π     ρ  Ρ     ς  ΢     σ  Σ     τ  Τ
      υ  Υ     φ  Φ     χ  Χ     ψ  Ψ     ω  Ω

*** theme

***** molokai
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'custom-theme-load-path "~/.emacs.d/molokai-theme/")
      (load-theme 'molokai t)
      (add-to-list 'load-path "~/.emacs.d/molokai-theme/")
      (require 'molokai-theme-kit)
      #+end_src

***** zenburn
      #+begin_src emacs-lisp
      (add-to-list 'custom-theme-load-path "~/.emacs.d/zenburn-emacs/")
      (load-theme 'zenburn t)
      #+end_src

*** translucent                       :no:
    #+begin_src emacs-lisp :tangle no
    ;; 当前窗口和非当前窗口时透明度
    ;; 都用 90
    (setq alpha-list '((90 90) (100 100)))
    (defun translucent ()
      (interactive)
      (let* ((h (car alpha-list))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))
            (setq alpha-list (cdr (append alpha-list (list h))))))
    (global-set-key (kbd "<f9>") 'translucent)

    (setq alpha-list-on '((100 100) (90 90)))
    (defun translucent-on ()
      (interactive)
      (let* ((h (car alpha-list-on))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

    (setq alpha-list-off '((90 90) (100 100)))
    (defun translucent-off ()
      (interactive)
      (let* ((h (car alpha-list-off))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

    ;; (translucent-on)
    (translucent-off)
    #+end_src

*** no-bother
    #+begin_src emacs-lisp :tangle ~/.emacs
    (mouse-avoidance-mode 'animate)
    (setq inhibit-startup-message t)
    (setq initial-scratch-message "")

    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)

    (fset 'yes-or-no-p 'y-or-n-p)
    #+end_src

*** cursor
    #+begin_src emacs-lisp :tangle ~/.emacs
    (blink-cursor-mode -1)

    ;; (set-frame-parameter nil 'cursor-type 'hollow)
    (set-frame-parameter nil 'cursor-type 'box)
    ;; (set-frame-parameter nil 'cursor-type 'bar)
    ;; (set-frame-parameter nil 'cursor-type '(bar . 2))
    ;; (set-frame-parameter nil 'cursor-type 'hbar)
    ;; (set-frame-parameter nil 'cursor-type '(hbar . 8))
    #+end_src

*** paren-face

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/three-color-bracket/")
    (require 'paren-face)

    (global-paren-face-mode)
    #+end_src

*** [not using] display
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (display-battery-mode t)
    ;; (display-time-mode t)
    #+end_src

*** symon                             :no:
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/symon/")
    (require 'symon)
    (symon-mode)
    #+end_src

*** fullscreen
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq frame-resize-pixelwise t)
    #+end_src

* emacs server & eshell

*** [note]
    * 需要與 bash 或 zsh 配合使用
      給 emacsclient 以 "e" 爲其別名
      並注意設置 emacsclient 的命令行參數
    * 但是如果先有一个 emacs-sever
      再打开 emacs 時 就会有警告
      我保留对这个警告的显示
      因为它提示了当前 emacs-sever 的开启状态
      (server-force-delete)
    * 因此常使用的方式是
      将(server-start)写在.emacs 中
      将 alias e='emacsclient -c -a "" -e \(eshell\)'写在.bashrc 中
      第一个 emacs 在终端中用 emacs 打开
      之后在终端中使用 e 就会以这个 emacs 为 sever
      退出这第一个 emacs 之后就会关闭被它打开的 emacs-sever

*** emacs server
    #+begin_src emacs-lisp :tangle ~/.emacs
    (server-start)
    ;; (setq server-name "><")
    ;; (server-force-delete)
    #+end_src

*** load-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/eshell/")
    (require 'eshell)
    #+end_src

*** hook
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook
     'eshell-mode-hook
     (lambda ()
       (local-set-key (kbd "C-c h")
                      (lambda ()
                            (interactive)
                            (insert
                             (ido-completing-read "eshell history: "
                                              (delete-dups
                                               (ring-elements eshell-history-ring))))))
       (local-set-key (kbd "C-c C-h") 'eshell-list-history)))
    #+end_src

*** [note] how to use

***** startup scripts
      *for i use org-mode, this is not very useful*
      like most shells,
      eshell supports both login and profile/rc shell scripts
      The full filepaths for both are stored in the variables
      eshell-login-script and eshell-rc-script
      but by default the files login and profile are stored in ~/.eshell/

      It bears mention that the comment syntax is #

***** jump
      it maintains a ring the last 32 directories seen.

      To view the ring: ‘cd =’
      Changing to an index within the ring: ‘cd -4’
      Note that ‘cd -’ is the same as ‘cd -0’
      Use a regular expression: ‘cd =regexp’

      The ring is saved in ‘~/.eshell/lastdir’.
      You can increase the ring size by setting ‘eshell-last-dir-ring-size’.
      Perhaps this is good enough for you, making autojump unnecessary.
      The only benefit autojump offers is that it sorts the entries
      by how often you switched there instead of when you switched there.

*** alias
    * the auto-correcting aliasing
      if you type an invalid command too many times
      (governed by eshell-bad-command-tolerance, which is 3 by default)
      Eshell will offer to alias it to its intended command for you
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; eshell will write the alias definitions to eshell-aliases-file
    (setq eshell-aliases-file "~/.emacs.d/eshell/alias")
    ;; which in turn is governed by the eshell-directory-name
    (setq eshell-directory-name "~/.emacs.d/eshell/")
    #+end_src

*** commands history
    * to use ido-completing-read to access to eshells history
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'eshell-mode-hook
                     (lambda ()
                       (local-set-key (kbd "M-<tab>") 'window->)))
    #+end_src

* make multi eshell work much easier

*** eshell/delete-char-or-kill-buffer
    1. (goto-char (point-max)) == (end-of-buffer)
    2. 在 emacs 中 efb 的识别方式有很多 比如:
       1. (eq (following-char) 0)
          (char-equal (following-char) 0)
       2. (eq (point-max) (point))
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun eshell/delete-char-or-kill-buffer ()
      (interactive)

      (point-to-register ?e)
      (eshell-bol)

      (if (eq (point-max) (point))
              (progn
            (kill-buffer)
            (delete-frame))
            (progn
              (jump-to-register ?e)
              (delete-char 1))))

    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-d") 'eshell/delete-char-or-kill-buffer)))
    #+end_src

*** eshell-prompt-function
    #+begin_src emacs-lisp :tangle ~/.emacs
    (set 'eshell-prompt-function
         (lambda ()
           (concat "\n"
                   (if (eq eshell-last-command-status 0)
                       ""
                       (number-to-string eshell-last-command-status))
                   "  "
                   (if (= (user-uid) 0)
                       "[root]  "
                       "")
                   (eshell/pwd)
                   "\n"
                   )))
    #+end_src

*** self-defun [before eshell]

***** my-cd-back
      #+begin_src emacs-lisp :tangle ~/.emacs
      (defun my-cd-back ()
        (interactive)
        (insert "cd ..")
        (eshell-send-input))
      (add-hook 'eshell-mode-hook
                (lambda ()
                      (local-set-key (kbd "<C-M-backspace>") 'my-cd-back)))
      #+end_src

***** rebinding normal move-beginning-of-line
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-hook 'eshell-mode-hook
                (lambda ()
                      (local-set-key (kbd "C-S-a") 'move-beginning-of-line)))
      #+end_src

*** [open|new]-eshell-for-frame

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; in ~/.xbindkeysrc.scm
    ;; I have the following
    ;; (xbindkey '(shift mod4 x) "LC_CTYPE=zh_CN.UTF-8 emacsclient -c -e \"(open-eshell-for-frame :on)\"")
    ;; (xbindkey '(mod4 t) "LC_CTYPE=zh_CN.UTF-8 emacsclient -t -e \"(open-eshell-for-frame :on)\"")

    (defun frame-eshell-name ()
      (concatenate 'string "eshell:" (frame-parameter nil 'name)))

    (defun open-eshell-for-frame (&optional translucent)
      (set-frame-parameter nil 'name (number-to-string (number-generator)))
      (let ((.buffer-name (frame-eshell-name)))
        (eshell t)
        (delete-region 1 (buffer-size))
        (insert "* (eshell)\n"
                "  eshell number " (frame-parameter nil 'name) "\n"
                "  the main eshell for this frame\n")
        (eshell-interrupt-process)
        (rename-buffer .buffer-name)))

    ;; can be used in 'emacs -nw'
    (defun new-eshell-for-frame (&optional translucent)
      (interactive)
      (let* ((.sub-number-string (number-to-string (number-generator)))
             (.buffer-name (concatenate 'string (frame-eshell-name) ":" .sub-number-string)))
        (eshell t)
        (delete-region 1 (buffer-size))
        (insert "* (eshell)\n"
                "  eshell number " (frame-parameter nil 'name) "\n"
                "  eshell sub-number " .sub-number-string "\n"
                "  a sub eshell of this frame\n")
        (eshell-interrupt-process)
        (rename-buffer .buffer-name)))

    (global-set-key (kbd "C-s e") 'new-eshell-for-frame)
    #+end_src

*** my-switch-to-eshell
    * 下面是黄金搭档 previous-buffer
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-switch-to-eshell ()
      (interactive)
      (cond
        ((not (member-string? (frame-eshell-name) (mapcar 'buffer-name (buffer-list))))
         (open-eshell-for-frame))
        (:else
         (switch-to-buffer (frame-eshell-name))))
      (local-set-key (kbd "C-s C-e") 'previous-buffer))
    (global-set-key (kbd "C-s C-e") 'my-switch-to-eshell)
    #+end_src

*** init call to (open-eshell-for-frame)

    #+begin_src emacs-lisp :tangle ~/.emacs
    (open-eshell-for-frame :off)
    #+end_src

* magit

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/with-editor/")
  (require 'with-editor)

  (add-to-list 'load-path "~/.emacs.d/magit/lisp/")
  (require 'magit)

  (global-set-key (kbd "C-x g") 'magit-status)
  #+end_src
