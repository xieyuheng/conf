#+TITLE:  init emacs ^-^
#+AUTHOR: 謝宇恆 / XIE Yuheng

* note

  - keep it simple
  - try to do not change default key-binding
  - add a thing only when you really need it

* lib

*** my functions
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defmacro rgx-opt (&rest lis)
      `(regexp-opt (quote ,lis)))
    ;; test:
    ;; (rgx-opt "aaa" "bbb" "ccc")

    (defun rgx-nested-groups-help (lis)
      (if lis
          (concat (car lis)
                  "\\("
                  (rx-groups-help (cdr lis))
                  "\\)")
        '()))
    (defmacro rgx-nested-groups (&rest lis)
      `(rgx-nested-groups-help (quote ,lis)))
    ;; test:
    ;; (rgx-nested-groups "aaa" "bbb" "ccc")
    ;; (rx (groups "aaa"
    ;;            (groups "bbb"
    ;;                   (groups "ccc"))))

    (defun rgx-groups (&rest lis)
      (apply (function concat)
             (apply (function append)
                    (mapcar (lambda (x) (list "\\(" x "\\)"))
                            lis))))
    ;; test:
    ;; (rgx-groups "1" "2" "3")
    ;; (rx (group "1") (group "2") (group "3"))





    ;; a syntax-table is a char-table
    (defmacro make-syntaxes (name &rest lis)
      (list 'progn ;; need to control eva order
            `(setq ,name
                   (make-char-table 'syntax-table (string-to-syntax "w")))
            (cons 'progn
                  (mapcar (lambda (char-and-newentry)
                            (append (list 'modify-syntax-entry)
                                    char-and-newentry
                                    (list name)))
                          lis))))





    (make-syntaxes word-syntax-table
                   ;; default is word constituent
                   ;; whitespace characters:
                   (   '(0 . 32)    "-"  )
                   (      127       "-"  ))

    (make-syntaxes word-syntax-table-with-symbol&with-open/close-delimiter
                   ;; note that, if modify one syntax entry twice
                   ;; the second will shadow the first
                   ;; whitespace characters:
                   (   '(0 . 32)    "-"  )
                   (      127       "-"  )
                   ;; symbol constituent:
                   ;; the following functions need this:
                   ;; ``forward-word'' and so on ...
                   (  '(33 . 47)    "_"  )
                   (  '(58 . 64)    "_"  )
                   (  '(91 . 96)    "_"  )
                   ( '(123 . 126)   "_"  )
                   ;; open/close delimiter:
                   ;; the following functions need this:
                   ;; ``forward-sexp'' ``backward-sexp''
                   ;; ``mark-sexp'' and so on ...
                   (  ?\(    "("  )
                   (  ?\)    ")"  )
                   (  ?\[    "("  )
                   (  ?\]    ")"  )
                   (  ?\{    "("  )
                   (  ?\}    ")"  ))

    (make-syntaxes word-syntax-table-with-symbol
                   ;; note that, if modify one syntax entry twice
                   ;; the second will shadow the first
                   ;; whitespace characters:
                   (   '(0 . 32)    "-"  )
                   (      127       "-"  )
                   ;; symbol constituent:
                   ;; the following functions need this:
                   ;; ``forward-word'' and so on ...
                   (  '(33 . 47)    "_"  )
                   (  '(58 . 64)    "_"  )
                   (  '(91 . 96)    "_"  )
                   ( '(123 . 126)   "_"  ))

    (make-syntaxes word-syntax-table-with-open/close-delimiter
                   ;; note that, if modify one syntax entry twice
                   ;; the second will shadow the first
                   ;; whitespace characters:
                   (   '(0 . 32)    "-"  )
                   (      127       "-"  )
                   ;; open/close delimiter:
                   ;; the following functions need this:
                   ;; ``forward-sexp'' ``backward-sexp''
                   ;; ``mark-sexp'' and so on ...
                   (  ?\(    "("  )
                   (  ?\)    ")"  )
                   (  ?\[    "("  )
                   (  ?\]    ")"  )
                   (  ?\{    "("  )
                   (  ?\}    ")"  ))





    (defun make-faces-help (alist)
      (mapcar (lambda (face-definiton)
                (eval (append '(defface)
                              (list (car face-definiton)
                                    (cons 'quote (cdr face-definiton)))
                              '("") )))
              alist))

    (defmacro make-faces (&rest alist)
      `(make-faces-help (quote ,alist)))





    (defun say-for-turn-off-indent ()
      (interactive)
      (back-to-indentation)
      (message "<tab> indentation has been turn off."))

    (setq function-before-turn-on-indent
          (lambda () (interactive)
            (message "<tab> indentation has not been turned off yet.")))
    (defun turn-off-indent ()
      (interactive)
      (setq function-before-turn-on-indent
            (lookup-key (current-local-map) (kbd "<tab>")))
      (local-set-key (kbd "<tab>") 'say-for-turn-off-indent)
      (message "turning off <tab> indentation."))

    (defun turn-on-indent ()
      (interactive)
      (local-set-key (kbd "<tab>") function-before-turn-on-indent)
      (message "turning on <tab> indentation."))


    (defun move-line-foreword ()
      (interactive)
      (if (char-equal 10 (char-before))
          (insert " ")
        (progn
          (point-to-register 666)
          (move-beginning-of-line 1)
          (insert " ")
          (jump-to-register 666))))

    (defun move-line-backword ()
      (interactive)
      (point-to-register 666)
      (move-beginning-of-line 1)
      (if (char-equal 32 (char-after))
          (delete-char 1))
      (jump-to-register 666))






    (defun change-parentheses ()
      (interactive)
      (cond ((looking-at "\(")
             (message "( ) --> [ ]")
             (let ()
               (delete-char 1)
               (insert "[")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert "]")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            ((looking-at "\\[")
             (message "[ ] --> { }")
             (let ()
               (delete-char 1)
               (insert "{")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert "}")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            ((looking-at "\{")
             (message "{ } --> ( )")
             (let ()
               (delete-char 1)
               (insert "(")
               (backward-char 1)
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp 1)))
             (let ()
               (delete-char -1)
               (insert ")")
               (with-syntax-table
                   word-syntax-table-with-open/close-delimiter
                 (forward-sexp -1))))

            (t ;;else
             (message "change-parentheses have nothing to do here !"))))
    #+end_src

*** move-line-[backword|foreword]
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "M-u") 'move-line-backword)
    (global-set-key (kbd "M-i") 'move-line-foreword)
    (global-set-key (kbd "M-[") 'change-parentheses)
    #+end_src

*** member-string?
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun member-string? (x l)
      (cond ((null l) nil)
            ((string-equal x (car l))
             t)
            (:else
             (member-string? x (cdr l)))))
    #+end_src

*** jump-to-register
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-.") 'ska-point-to-register)
    (global-set-key (kbd "C-,") 'ska-jump-to-register)
    (defun ska-point-to-register()
      "Store cursorposition _fast_ in a register.
    Use ska-jump-to-register to jump back to the stored
    position."
      (interactive)
      (setq zmacs-region-stays t)
      (point-to-register 8))

    (defun ska-jump-to-register()
      "Switches between current cursorposition and position
    that was stored with ska-point-to-register."
      (interactive)
      (setq zmacs-region-stays t)
      (let ((tmp (point-marker)))
            (jump-to-register 8)
            (set-register 8 tmp)))
    #+end_src

*** go-to-char
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (string c1 ...)
    ;; concatenate all the argument characters
    ;; and make the result a string

    ;; (search-forward STRING &optional BOUND NOERROR COUNT)

    ;; (read-char &optional PROMPT INHERIT-INPUT-METHOD SECONDS)

    (defun go-to-char (n char)
          "Move forward to Nth occurence of CHAR.
    Typing `go-to-char-key' again will move forwad to the next Nth
    occurence of CHAR."
          (interactive "p\ncGo to char: ")
          (search-forward (string char) nil nil n)
          (while (char-equal (read-char) char)
            (search-forward (string char) nil nil n))
          (setq unread-command-events (list last-input-event)))

    (define-key global-map (kbd "C-c c") 'go-to-char)
    #+end_src

*** my-quote
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; so here is a encoding for registers:
    ;; n-w
    ;; ==>
    ;; (+ (* 52 (- ?n ?A))
    ;;    (* (- ?w ?A)))

    (setq next-whitespace-register
              (+ (* 52 (- ?n ?A))
             (* (- ?w ?A))))
    (setq end-of-line-register
              (+ (* 52 52 (- ?e ?A))
             (* 52 (- ?o ?A))
             (* (- ?l ?A))))
    (setq my-word-quote-register
              (+ (* 52 52 (- ?m ?A))
             (* 52 (- ?w ?A))
             (* (- ?q ?A))))
    (defun next-whitespace ()
      (interactive)
      (let ((searching-for-next-whitespace
             (search-forward (string 32) nil t 1)))
            (left-char 1)
            (if (null searching-for-next-whitespace)
            'non-nil
              nil)))

    (defun my-word-quote ()
      "abc ==> ``abc''"
      (interactive)
      (progn
            (insert "`")
            (point-to-register my-word-quote-register)

            (if (null (next-whitespace))
            (point-to-register next-whitespace-register)
              ;; else there is no next-whitespace
              (set-register next-whitespace-register
                            ':no-next-whitespace:))

            (jump-to-register my-word-quote-register)

            (end-of-line)
            (point-to-register end-of-line-register)

            (cond ((eq (get-register next-whitespace-register)
                       ':no-next-whitespace:)
               (jump-to-register end-of-line-register)
               (insert "'"))
              (t;else
               (if (< (get-register next-whitespace-register)
                      (get-register end-of-line-register))
                       (jump-to-register next-whitespace-register)
                     (jump-to-register end-of-line-register))
               (insert "'")))

            (jump-to-register my-word-quote-register)
            ))
    (global-set-key (kbd "M-'") 'my-word-quote)


    (defun my-line-quote ()
      "abc 123 ==> ``abc 123''"
      (interactive)
      (progn
            (insert "``")
            (org-end-of-line)
            (insert "''")))
    (global-set-key (kbd "C-x M-'") 'my-line-quote)
    #+end_src

*** key board macros
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-<C-f1> ()
      (interactive)
      (forward-word)
      (delete-char 1)
      (insert "-"))
    (global-set-key (kbd "<C-f1>") 'my-<C-f1>)

    (defun my-<C-f2> ()
      (interactive)
      (forward-word)
      (delete-char 1)
      (insert "_"))
    (global-set-key (kbd "<C-f2>") 'my-<C-f2>)
    #+end_src

*** generator
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defvar number-generator:*counter* 0)
    (defun number-generator ()
      (setq number-generator:*counter* (+ number-generator:*counter* 1))
      number-generator:*counter*)
    #+end_src

*** dash (needed by something)
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/dash/")
    (require 'dash)
    #+end_src

*** epl (needed by something)
    Emacs Package Library
    #+begin_src emacs-lisp  :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/epl/")
    (require 'epl)
    #+end_src

*** pkg-info (needed by something)
    #+begin_src emacs-lisp  :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/pkg-info/")
    (require 'pkg-info)
    #+end_src

*** load xrdb
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun xrdb ()
      (interactive)
      (eshell-command "xrdb ~/.Xresource"))
    #+end_src

*** load-path
    * path is loaded as much separately as possible
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/")
    #+end_src

* key binding

*** unbinding
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; orientally: transpose-words
    (global-set-key (kbd "M-t") 'nil)
    #+end_src

*** prefix-command
    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-prefix-command 'C-s-map)
    (global-set-key (kbd "C-s") 'C-s-map)
    ;; used by:
    ;; "C-s C-r" : rename-buffer
    ;; "C-s C-s" : org-edit-src-code
    ;; "C-s C-x" : switch-to-buffer-*scheme*
    ;; "C-s C-c" : switch-to-buffer-*haskell*
    ;; "C-s C-e" : my-switch-to-eshell
    #+end_src

*** example of prefix-command
    #+begin_src emacs-lisp
    (define-prefix-command '存-map)
    (global-set-key (kbd "存") '存-map)
    (define-key 存-map (kbd "盘") 'save-buffer)

    (define-prefix-command 'ctl-z-map)
    (define-prefix-command '存-map)
    (define-prefix-command '盘-map)

    (global-set-key (kbd "C-z") 'ctl-z-map)
    (define-key ctl-z-map (kbd "存") '存-map)
    (define-key 存-map (kbd "盘") '盘-map)

    (define-key 盘-map (kbd "！") 'save-buffer)
    (define-key 盘-map (kbd "到") 'write-file)
    (define-key 盘-map (kbd "退出")
      (lambda ()
            (interactive)
            (save-buffer)
            (kill-emacs)))
    #+end_src

*** cruise
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun window-> () (interactive) (other-window +1))
    (defun <-window () (interactive) (other-window -1))

    ;; 没有使用<C-tab>
    ;; 因为<C-tab>需要在 org-mode 中使用
    ;; 因为按<tab>的时候可以不放开 Ctrl 是方便的
    (global-set-key (kbd "M-<tab>") 'window->)
    ;; (global-set-key (kbd "M-<tab>") (lambda () (interactive) (other-window +1)))

    (global-set-key (kbd "M-=") 'window->)
    (global-set-key (kbd "M--") '<-window)
    ;; (global-set-key (kbd "M-0") 'window->)
    ;; (global-set-key (kbd "M-9") '<-window)

    (global-set-key (kbd "C-x .") 'next-buffer)
    (global-set-key (kbd "C-x ,") 'previous-buffer)

    (global-set-key (kbd "C-M-.") 'next-buffer)
    (global-set-key (kbd "C-M-,") 'previous-buffer)

    (global-set-key (kbd "M-p") 'backward-paragraph)
    (global-set-key (kbd "M-n") 'forward-paragraph)
    #+end_src

*** window resizing
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-M-h") 'shrink-window-horizontally)
    (global-set-key (kbd "C-M-l") 'enlarge-window-horizontally)
    (global-set-key (kbd "C-M-j") 'shrink-window)
    (global-set-key (kbd "C-M-k") 'enlarge-window)
    #+end_src

*** path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "<C-M-return>") 'pwd)
    #+end_src

*** line wrap
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-M-g") 'global-visual-line-mode)
    #+end_src

*** comment
    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-prefix-command '<menu>-map)
    (global-set-key (kbd "<menu>") '<menu>-map)

    (global-set-key (kbd "<menu> '") 'comment-region)
    (global-set-key (kbd "<menu> ;") 'uncomment-region)
    #+end_src

*** edit
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; backward-kill-sentence

    ;; (defun say-not-binding ()
    ;;   (interactive)
    ;;   (message "this key have not binding"))

    (global-set-key (kbd "C-x <backspace>") 'delete-backward-char)
    #+end_src

*** view
    + 如果不左右 scroll
      emacs 就会自动为把长的行折反到视野中来(org-mode 除外)
    + M-< : beginning-of-buffer
      M-> : end-of-buffer
      + 不要与下面的绑定混淆
        M-, : org-babel-previous-src-block
        M-. : org-babel-next-src-block
    + C-v : scroll-up-command
      M-v : scroll-down-command
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun scroll-right-as-my-wish ()
      (interactive)
      (scroll-left -1 1))
    (defun scroll-left-as-my-wish ()
      (interactive)
      (scroll-left 1 1))
    (global-set-key (kbd "<prior>") 'scroll-right-as-my-wish)
    (global-set-key (kbd "<next>") 'scroll-left-as-my-wish)
    (setq hscroll-step 1
              hscroll-margin 6)
    #+end_src

*** search
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-t") 'isearch-forward)
    (add-hook 'isearch-mode-hook
              (lambda ()
                    (define-key isearch-mode-map (kbd "C-t") 'isearch-repeat-forward)
                    ))
    #+end_src

*** query-replace
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "M-q") 'query-replace)
    #+end_src

*** help
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-/") 'help)
    #+end_src

*** rename-buffer
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-s C-r") 'rename-buffer)
    #+end_src

*** insert (some trick here)
    can't bind C-M-i to new function in normal way

    and TAB == C-i

    one can find:
    (kbd "C-i") == (kbd "TAB") == "	"
    (kbd "C-M-i") == [134217737]
    in elisp-repl
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (define-key input-decode-map [?\C-i] [control-i])
    ;; (global-set-key [control-i] 'insert-newline-below)

    (define-key input-decode-map [134217737] [C-M-i])
    (global-set-key [C-M-i] 'insert-newline-below)

    (defun insert-newline-below ()
      (interactive)
      (insert "\n")
      (backward-char 1))
    #+end_src

*** whitespace
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key
     (kbd "C-M-w")
     (lambda ()
       (interactive)
       (message "* (whitespace-cleanup)")
       (whitespace-cleanup)))

    (global-set-key
     (kbd "M-W")
     (lambda ()
       (interactive)
       (message "* (whitespace-cleanup)")
       (whitespace-cleanup)))


    ;; 有了下面的設置 每次 C-x C-s 時 就會自動清除 whitespace
    ;; automatically clean up bad whitespace
    ;; (setq whitespace-action '(auto-cleanup))

    ;; only show bad whitespace
    (setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab))

    (whitespace-mode t)
    (global-whitespace-mode t)
    #+end_src

*** mania
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-s C-x") 'save-buffer)
    #+end_src

* general setting

*** variable
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq case-fold-search nil)
    (setq case-replace nil)
    (setq indent-tabs-mode nil)
    (setq-default indent-tabs-mode nil)
    ;; 全局设置上面的变量并没有用
    ;;   设想如果我能用一个树状图来清晰地描述 mode 之间的继承与依赖关系
    ;;   而不是只有简单的 major 和 minor 两个层次
    ;;   并且我能方便的浏览这个树
    ;;   能像操作一个列表一样方便的调整这个树
    ;; 写一个不光有更好配置语言的
    ;; 而且有更好的设计的文本编辑器也许并没有那么难
    (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))

    (fringe-mode 1)

    (transient-mark-mode t)

    (setq column-number-mode t)

    (setq mouse-yank-at-point t)

    (setq kill-ring-max 200)

    ;(setq enable-recursive-minibuffers t)

    (setq scroll-margin 4
              scroll-conservatively 10000)

    ;(setq default-major-mode 'org-mode)

    (show-paren-mode t)
    (setq show-paren-style 'parentheses)
    #+end_src

*** enable disable
    #+begin_src emacs-lisp :tangle ~/.emacs
    (put 'set-goal-column 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    #+end_src

*** simple version control
    #+begin_src emacs-lisp
    ;; to keep the *~ style backup
    ;; is to:
    (setq make-backup-files t)
    #+end_src

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq
     backup-by-copying t
     version-control t
     delete-old-versions t
     kept-new-versions 10
     kept-old-versions 0
     dired-kept-versions 1
     )
    #+end_src

*** variable about mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq modes-about-lisp
          '(scheme-mode
            inferior-scheme-mode

            lisp-mode
            lisp-interaction-mode

            emacs-lisp-mode
            ielm-mode
            inferior-emacs-lisp-mode
            ))

    (setq modes-about-haskell
          '(haskell-mode
            inferior-haskell-mode
            ))

    (setq modes-about-C
          '(c-mode
            ))

    (setq modes-about-cicada
          '(cicada-mode
            inferior-cicada-mode
            ))
    #+end_src

*** kill-buffer-query-functions
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq kill-buffer-query-functions nil)
    #+end_src

* note little input method
  输入法和文本编辑器相辅相成同等重要
  emcas 因一个 bug 而不能使用 input method framework
  启动 emcas 前需要更改环境变量 LC_CTYPE 来弥补这个问题
  #+begin_src sh
  LC_CTYPE=zh_CN.UTF-8 emacs
  #+end_src

  #+begin_src sh
  export LC_CTYPE=zh_CN.UTF-8
  emacs &
  #+end_src

  有的时候能直接用
  有的时候必须要用上面的方法

* <f1>

*** note
    point-to-register: C-x r SPC
    jump-to-register: C-x r j
    get-register

*** init-<f1>
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (define-prefix-command '<f1>-map)
    ;; (global-set-key (kbd "<f1>") '<f1>-map)


    (defun init-<f1> ()
      (interactive)
      (progn
        (cond ((memq major-mode modes-about-lisp)
               (init-<f1>-for-lisp))

              ((eq major-mode 'cicada-nymph-mode)
               (init-<f1>-for-cicada-nymph))

              ((eq major-mode 'org-mode)
               ;; for i am a LISPer
               (init-<f1>-for-lisp))

              ((eq major-mode 'coq-mode)
               (init-<f1>-for-coq))

              ((memq major-mode modes-about-haskell)
               (init-<f1>-for-haskell))

              ((memq major-mode modes-about-C)
               (init-<f1>-for-C))

              ((eq major-mode 'caml-mode)
               (init-<f1>-for-caml))

              (t
               (message "<f1> have do nothing in this major mode"))

              )))

    (global-set-key (kbd "<f1>") 'init-<f1>)
    #+end_src

*** insert things
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun insert-lambda () (interactive) (insert "lambda"))

    ;; first-order-logic
    (defun insert-∧ () (interactive) (insert "∧"))
    (defun insert-∨ () (interactive) (insert "∨"))
    (defun insert-¬ () (interactive) (insert "¬"))
    (defun insert-→ () (interactive) (insert "→"))
    (defun insert-← () (interactive) (insert "←"))
    (defun insert-↔ () (interactive) (insert "↔"))
    (defun insert-∃ () (interactive) (insert "∃"))
    (defun insert-∀ () (interactive) (insert "∀"))

    ;; set theory
    (defun insert-∈ () (interactive) (insert "∈"))
    (defun insert-⋶ () (interactive) (insert "⋶"))
    (defun insert-є () (interactive) (insert "є"))
    (defun insert-э () (interactive) (insert "э"))
    (defun insert-⊂ () (interactive) (insert "⊂"))
    (defun insert-⊃ () (interactive) (insert "⊃"))
    (defun insert-⊄ () (interactive) (insert "⊄"))
    (defun insert-⊅ () (interactive) (insert "⊅"))
    (defun insert-⊆ () (interactive) (insert "⊆"))
    (defun insert-⊇ () (interactive) (insert "⊇"))
    (defun insert-∩ () (interactive) (insert "∩"))
    (defun insert-∪ () (interactive) (insert "∪"))
    (defun insert-∅ () (interactive) (insert "∅"))

    ;; about function
    (defun insert-↤ () (interactive) (insert "↤"))
    (defun insert-↦ () (interactive) (insert "↦"))
    (defun insert-<- () (interactive) (insert "<-"))
    (defun insert--> () (interactive) (insert "->"))

    ;; proof theory
    (defun insert-≡ () (interactive) (insert "≡"))
    (defun insert-ͱ () (interactive) (insert "ͱ"))
    (defun insert-⊢ () (interactive) (insert "⊢"))
    (defun insert-⊦ () (interactive) (insert "⊦"))

    ;; _ and ^
    (defun insert-∞ () (interactive) (insert "∞"))
    (defun insert-√ () (interactive) (insert "√"))
    (defun insert-¿ () (interactive) (insert "¿"))
    (defun insert-° () (interactive) (insert "°"))

    ;; mics
    (defun insert-ߊ () (interactive) (insert "ߊ"))
    (defun insert-▓ () (interactive) (insert "▓"))
    #+end_src

*** init-<f1>-for-cicada-nymph
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-cicada-nymph ()
      (interactive)
      (progn
        ;; 需要快捷输入 lambda
        (local-set-key
         (kbd "<f1> <f1>")
         (lambda ()
           (interactive)
           (insert ": ")
           (point-to-register ?c)
           (insert "\n")
           (insert "  << -- >>\n")
           (insert "  \n")
           (insert "  end\n")
           (insert "; define-function")
           (jump-to-register ?c)
           ))

        ;; connectives
        (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
        (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
        (local-set-key (kbd "<f1> -") 'insert-¬);; negation
        (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
        (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
        ;; quantifiers
        (local-set-key (kbd "<f1> a") 'insert-∀);; all
        (local-set-key (kbd "<f1> e") 'insert-∃);; exist

        ;; set thoery
        (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
        (local-set-key (kbd "<f1> 0") 'insert-∅)
        (local-set-key (kbd "<f1> [") 'insert-⊂)
        (local-set-key (kbd "<f1> ]") 'insert-⊃)
        (local-set-key (kbd "<f1> u") 'insert-∪)
        (local-set-key (kbd "<f1> n") 'insert-∩)


        (local-set-key (kbd "<f1> k") 'insert-√);; check
        (local-set-key (kbd "<f1> =") 'insert-≡)
        (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

        ;; _ and ^
        (local-set-key (kbd "<f1> o") 'insert-°)
        (local-set-key (kbd "<f1> 9") 'insert-∞)
        ))
    #+end_src

*** init-<f1>-for-lisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-lisp ()
      (interactive)
      (progn
            ;; 需要快捷输入 lambda
            (local-set-key (kbd "<f1> <f1>") 'insert-lambda)

            ;; connectives
            (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
            (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
            (local-set-key (kbd "<f1> -") 'insert-¬);; negation
            (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
            (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
            ;; quantifiers
            (local-set-key (kbd "<f1> a") 'insert-∀);; all
            (local-set-key (kbd "<f1> e") 'insert-∃);; exist

            ;; set thoery
            (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
            (local-set-key (kbd "<f1> 0") 'insert-∅)
            (local-set-key (kbd "<f1> [") 'insert-⊂)
            (local-set-key (kbd "<f1> ]") 'insert-⊃)
            (local-set-key (kbd "<f1> u") 'insert-∪)
            (local-set-key (kbd "<f1> n") 'insert-∩)


            (local-set-key (kbd "<f1> k") 'insert-√);; check
            (local-set-key (kbd "<f1> =") 'insert-≡)
            (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

            ;; _ and ^
            (local-set-key (kbd "<f1> o") 'insert-°)
            (local-set-key (kbd "<f1> 9") 'insert-∞)
            ))
    #+end_src

*** init-<f1>-for-haskell
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-haskell ()
      (interactive)
      (progn
            ;; 需要快捷输入->
            (local-set-key (kbd "<f1> <f1>") 'insert-->)

            ;; connectives
            (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
            (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
            (local-set-key (kbd "<f1> n") 'insert-¬);; negation
            (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
            (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
            ;; quantifiers
            (local-set-key (kbd "<f1> a") 'insert-∀);; all
            (local-set-key (kbd "<f1> e") 'insert-∃);; exist

            ;; set thoery
            (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
            (local-set-key (kbd "<f1> 0") 'insert-∅)
            (local-set-key (kbd "<f1> [") 'insert-⊂)
            (local-set-key (kbd "<f1> ]") 'insert-⊃)

            (local-set-key (kbd "<f1> k") 'insert-√);; check
            (local-set-key (kbd "<f1> =") 'insert-≡)
            (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

            ;; _ and ^
            (local-set-key (kbd "<f1> o") 'insert-°)
            ))
    #+end_src

*** init-<f1>-for-C
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-C ()
       (interactive)
       (progn
             (local-set-key (kbd "<f1> <f1> <f1>")
                            (lambda ()
                              (interactive)
                              (insert "main ()\n{\n  \n}")
                              (left-char 2)))
             (local-set-key (kbd "<f1> <f1> f")
                            (lambda ()
                              (interactive)
                              ;; ?C == 67
                              (progn
                            (insert "for (")
                            (c-indent-line-or-region)
                            (point-to-register ?C)
                            (insert "; ; )\n;")
                            (c-indent-line-or-region)
                            (right-char 2)
                            (c-indent-line-or-region)
                            (jump-to-register ?C))))
             ;; (local-set-key (kbd "<f1> <f1> c")
             ;;                (lambda ()
             ;;                  (interactive)
             ;;                  ;; ?C == 67
             ;;                  (progn
             ;;                    (insert "for (")
             ;;                    (c-indent-line-or-region)
             ;;                    (point-to-register ?C)
             ;;                    (insert "; ; )\n;")
             ;;                    (c-indent-line-or-region)
             ;;                    (right-char 2)
             ;;                    (c-indent-line-or-region)
             ;;                    (jump-to-register ?C))))

             (local-set-key (kbd "<f1> <f1> i")
                            (lambda ()
                              (interactive)
                              (insert "# include <.h>")
                              (left-char 3)))
             (local-set-key (kbd "<f1> <f1> d")
                            (lambda ()
                              (interactive)
                              (insert "# define ")))
             (local-set-key (kbd "<f1> t")
                            ;; t denote type
                            (lambda ()
                              (interactive)
                              (insert "/* ")
                              (point-to-register ?t)
                              (insert " ::  <-  */\n")
                              (insert "/*\n")
                              (insert "  CREATE:\n\n")
                              (insert "  READ:\n\n")
                              (insert "  WRITE:\n\n")
                              (insert "*/\n")
                              (jump-to-register ?t)
                              ))

             ;; connectives
             (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
             (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
             (local-set-key (kbd "<f1> n") 'insert-¬);; negation
             (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
             (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
             ;; quantifiers
             (local-set-key (kbd "<f1> a") 'insert-∀);; all
             (local-set-key (kbd "<f1> e") 'insert-∃);; exist

             ;; set thoery
             (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
             (local-set-key (kbd "<f1> 0") 'insert-∅)
             (local-set-key (kbd "<f1> [") 'insert-⊂)
             (local-set-key (kbd "<f1> ]") 'insert-⊃)

             (local-set-key (kbd "<f1> k") 'insert-√);; check
             (local-set-key (kbd "<f1> =") 'insert-≡)
             (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

             ;; _ and ^
             (local-set-key (kbd "<f1> o") 'insert-°)
             ))
    #+end_src

*** init-<f1>-for-coq
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-coq ()
      (interactive)
      (progn
            (local-set-key (kbd "<f1> <f1>")
                            (lambda ()
                              (interactive)
                              (progn
                            (insert "Eval compute in\n")
                            (indent-for-tab-command))))
            (local-set-key (kbd "<f1> p")
                           (lambda ()
                             (interactive)
                             (progn
                               (insert "Proof.\n")
                               (indent-for-tab-command)
                               (point-to-register ?c)
                               (insert "\nQed.")
                               (jump-to-register ?c))))

            ;; connectives
            (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
            (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
            (local-set-key (kbd "<f1> n") 'insert-¬);; negation
            (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
            (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
            ;; quantifiers
            (local-set-key (kbd "<f1> a") 'insert-∀);; all
            ;; (local-set-key (kbd "<f1> e") 'insert-∃);; exist

            ;; set thoery
            (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
            (local-set-key (kbd "<f1> 0") 'insert-∅)
            (local-set-key (kbd "<f1> [") 'insert-⊂)
            (local-set-key (kbd "<f1> ]") 'insert-⊃)

            (local-set-key (kbd "<f1> k") 'insert-√);; check
            (local-set-key (kbd "<f1> =") 'insert-≡)
            (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

            ;; _ and ^
            (local-set-key (kbd "<f1> o") 'insert-°)
            ))
    #+end_src

*** init-<f1>-for-caml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f1>-for-caml ()
      (interactive)
      (progn
            ;; 需要快捷输入 lambda
            (local-set-key (kbd "<f1> <f1>")
                       (lambda ()
                             (interactive)
                             (progn
                               (insert "function ")
                               (insert "(")
                               (point-to-register ?m)
                               (insert ")")
                               (caml-indent-command)
                               (insert "\n")
                               (insert "-> ")
                               (caml-indent-command)
                               (jump-to-register ?m))))

            ;; connectives
            (local-set-key (kbd "<f1> c") 'insert-∧)        ;; conjunction
            (local-set-key (kbd "<f1> d") 'insert-∨)        ;; disjunction
            (local-set-key (kbd "<f1> -") 'insert-¬)         ;; negation
            (local-set-key (kbd "<f1> <right>") 'insert-→)  ;; implication
            (local-set-key (kbd "<f1> <S-right>") 'insert-↔) ;; equivalence
            ;; quantifiers
            (local-set-key (kbd "<f1> a") 'insert-∀) ;; all
            (local-set-key (kbd "<f1> e") 'insert-∃) ;; exist

            ;; set thoery
            (local-set-key (kbd "<f1> b") 'insert-∈) ;; belong to
            (local-set-key (kbd "<f1> 0") 'insert-∅)
            (local-set-key (kbd "<f1> [") 'insert-⊂)
            (local-set-key (kbd "<f1> ]") 'insert-⊃)
            (local-set-key (kbd "<f1> u") 'insert-∪)
            (local-set-key (kbd "<f1> n") 'insert-∩)


            (local-set-key (kbd "<f1> k") 'insert-√) ;; check
            (local-set-key (kbd "<f1> =") 'insert-≡)
            (local-set-key (kbd "<f1> i") 'insert-ͱ) ;; inference

            ;; _ and ^
            (local-set-key (kbd "<f1> o") 'insert-°)
            (local-set-key (kbd "<f1> 9") 'insert-∞)
            ))
    #+end_src

* <f2>

*** init-<f2>
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (define-prefix-command '<f2>-map)
    ;; (global-set-key (kbd "<f2>") '<f2>-map)

    (defun init-<f2> ()
      (interactive)
      (cond ((memq major-mode modes-about-lisp)
             (init-<f2>-for-lisp))

            ((eq major-mode 'cicada-nymph-mode)
             (init-<f2>-for-cicada-nymph))

            ((eq major-mode 'org-mode)
             ;; for i am a LISPer
             (init-<f2>-for-lisp))

            ((eq major-mode 'coq-mode)
             (init-<f2>-for-coq))

            ((eq major-mode 'agda2-mode)
             (init-<f2>-for-agda))

            ((eq major-mode 'caml-mode)
             (init-<f2>-for-caml))

            ((memq major-mode modes-about-haskell)
             (init-<f2>-for-haskell))

            (t
             (message "<f2> have do nothing in this major mode"))

            ))
    (global-set-key (kbd "<f2>") 'init-<f2>)
    #+end_src

*** insert things
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun insert-α () (interactive) (insert "α"))
    (defun insert-β () (interactive) (insert "β"))
    (defun insert-γ () (interactive) (insert "γ"))
    (defun insert-δ () (interactive) (insert "δ"))
    (defun insert-ε () (interactive) (insert "ε"))
    (defun insert-θ () (interactive) (insert "θ"))
    (defun insert-Θ () (interactive) (insert "Θ"))
    (defun insert-ι () (interactive) (insert "ι"))
    (defun insert-κ () (interactive) (insert "κ"))
    (defun insert-λ () (interactive) (insert "λ"))
    (defun insert-Λ () (interactive) (insert "Λ"))
    (defun insert-σ () (interactive) (insert "σ"))
    (defun insert-ς () (interactive) (insert "ς"))
    (defun insert-Σ () (interactive) (insert "Σ"))
    (defun insert-τ () (interactive) (insert "τ"))
    (defun insert-ζ () (interactive) (insert "ζ"))
    (defun insert-ω () (interactive) (insert "ω"))
    (defun insert-Ω () (interactive) (insert "Ω"))
    (defun insert-π () (interactive) (insert "π"))
    (defun insert-Π () (interactive) (insert "Π"))
    (defun insert-ρ () (interactive) (insert "ρ"))
    (defun insert-φ () (interactive) (insert "φ"))
    (defun insert-Φ () (interactive) (insert "Φ"))
    (defun insert-υ () (interactive) (insert "υ"))
    (defun insert-ν () (interactive) (insert "ν"))
    (defun insert-χ () (interactive) (insert "χ"))
    (defun insert-Ψ () (interactive) (insert "Ψ"))
    (defun insert-ψ () (interactive) (insert "ψ"))
    (defun insert-μ () (interactive) (insert "μ"))
    (defun insert-η () (interactive) (insert "η"))
    (defun insert-Γ () (interactive) (insert "Γ"))
    (defun insert-Δ () (interactive) (insert "Δ"))
    (defun insert-ξ () (interactive) (insert "ξ"))
    (defun insert-Ξ () (interactive) (insert "Ξ"))
    #+end_src

*** init-<f2>-for-cicada-nymph
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-cicada-nymph ()
      (interactive)
      (progn
        ;; 需要快捷输入λ
        (local-set-key (kbd "<f2> <f2>") 'insert-λ)

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

*** init-<f2>-for-lisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-lisp ()
      (interactive)
      (progn
        ;; 需要快捷输入λ
        (local-set-key (kbd "<f2> <f2>") 'insert-λ)

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

*** init-<f2>-for-haskell
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-haskell ()
      (interactive)
      (progn
        ;; 需要快捷输入λ
        (local-set-key (kbd "<f2> <f2>") (lambda ()
                                           (interactive)
                                           (insert "(\\ -> )")
                                           (left-char 5)))
        (local-set-key (kbd "<f2> <right>") (lambda ()
                                              (interactive)
                                              (insert "->")))
        (local-set-key (kbd "<f2> <left>") (lambda ()
                                             (interactive)
                                             (insert "<-")))

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

*** init-<f2>-for-coq
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-coq ()
      (interactive)
      (progn
        ;; 需要快捷输入λ
        (local-set-key (kbd "<f2> <f2>") 'insert-λ)

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

*** init-<f2>-for-agda
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-agda ()
      (interactive)
      (progn
        ;; 需要快捷输入λ
        (local-set-key (kbd "<f2> <f2>") 'insert-λ)

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

*** init-<f2>-for-caml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun init-<f2>-for-caml ()
      (interactive)
      (progn
        (local-set-key (kbd "<f2> <f2>")
                       (lambda ()
                         (interactive)
                         (progn
                           (insert "| ")
                           (insert "(")
                           (point-to-register ?m)
                           (insert ")")
                           (caml-indent-command)
                           (insert "\n")
                           (insert "-> ")
                           (caml-indent-command)
                           (jump-to-register ?m))))

        (local-set-key (kbd "<f2> a") 'insert-α)
        (local-set-key (kbd "<f2> b") 'insert-β)
        (local-set-key (kbd "<f2> c") 'insert-γ)
        (local-set-key (kbd "<f2> C") 'insert-Γ)
        (local-set-key (kbd "<f2> g") 'insert-γ)
        (local-set-key (kbd "<f2> G") 'insert-Γ)
        (local-set-key (kbd "<f2> d") 'insert-δ)
        (local-set-key (kbd "<f2> D") 'insert-Δ)
        (local-set-key (kbd "<f2> e") 'insert-ε)
        (local-set-key (kbd "<f2> f") 'insert-φ)
        (local-set-key (kbd "<f2> F") 'insert-Φ)
        ;; th = Θ, θ
        (local-set-key (kbd "<f2> h") 'insert-θ)
        (local-set-key (kbd "<f2> H") 'insert-Θ)
        (local-set-key (kbd "<f2> i") 'insert-η)
        ;;(local-set-key (kbd "<f2> i") 'insert-ι)
        (local-set-key (kbd "<f2> k") 'insert-κ)
        (local-set-key (kbd "<f2> l") 'insert-λ)
        (local-set-key (kbd "<f2> L") 'insert-Λ)
        (local-set-key (kbd "<f2> m") 'insert-μ)
        (local-set-key (kbd "<f2> n") 'insert-ν)
        (local-set-key (kbd "<f2> o") 'insert-ω)
        (local-set-key (kbd "<f2> O") 'insert-Ω)
        (local-set-key (kbd "<f2> p") 'insert-π)
        (local-set-key (kbd "<f2> P") 'insert-Π)
        (local-set-key (kbd "<f2> r") 'insert-ρ)
        (local-set-key (kbd "<f2> s") 'insert-σ)
        ;; final sigma
        ;;(local-set-key (kbd "<f2> s") 'insert-ς)
        (local-set-key (kbd "<f2> S") 'insert-Σ)
        (local-set-key (kbd "<f2> t") 'insert-τ)
        (local-set-key (kbd "<f2> u") 'insert-υ)
        (local-set-key (kbd "<f2> v") nil)
        (local-set-key (kbd "<f2> x") 'insert-ξ)
        (local-set-key (kbd "<f2> X") 'insert-Ξ)
        ;; ps = ψ, Ψ
        (local-set-key (kbd "<f2> y") 'insert-Ψ)
        (local-set-key (kbd "<f2> Y") 'insert-ψ)
        (local-set-key (kbd "<f2> z") 'insert-ζ)
        ))
    #+end_src

* language

*** load progmodes
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/progmodes/")
    #+end_src

*** repl-space
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/repl-space/")
    (require 'repl-space)
    #+end_src

*** edit sexp

***** load-path
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/edit-sexp/")
      #+end_src

***** mark and cruise
      the follow functions are belong to lisp.el
      #+begin_src emacs-lisp :tangle ~/.emacs
      (global-set-key (kbd "s-z") 'mark-defun)
      (global-set-key (kbd "s-a") 'mark-sexp)

      (global-set-key (kbd "s-w") 'backward-sexp)
      (global-set-key (kbd "s-s") 'forward-sexp)

      (defun in-> () (interactive) (down-list))
      (global-set-key (kbd "s-e") 'in->)

      (defun <-out () (interactive) (backward-up-list))
      (global-set-key (kbd "s-q") '<-out)

      (defun out-> () (interactive) (up-list))
      (global-set-key (kbd "s-d") 'out->)

      ;; the following is for emacs-nox which can not see s-
      (define-key input-decode-map [134217825] [M-a])
      (global-set-key [M-a] 'mark-sexp)

      ;; (global-set-key (kbd "C-M-p") 'backward-sexp)
      ;; (global-set-key (kbd "C-M-n") 'forward-sexp)

      ;; (global-set-key (kbd "C-M-f") 'in->)

      ;; (global-set-key (kbd "C-M-b") '<-out)
      #+end_src

***** paredit
      file:~/.emacs.d/edit-sexp/paredit.el
      #+begin_src emacs-lisp :tangle ~/.emacs
      (autoload 'enable-paredit-mode
          "paredit"
        "Turn on pseudo-structural editing of Lisp code." t)

      (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
      (add-hook 'inferior-scheme-mode-hook  #'enable-paredit-mode)

      (add-hook 'racket-repl-mode-hook      #'enable-paredit-mode)
      (add-hook 'racket-mode-hook           #'enable-paredit-mode)


      (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
      (add-hook 'slime-repl-mode-hook       #'enable-paredit-mode)
      (add-hook 'slime-mode-hook            #'enable-paredit-mode)



      (add-hook 'lfe-mode-hook              #'enable-paredit-mode)
      (add-hook 'inferior-lfe-mode-hook     #'enable-paredit-mode)

      (add-hook 'shen-mode-hook             #'enable-paredit-mode)
      (add-hook 'inferior-shen-mode-hook    #'enable-paredit-mode)

      (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
      (add-hook 'cider-repl-mode-hook       #'enable-paredit-mode)


      ;; (add-hook 'ielm-mode-hook             #'enable-paredit-mode)

      ;; the following is about the *scratch* buffer
      ;; (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
      ;; 不知道为什么这里就算使用 maybe-map-paredit-newline 也总是绑定不到 RET
      ;; 只有在下面的 mode 中不使用 enable-paredit-mode
      ;; *scratch* buffer 中的 RET 才能正常
      (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)


      (add-hook 'coq-mode-hook              #'enable-paredit-mode)

      ;; (add-hook 'haskell-mode-hook          #'enable-paredit-mode)

      ;; (add-hook 'c-mode-hook                #'enable-paredit-mode)


      (defun maybe-map-paredit-newline ()
        (cond
          ((memq major-mode '(inferior-scheme-mode
                              inferior-shen-mode
                              inferior-emacs-lisp-mode
                              lisp-interaction-mode
                              inferior-haskell-mode))
           (local-set-key (kbd "RET") 'comint-send-input))
          ((memq major-mode '(scheme-mode
                              emacs-lisp-mode
                              lisp-mode
                              lisp-interaction-mode))
           (local-set-key (kbd "RET") 'paredit-newline))
          ))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

      ;; for i want to use paredit a lot of place out of LISP
      ;; i comment out the binding of:
      ;; ";" -> paredit-semicolon
      ;; "M-;" -> paredit-comment-dwim
      ;; in the paredit.el
      (defun maybe-map-paredit-semicolon ()
        (cond
          ((memq major-mode modes-about-lisp)
           (progn
             (local-set-key (kbd ";") 'paredit-semicolon)
             (local-set-key (kbd "M-;") 'paredit-comment-dwim)))
          ))
      (add-hook 'paredit-mode-hook 'maybe-map-paredit-semicolon)
      #+end_src

***** >< a easier way to insert "(" ")" (not using)
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (defun my-insert-9 () (interactive) (insert "9"))
      (defun my-insert-0 () (interactive) (insert "0"))

      (add-hook 'scheme-mode-hook
                (lambda ()
                      (local-set-key (kbd "9") 'paredit-open-round)
                      (local-set-key (kbd "0") 'paredit-close-round)
                      (local-set-key (kbd "(") 'my-insert-9)
                      (local-set-key (kbd ")") 'my-insert-0)
                      ))
      #+end_src

***** mini-parentheses-editor
      parentheses /pəˈrɛnθəsiːz/
      is plural form of parenthesis /pəˈrɛnθəsɪs/
      #+begin_src emacs-lisp :tangle ~/.emacs
      (global-set-key (kbd "M-(")         'paredit-wrap-round)
      (global-set-key (kbd "M-s")         'paredit-splice-sexp)
      (global-set-key (kbd "M-r")         'paredit-raise-sexp)
      (global-set-key (kbd "<C-right>")   'paredit-forward-slurp-sexp)
      (global-set-key (kbd "<C-left>")    'paredit-forward-barf-sexp)
      (global-set-key (kbd "M-\"")        'paredit-meta-doublequote)
      (global-set-key (kbd "<C-M-right>") 'paredit-backward-barf-sexp)
      (global-set-key (kbd "<C-M-left>")  'paredit-backward-slurp-sexp)
      ;; (global-set-key (kbd "C-d")         'paredit-forward-delete)
      ;; (global-set-key (kbd "<backspace>") 'paredit-backward-delete)
      ;; (global-set-key (kbd "C-k")         'paredit-kill)
      #+end_src

***** >< paredit-everywhere
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (require 'mini-paredit)

      (add-hook 'haskell-mode-hook            'mini-paredit-mode)
      (add-hook 'inferior-haskell-mode-hook   'mini-paredit-mode)

      (add-hook 'c-mode-hook                  'mini-paredit-mode)

      (add-hook 'coq-mode-hook                'mini-paredit-mode)

      (add-hook 'lua-mode-hook                'mini-paredit-mode)

      (add-hook 'sml-mode-hook                'mini-paredit-mode)
      #+end_src

***** >< experiment
      1. 从 simple.el 中可以学到很多
         file:/usr/local/share/emacs/24.3/lisp/simple.el.gz
         尤其是当找到一个函数是在这里定义的时候

      下面是三组有用的函数
      其中 what-cursor-position 是在 simple.el 中定义的
      #+begin_src emacs-lisp
      (looking-at "")
      (what-cursor-position)
      (insert (what-cursor-position))
      (setq kkk (what-cursor-position))
      (insert kkk)

      (following-char)
      (memq 67 '("C"))
      (char-to-string 67)

      (point)

      (message "kkk")
      #+end_src

*** scheme

***** load-path
      some scheme related files are under this dir
      for hack
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/scheme/")
      (add-to-list 'load-path "~/.emacs.d/scheme/cmuscheme-init-repl/")
      #+end_src

***** scheme-mode
      file used by cmuscheme to init a *scheme* buffer
      for a prescribed interpreter's repl

      one can change the directory to save these files
      by editing the function ``scheme-start-file'' in cmuscheme.el
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-ikarus.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-csi.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-guile.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-petite.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-racket.scm
      file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-mit-scheme.scm
      #+begin_src emacs-lisp :tangle ~/.emacs
      (require 'cmuscheme)

      (setq scheme-program-name "racket")

      (defun switch-to-buffer-*scheme* ()
        (interactive)
        (switch-to-scheme 1) ;; (switch-to-buffer "*scheme*")
        (local-set-key (kbd "C-s C-d") 'previous-buffer))
      (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*scheme*)

      (defun split-window-with-named-buffer (buffer-name-string)
        (interactive)
        (cond
         ((= 1 (count-windows))
              (progn
                ;; 下面这两个的组合总能行为正确
                (split-window-vertically (floor (* 0.68 (window-height))))
                (other-window 1)
                (switch-to-buffer buffer-name-string)
                (other-window -1)))

         ;; 只允许出现一个 scheme 窗口
         ;; 因此当发现有别的窗口的时候就在那个窗口中打开所需要的 buffer
         ((not (cl-find buffer-name-string
                    (mapcar (lambda (w) (buffer-name (window-buffer w)))
                            (window-list))
                    :test 'equal))
              (progn
                (other-window 1)
                (switch-to-buffer buffer-name-string)
                (other-window -1)))))

      (defun scheme-send-last-sexp-split-window ()
        (interactive)
        (scheme-send-last-sexp)
        (split-window-with-named-buffer "*scheme*"))

      (defun scheme-send-definition-split-window ()
        (interactive)
        (scheme-send-definition)
        (split-window-with-named-buffer "*scheme*"))

      (add-hook
       'inferior-scheme-mode-hook
       (lambda ()
         (local-set-key (kbd "C-c C-c")
                        (lambda ()
                          (interactive)
                          (kill-buffer)
                          (run-scheme scheme-program-name)))))

      (defun scheme-easy-to-eval ()
        (interactive)
        (if (>= (+ 1 (point))
                (point-max))
            (message "C-<tab> : last sexp is evaled")
            (let ()
              (forward-sexp)
              (scheme-send-last-sexp-split-window))))

      (add-hook
       'scheme-mode-hook
       (lambda ()
         (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
         (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
         (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)
         (local-set-key (kbd "|")
                        (lambda ()
                          (interactive)
                          (insert "||")))
         (local-set-key (kbd "{")
                        (lambda ()
                          (interactive)
                          (insert "{}")))
         (local-set-key (kbd "M-|")
                        (lambda ()
                          (interactive)
                          (insert "|")
                          (forward-sexp 1)
                          (insert "|")
                          (left-char)
                          (backward-sexp 1)
                          (left-char)))))
      #+end_src

***** scheme-here
      #+begin_src emacs-lisp :tangle ~/.emacs
      (require 'scheme-here)
      (add-hook 'inferior-scheme-mode-hook
                (lambda ()
                      (define-key scheme-mode-map (kbd "C-s C-a") 'scheme-here-send-sexp)))
      #+end_src

***** parenface (not using)
      i actually like these parentheses
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (require 'parenface)
      (set-face-foreground 'paren-face "DimGray")
      #+end_src

***** pretty-lambdas-for-lisp (not using)
      * not using
        for no good font
      #+begin_src emacs-lisp
      (defun pretty-lambdas-for-lisp ()
        (interactive)
        (font-lock-add-keywords
         nil `(("(\\(lambda\\>\\)"
                (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                              993
                                              ;; 923 : Λ
                                              ;; 955 : λ
                                              ;; 411 : ƛ
                                              ;; 654 : ʎ
                                              ;; 992 : Ϡ
                                              ;; 993 : ϡ
                                              )
                              nil))))))


      (add-hook 'scheme-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'inferior-scheme-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'emacs-lisp-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'ielm-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'lisp-mode-hook
                'pretty-lambdas-for-lisp)
      (add-hook 'lisp-interaction-mode-hook
                'pretty-lambdas-for-lisp)

      (add-hook 'org-mode-hook
                'pretty-lambdas-for-lisp)
      #+end_src

***** scheme-add-keywords
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; scheme-mode 中原本的实现不是如此
      (defun scheme-add-keywords (face-name keyword-rules)
        (let* ((keyword-list (mapcar #'(lambda (x)
                                         (symbol-name (cdr x)))
                                     keyword-rules))
               (keyword-regexp (concat "(\\("
                                       (regexp-opt keyword-list)
                                       "\\)[ \n]")))
          (font-lock-add-keywords 'scheme-mode
                                  `((,keyword-regexp 1 ',face-name))))
        (mapc #'(lambda (x)
                  (put (cdr x)
                       'scheme-indent-function
                       (car x)))
              keyword-rules))

      ;; 前面的数字被认为是参数项的个数
      ;; 参数项完全换行时强缩进 其他项弱缩进
      ;; 非语法关键词 所有项在完全换行时都不缩进
      (scheme-add-keywords
       'font-lock-keyword-face
       '(
         ;; the little prover
         (2 . defun)
         (2 . dethm)
         (1 . J-Bob/step)
         (1 . J-Bob/prove)
         (1 . J-Bob/define)

         ;; 下面 scheme 中需要高亮的词
         (0 . set!)
         (0 . set-car!)
         (0 . set-cdr!)
         (0 . vector-set!)
         (1 . quote)
         (1 . quasiquote)
         (1 . unquote)
         (1 . if)
         (1 . apply)
         (1 . letrec*)
         (1 . while)
         ;; 来自扩展的
         (1 . letcc)
         (1 . pmatch)
         (2 . pmatch-who)
         (0 . guard)
         (0 . add-to-list!)
         (0 . add-to-list-end!)
         (0 . append!)
         (0 . insert-a-val-to-a-field-of-a-wlist!)
         (0 . to-a-field-of-a-wlist--let-us-insert-a-val!)

         ;; 来自 ikarus
         (1 . make-parameter)
         (1 . parameterize)

         ;; 下面 scheme 中我还没用到以后可能需要高亮的词
         (1 . when)
         (1 . unless)
         (2 . let1)
         (1 . error)

         ;; 下面是我的解释器中需要高亮的词
         (1 . λ)
         (0 . begin*)
         (1 . def)
         (1 . doc)
         (2 . rewrite-doc)

         ;; 下面是 /home/xyh/scheme-toys/~.scm 中需要高亮的词
         (1 . ~?)
         (1 . ~)
         (0 . ~+~)
         (2 . ~map)
         (1 . ~fun+)
         (1 . copy~)
         (1 . <~!)
         (1 . <~)
         (1 . take~)

         ;; 下面是 mk 中需要高亮的词
         ;; core:
         ;; Logical operators:
         (2 . ==)
         (1 . fresh)
         (0 . conde)
         ;; Interface operators:
         (2 . run)
         (1 . run*)

         ;; 下面是 mk 的元代码中需要高亮的词
         ;; [(lambdag@ (p) e) (lambda (p) e)]
         ;; (1 . lambdag@)
         ;; [(lambdaf@ () e) (lambda () e)]
         ;; (1 . lambdaf@)

         (1 . λᴳ)
         (1 . λ~)

         ;;
         (0 . set-pointer!)
         (1 . define-pointer)
         ;; 下面是 vvv-mimic-ccc.scm 中需要高亮的词
         (0 . vons)
         (0 . vnr)
         (0 . v0r)
         (0 . v1r)
         (0 . v2r)
         (0 . v3r)
         (0 . v4r)
         (0 . v5r)
         (0 . v6r)
         (0 . v7r)
         (0 . v8r)
         (0 . v9r)
         (0 . set-vnr!)
         (0 . set-v0r!)
         (0 . set-v1r!)
         (0 . set-v2r!)
         (0 . set-v3r!)
         (0 . set-v4r!)
         (0 . set-v5r!)
         (0 . set-v6r!)
         (0 . set-v7r!)
         (0 . set-v8r!)
         (0 . set-v9r!)

         (0 . vonz)
         (0 . vnz)
         (0 . v0z)
         (0 . v1z)
         (0 . v2z)
         (0 . v3z)
         (0 . v4z)
         (0 . v5z)
         (0 . v6z)
         (0 . v7z)
         (0 . v8z)
         (0 . v9z)
         (0 . set-vnz!)
         (0 . set-v0z!)
         (0 . set-v1z!)
         (0 . set-v2z!)
         (0 . set-v3z!)
         (0 . set-v4z!)
         (0 . set-v5z!)
         (0 . set-v6z!)
         (0 . set-v7z!)
         (0 . set-v8z!)
         (0 . set-v9z!)

         (0 . conz)
         (0 . caz)
         (0 . cdz)
         (0 . set-caz!)
         (0 . set-cdz!)

         ;; 其它可能临时用到的高亮
         (0 . *λ)
         (0 . *l)

         (1 . define-primitive)

         ;; racket
         (1 . require)
         (1 . provide)
         (1 . module)
         (1 . module+)
         (1 . module*)

         (1 . class)
         (2 . class*)
         (1 . interface)
         (2 . mixin)
         (1 . define/public)
         (1 . define/override)
         (1 . new)
         (1 . send)
         (2 . :)
         (1 . ::)
         (1 . super)

         (1 . test-case)
         (0 . check-expect)
         (2 . check-error)

         (1 . match)
         (1 . match*)
         (0 . match-lambda**)
         (0 . fun)
         (1 . just-fun)
         (1 . define/match)

         (2 . syntax-case)
         (1 . syntax-parse)

         (0 . orz)
         (0 . note)

         (2 . oer)

         (1 . create)
         (1 . apply-creator-list)
         (1 . process)
         (1 . apply-processor-list)
         (1 . settle)
         (1 . apply-settler-list)

         (1 . with-handlers)
         (1 . raise)

         (0 . try)
         (1 . back-to-last-try)

         ;; cicada
         (1 . create-primitive-function)

         (1 . define-function)
         (1 . define-variable)
         (1 . define-primitive-function)

         (0 . here)
         (0 . !)
         (0 . @)
         (0 . !td)
         (0 . @t)
         (0 . @d)

         (0 . succedent:)
         (0 . antecedent:)

         (0 . note:)

         (1 . vector-map)
         (1 . map)

         (1 . match-let)
         (1 . match-let*)

         ))
      #+end_src

*** racket
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/racket-mode/")

    ;; (add-to-list 'load-path "~/.emacs.d/s.el/")
    ;; (require 's)
    ;; (add-to-list 'load-path "~/.emacs.d/racket-mode--greghendershott/")

    (require 'racket-mode)

    (setq auto-mode-alist (cons `("\\.rkt$" . scheme-mode) auto-mode-alist))

    ;; (defun switch-to-buffer-*racket* ()
    ;;   (interactive)
    ;;   (let ()
    ;;     (switch-to-buffer racket--repl-buffer-name t)
    ;;     (with-current-buffer racket--repl-buffer-name
    ;;       (goto-char (point-max))))
    ;;   (local-set-key (kbd "C-s C-d") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*racket*)
    #+end_src

*** dylan
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/dylan-mode/")
    (require 'dime)
    #+end_src


*** common lisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (setq inferior-lisp-program "/usr/local/bin/clisp")
    ;; (setq inferior-lisp-program "/usr/local/bin/sbcl")
    ;; (setq inferior-lisp-program "/usr/local/bin/sbcl --dynamic-space-size 1000")
    ;; (setq inferior-lisp-program "/usr/local/bin/mkcl")
    ;; (setq inferior-lisp-program "~/lang/lisp/ccl/lx86cl64")
    ;; (setq inferior-lisp-program "sbcl")
    ;; (setq inferior-lisp-program "ecl")
    (setq inferior-lisp-program "ccl")

    (add-hook 'lisp-mode-hook
              (lambda ()
                (local-set-key (kbd "M-q") 'query-replace)
                ))
    #+end_src

*** lisp-add-keywords
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun lisp-add-keywords (face-name keyword-rules)
      (let* ((keyword-list
              (mapcar #'(lambda (x)
                          (symbol-name (cdr x)))
                      keyword-rules))
             (keyword-regexp
              (concat "(\\("
                      (regexp-opt keyword-list)
                      "\\)[ \n]")))
        (font-lock-add-keywords
         'lisp-mode
         `((,keyword-regexp 1 ',face-name))))
      (mapc #'(lambda (x)
                (put (cdr x)
                     'lisp-indent-function
                     (car x)))
            keyword-rules))

    ;; note that
    ;; a macro will be turned into keyword by slime
    ;; slime will override the following definition
    ;; but slime does not help some of the colors
    (lisp-add-keywords
     'font-lock-keyword-face
     '(
       (0 . quote)
       (0 . function)
       (0 . values)

       (1 . defin)
       (1 . with)

       (1 . apply)
       (1 . funcall)

       (2 . deftest)
       (3 . ensure)

       (1 . cat)
       (1 . orz)

       (1 . add1!)
       (1 . sub1!)
       (2 . set!)
       (2 . set-car!)
       (2 . set-cdr!)
       (2 . set-end-car!)
       (2 . set-end-cdr!)

       (1 . multiple-value-let)
       ;; (1 . let-fun)
       (1 . help)
       ))
    #+end_src

*** slime
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; setup load-path and autoloads
    (add-to-list 'load-path "~/.emacs.d/slime/")
    (setq slime-contribs '(slime-fancy))
    (require 'slime-autoloads)


    (setf common-lisp-hyperspec-root "/home/xyh/lang/lisp/hyperspec/"
          slime-complete-symbol-function 'slime-fuzzy-complete-symbol
          lisp-indent-function 'common-lisp-indent-function)


    (add-hook 'slime-mode-hook
              (lambda ()
                (local-set-key (kbd "M-l")  'slime-documentation-lookup)
                (local-set-key (kbd "C-M-h")  'slime-fuzzy-complete-symbol)
                (local-set-key (kbd "C-M-.") 'next-buffer)
                (local-set-key (kbd "C-M-,") 'previous-buffer)
                ))

    ;; (require 'slime)


    ;; the following are not working
    ;; so I just edit the slime.el

    (add-hook 'slime-repl-mode-hook
              (lambda ()
                (local-set-key (kbd "C-M-.") 'next-buffer)
                (local-set-key (kbd "C-M-,") 'previous-buffer)
                ))




    ;; (defun switch-to-buffer-*slime* ()
    ;;   (interactive)
    ;;   (slime-switch-to-output-buffer)
    ;;   (local-set-key (kbd "C-s C-x") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-x") 'switch-to-buffer-*slime*)




    ;; (add-hook
    ;;  'slime-mode-hook
    ;;  (lambda ()
    ;;    (local-set-key (kbd "C-x C-e") 'slime-send-last-sexp-split-window)
    ;;    ))
    #+end_src


*** elisp
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-elisp-mode-keywords()
      (font-lock-add-keywords
       nil
       '(("\\<\\(setq\\)" . 'font-lock-keyword-face))))
    (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode-keywords)
    #+end_src

*** emacs-lisp-add-keywords
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun emacs-lisp-add-keywords (face-name keyword-rules)
      (let* ((keyword-list
              (mapcar #'(lambda (x)
                          (symbol-name (cdr x)))
                      keyword-rules))
             (keyword-regexp
              (concat "(\\("
                      (regexp-opt keyword-list)
                      "\\)[ \n]")))
        (font-lock-add-keywords
         'emacs-lisp-mode
         `((,keyword-regexp 1 ',face-name))))
      (mapc #'(lambda (x)
                (put (cdr x)
                     'emacs-lisp-indent-function
                     (car x)))
            keyword-rules))

    (emacs-lisp-add-keywords
     'font-lock-keyword-face
     '(
       (1 . add-hook)
       ))
    #+end_src

*** general seting
    Non-nil means print recursive structures using #N= and #N# syntax.
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq print-circle t)
    #+end_src

*** ielm = run-elisp                  :no:
    * 不知道哪个傻逼起的 ielm 这个名字
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun run-elisp ()
      (interactive)
      (ielm))

    (defun switch-to-buffer-*elisp-repl* ()
      (interactive)
      (if (member-string? "*elisp-repl*" (mapcar 'buffer-name (buffer-list)))
              (switch-to-buffer "*elisp-repl*")
            (progn
              (ielm)
              (rename-buffer "*elisp-repl*")))
      (local-set-key (kbd "C-s e") 'previous-buffer))
    (global-set-key (kbd "C-s e") 'switch-to-buffer-*elisp-repl*)
    #+end_src


*** shen
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/shen-mode/")
    (require 'shen-mode)
    (require 'inf-shen) ; <- for interaction with an external shen process

    ;; (defun switch-to-buffer-*inferior-shen* ()
    ;;   (interactive)
    ;;   (if (member-string? "*inferior-shen*" (mapcar 'buffer-name (buffer-list)))
    ;;           (switch-to-buffer "*inferior-shen*")
    ;;         (switch-to-shen t))
    ;;   (local-set-key (kbd "C-s C-w") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-w") 'switch-to-buffer-*inferior-shen*)
    #+end_src


*** egison-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/egison-mode/")
    (require 'egison-mode)
    (autoload 'egison-mode "egison-mode" "Major mode for editing Egison code." t)
    (setq auto-mode-alist (cons `("\\.egi$" . egison-mode) auto-mode-alist))
    #+end_src

*** js

***** js-mode

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-hook
       'js-mode-hook
       (lambda ()
         (setq comment-style 'extra)
         (setq js-indent-level 2)
         (setq js2-basic-offset 2)))
      #+end_src

***** js2-mode

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/js2-mode/")
      (require 'js2-mode)

      (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
      (add-hook 'js-mode-hook 'js2-minor-mode)
      (add-to-list 'interpreter-mode-alist '("node" . js2-mode))

      (add-hook 'js-mode-hook
                (lambda ()
                  (setq comment-style 'extra)
                  (setq js-indent-level 2)
                  (setq js2-basic-offset 2)))

      (add-hook 'js2-mode-hook
                (lambda ()
                  (setq comment-style 'extra)
                  (setq js-indent-level 2)
                  (setq js2-basic-offset 2)))
      #+end_src

***** js3-mode                        :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/js3-mode/")
      (autoload 'js3-mode "js3" nil t)
      (add-to-list 'auto-mode-alist '("\\.js$" . js3-mode))
      #+end_src

***** simple-httpd                    :no:
      #+begin_src emacs-lisp :tangle no
      ;; (add-to-list 'load-path "~/.emacs.d/emacs-web-server/")
      ;; (require 'simple-httpd)
      #+end_src

***** skewer-mode                     :no:
      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/skewer-mode/")
      (require 'skewer-mode)
      (add-hook 'js-mode-hook 'skewer-mode)
      (add-hook 'js2-mode-hook 'skewer-mode)
      (add-hook 'css-mode-hook 'skewer-css-mode)
      (add-hook 'html-mode-hook 'skewer-html-mode)
      #+end_src

***** ac-js2                          :no:
      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/popup-el/")
      (require 'popup)

      (add-to-list 'load-path "~/.emacs.d/auto-complete/")
      (require 'auto-complete)
      (require 'auto-complete-config)
      (ac-config-default)

      (add-to-list 'load-path "~/.emacs.d/ac-js2/")
      (add-hook 'js2-mode-hook 'ac-js2-mode)
      (require 'ac-js2)

      ;; Copy the snippet below
      ;; if you want to evaluate your Javascript code for candidates.
      ;; Not setting this value will still provide you with basic completion.

      (setq ac-js2-evaluate-calls t)

      ;; Add any external Javascript files to the variable below.
      ;; Make sure you have initialised ac-js2-evaluate-calls to t
      ;; if you add any libraries.

      ;; (setq ac-js2-external-libraries '("full/path/to/a-library.js"))
      #+end_src

***** coffee-mode
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/coffee-mode/")
      (require 'coffee-mode)
      (add-to-list 'auto-mode-alist '("\\.coffee\\'" . coffee-mode))
      (custom-set-variables '(coffee-tab-width 2))

      (add-to-list 'load-path "~/.emacs.d/literate-coffee-mode/")
      (require 'literate-coffee-mode)
      #+end_src

*** sibilant-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/sibilant-mode/")
    (require 'sibilant-mode)
    #+end_src



*** sawfish (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/sawfish/")
    (autoload 'sawfish-mode "sawfish" "sawfish-mode" t)
    (setq auto-mode-alist (cons '("\\.sawfishrc$"  . sawfish-mode) auto-mode-alist)
              auto-mode-alist (cons '("\\.jl$"         . sawfish-mode) auto-mode-alist)
              auto-mode-alist (cons '("\\.sawfish/rc$" . sawfish-mode) auto-mode-alist))
    #+end_src



*** markdown
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/markdown-mode/")
    (autoload 'markdown-mode "markdown-mode"
           "Major mode for editing Markdown files" t)
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

    (add-hook
     'markdown-mode-hook
     (lambda ()
       (local-set-key (kbd "M-p") 'backward-paragraph)
       (local-set-key (kbd "M-n") 'forward-paragraph)
       ;; (turn-off-indent)
       ))
    #+end_src

*** haml

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/haml-mode/")
    (require 'haml-mode)
    #+end_src

*** [not using] DOS
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/DOS/")
    (require 'ntcmd)
    (add-to-list 'auto-mode-alist '("\\.cmd$" . ntcmd-mode))
    (add-to-list 'auto-mode-alist '("\\.bas$" . ntcmd-mode))
    (add-to-list 'auto-mode-alist '("\\.bat$" . ntcmd-mode))

    ;; (require 'dos)
    ;; (require 'batch-mode)
    ;; (require 'cmd-mode)
    #+end_src


*** lfe
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/lfe/")
    (require 'lfe-mode)
    (require 'inferior-lfe)
    (require 'lfe-start)
    #+end_src



*** cicada-nymph
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cicada-nymph-mode/")
    (require 'cicada-nymph-mode)
    (require 'inferior-cicada-nymph-mode)

    ;; (define-prefix-command 'C-s-map)
    ;; (global-set-key (kbd "C-s") 'C-s-map)

    ;; (defun switch-to-buffer-*cicada-nymph* ()
    ;;   (interactive)
    ;;   (if (member-string? "*cicada-nymph*" (mapcar 'buffer-name (buffer-list)))
    ;;       (let ()
    ;;         (switch-to-buffer "*cicada-nymph*")
    ;;         (local-set-key (kbd "C-s C-c") 'previous-buffer))
    ;;       (run-cicada-nymph
    ;;        (read-string "* run cicada-nymph : "
    ;;                     cicada-nymph-program-name))))
    ;; (global-set-key (kbd "C-s C-c") 'switch-to-buffer-*cicada-nymph*)

    (add-hook 'cicada-nymph-mode-hook
     (lambda ()
       (local-set-key (kbd "C-h") 'hippie-expand)
       (local-set-key (kbd "M-q") 'query-replace)
       (local-set-key (kbd "C-c C-e")
                      'cicada-nymph-send-region-and-split-window)
       (local-set-key (kbd "C-<tab>")
                      'cicada-nymph-send-line-and-split-window-and-goto-next-line)))
    #+end_src

*** cicada-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cicada-language-mode/")
    (require 'cicada-language-mode)
    (require 'inferior-cicada-language-mode)

    ;; (define-prefix-command 'C-s-map)
    ;; (global-set-key (kbd "C-s") 'C-s-map)

    (defun switch-to-buffer-*cicada-language* ()
      (interactive)
      (if (member-string? "*cicada-language*" (mapcar 'buffer-name (buffer-list)))
          (let ()
            (switch-to-buffer "*cicada-language*")
            (local-set-key (kbd "C-s C-c") 'previous-buffer))
          (run-cicada-language
           (read-string "* run cicada-language : "
                        cicada-language-program-name))))
    (global-set-key (kbd "C-s C-c") 'switch-to-buffer-*cicada-language*)

    (add-hook 'cicada-language-mode-hook
     (lambda ()
       (local-set-key (kbd "C-h") 'hippie-expand)
       (local-set-key (kbd "M-q") 'query-replace)
       (local-set-key (kbd "C-c C-e")
                      'cicada-language-send-region-and-split-window)
       (local-set-key (kbd "C-<tab>")
                      'cicada-language-send-line-and-split-window-and-goto-next-line)))
    #+end_src

*** return-stack
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/return-stack-mode/")
    (require 'return-stack-mode)
    #+end_src


*** rust
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rust-mode/")
    (autoload 'rust-mode "rust-mode" nil t)
    (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
    #+end_src

*** go
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/go-mode/")
    (require 'go-mode)
    #+end_src

*** retro
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/retro/")

    (autoload 'retro-mode "retro-mode.el" "retro mode" t)
    (add-to-list 'auto-mode-alist '("\\.rx\\'" . retro-mode))
    #+end_src



*** forth
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/forth-mode/")
    ;; (require 'forth-mode)

    (defun switch-to-buffer-*forth* ()
      (interactive)
      (if (member-string? "*forth*" (mapcar 'buffer-name (buffer-list)))
          (switch-to-buffer "*forth*")
          (let ((forth-name (read-from-minibuffer "run which forth? : ")))
            (run-forth forth-name)))
      (local-set-key (kbd "C-s C-f") 'previous-buffer))
    (global-set-key (kbd "C-s C-f") 'switch-to-buffer-*forth*)

    (add-to-list 'auto-mode-alist '("\\.frt$" . forth-mode))
    #+end_src

*** gforth
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/gforth.el/")

    (require 'forth-mode)

    (autoload 'forth-mode "gforth.el")
    (setq auto-mode-alist (cons '("\\.f\\'" . forth-mode)
                                    auto-mode-alist))

    (defun forth-send-paragraph-split-window ()
      (interactive)
      (split-window-with-named-buffer "*forth*")
      (forth-send-paragraph))

    ;; 利用 forth-send-region 来实现 forth-send-line
    ;; 因为不想使用 forth-send-paragraph
    (defun forth-send-line ()
      (interactive)
      (move-beginning-of-line nil)
      (cua-set-mark)
      (move-end-of-line nil)
      (forth-send-region (region-beginning) (region-end))
      (cua-set-mark))

    (defun forth-send-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*forth*")
      (forth-send-line))

    (defun forth-send-line-and-goto-next-line ()
      (interactive)
      (forth-send-line)
      (next-line))


    (add-hook
     'forth-mode-hook
     (function (lambda ()

                     (setq forth-indent-level 4)
                     (setq forth-minor-indent-level 2)
                     (setq forth-hilight-level 3)

                     (local-set-key (kbd "C-h") 'hippie-expand)

                     (local-set-key (kbd "C-x C-e") 'forth-send-line-split-window)
                     (local-set-key (kbd "C-<tab>") 'forth-send-line-and-goto-next-line)
                     (local-set-key (kbd "<return>") 'newline)

                     ;; (turn-off-indent)
                     (local-set-key (kbd "M-q") 'query-replace)

                     ;; (setq comment-start "("!;\ )
                     ;; (setq comment-end " !;\"!;\ )
                     ;; (setq comment-padding" "!;\ )

                     )))
    #+end_src



*** tcl
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq tcl-application "tclsh")


    (defun tcl-eval-defun-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-eval-defun))

    (defun tcl-send-line ()
      (interactive)
      (move-beginning-of-line nil)
      (cua-set-mark)
      (move-end-of-line nil)
      (tcl-eval-region (region-beginning) (region-end))
      (cua-set-mark))

    (defun tcl-send-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-send-line))

    (defun tcl-send-line-and-goto-next-line ()
      (interactive)
      (tcl-send-line)
      (next-line))

    (defun tcl-send-line-and-goto-next-line-split-window ()
      (interactive)
      (split-window-with-named-buffer "*inferior-tcl*")
      (tcl-send-line)
      (next-line))

    (add-hook
     'tcl-mode-hook
     (function (lambda ()
       ;; note that how a function definition in tcl is viewed as a line
       (local-set-key (kbd "C-<tab>") 'tcl-send-line-and-goto-next-line-split-window)
       (local-set-key (kbd "C-x C-e") 'tcl-send-line-split-window)
       (local-set-key (kbd "C-c C-e") 'tcl-eval-defun-split-window)
       )))
    #+end_src



*** sml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/sml/")
    ;; (defun switch-to-buffer-about-sml ()
    ;;   (interactive)
    ;;   (cond ((member-string? "*hamlet*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*hamlet*"))
    ;;         ((member-string? "*mosml*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*mosml*"))
    ;;         ((member-string? "*poly*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*poly*"))
    ;;         ((member-string? "*sml*" (mapcar 'buffer-name (buffer-list)))
    ;;          (switch-to-buffer "*sml*"))
    ;;         (else
    ;;          ;; (run-sml "sml" "")
    ;;          (run-sml "hamlet" "")
    ;;          ))
    ;;   ;; 然后总能通过向左一个 buffer 回到之前的 buffer
    ;;   ;; 这是笨的解决方法，某些情况下一定会出问题
    ;;   (local-set-key (kbd "C-s C-q") 'previous-buffer))
    ;; (global-set-key (kbd "C-s C-q") 'switch-to-buffer-about-sml)
    #+end_src

***** 版本 1
      sml-mode-6.4.el
      #+begin_src emacs-lisp :tangle ~/.emacs
      (autoload 'sml-mode "sml-mode" "Major mode for editing SML." t)
      (autoload 'run-sml "sml-proc" "Run an inferior SML process." t)
      (add-to-list 'auto-mode-alist '("\\.\\(sml\\|sig\\)\\'" . sml-mode))

      (setq sml-program-name "sml")
      ;; (setq sml-program-name "hamlet")

      (require 'sml-mode)

      (add-hook
       'sml-mode-hook
       (lambda ()
         (define-key sml-mode-map (kbd "C-x C-e") 'sml-send-function)
         ;; (local-set-key (kbd "C-x C-e") 'sml-send-function)
         )
       'turn-off-indent)
      #+end_src

***** 版本 2
      sml-mode-color.el
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      ;; *** set this path to the sml executable (sml.bat on Windows)
      ;; (setq sml-prog-name "/usr/bin/hamlet")

      (autoload 'sml-mode "sml-mode-color" () t)
      (add-to-list 'auto-mode-alist '("\\.sml$" . sml-mode))
      (add-to-list 'auto-mode-alist '("\\.sig$" . sml-mode))

      (add-hook 'sml-mode-hook
         (lambda ()
               (setq indent-tabs-mode nil)
               (setq sml-indent-args 2)
               (local-set-key (kbd "M-SPC") 'just-one-space)))

      (add-hook 'sml-shell-hook
         (lambda ()
               (send-string sml-process-name
                 (concat "use \""
                         sml-mode-dir
                         "/inferior-setup.sml\";\n"))))
      #+end_src

***** 版本 3
      sml-mode-kkk.el
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      (autoload 'sml-mode "sml-mode" "Major mode for editing ML programs." t)

      (setq auto-mode-alist
                (cons '(("\\.sml$" . sml-mode)
                        ("\\.ML$"  . sml-mode)) auto-mode-alist))

      (setq sml-mode-hook
                '(lambda() "ML mode hacks"
               (setq sml-indent-level 2         ; conserve on horiz. space
                         indent-tabs-mode nil)))    ; whatever

      ;; (setq sml-load-hook
      ;;       '(lambda() "Highlights." (require 'sml-hilite)))

      ;; (if window-system
      ;;     (setq hilit-background-mode   t ; monochrome (alt: 'dark or 'light)
      ;;           hilit-inhibit-hooks     nil
      ;;           hilit-inhibit-rebinding nil
      ;;           hilit-quietly           t))

      ;; Alternatively, you can (require 'sml-font) which uses the font-lock
      ;; package instead.
      #+end_src

*** ocaml-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/ocaml-mode/")

    (add-to-list 'auto-mode-alist '("\\.ml[iylp]?$" . caml-mode))
    (autoload 'caml-mode "caml" "Major mode for editing OCaml code." t)
    (autoload 'run-caml "inf-caml" "Run an inferior OCaml process." t)
    (autoload 'camldebug "camldebug" "Run ocamldebug on program." t)
    (add-to-list 'interpreter-mode-alist '("ocamlrun" . caml-mode))
    (add-to-list 'interpreter-mode-alist '("ocaml" . caml-mode))


    ;; (if window-system (require 'caml-hilit))
    (if window-system (require 'caml-font))

    (defun switch-to-buffer-*inferior-caml* ()
       (interactive)
      (if (member-string? "*inferior-caml*" (mapcar 'buffer-name (buffer-list)))
           (switch-to-buffer "*inferior-caml*")
         (run-caml "ocaml"))
       (local-set-key (kbd "C-s C-q") 'previous-buffer))
     (global-set-key (kbd "C-s C-q") 'switch-to-buffer-*inferior-caml*)

    (defun caml-eval-phrase-split-window ()
      (interactive)
      (caml-eval-phrase 1)
      (split-window-with-named-buffer "*inferior-caml*"))

    (add-hook
     'caml-mode-hook
     (lambda ()
       (local-set-key (kbd "C-x C-e") 'caml-eval-phrase-split-window)
       (local-set-key (kbd "C-<tab>") 'caml-eval-phrase-split-window)
       (local-set-key (kbd "<return>") 'electric-newline-and-maybe-indent)
       (turn-off-indent)
       (setq comment-style 'multi-line)))
    #+end_src

*** tuareg-mode for ocaml (not using)
    这个 mode 运行很慢
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/tuareg/")
    (require 'tuareg)
    ;; (require 'caml)
    #+end_src


*** asm
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; may set this variable in `asm-mode-set-comment-hook',
    ;; which is called near the beginning of mode initialization.
    (add-hook 'asm-mode-set-comment-hook
              (lambda ()
                    (setq asm-comment-char ?\#)
                    ))

    (defun asm-indent-line-by-line ()
      (interactive)
      (asm-indent-line)
      (next-line))

    (add-hook 'asm-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-<tab>") 'asm-indent-line-by-line)
                    ))
    #+end_src

*** gas (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/gas-mode/")

    (require 'gas-mode)
    (add-to-list 'auto-mode-alist '("\\.S\\'" . gas-mode))
    #+end_src

*** fasm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/fasm-mode/")
    (require 'fasm-mode)
    (add-to-list 'auto-mode-alist '("\\.fasm$" . fasm-mode))
    (add-to-list 'auto-mode-alist '("\\.inc$"  . fasm-mode))
    (add-to-list 'auto-mode-alist '("\\.s$"    . fasm-mode))

    (defun fasm-indent-line-and-next-line ()
      (interactive)
      (fasm-indent-line)
      (next-line))

    (add-hook 'fasm-mode-hook
              (lambda ()
                    ;; (setq tab-width 13)
                    ;; (setq indent-tabs-mode t)
                    ;; (local-set-key (kbd "<tab>") 'fasm-indent-line)
                    ;; (local-set-key (kbd "C-<tab>") 'fasm-indent-line-and-next-line)
                    ;; (turn-off-indent)
                    ))
    #+end_src

*** nasm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/nasm/")
    (autoload 'nasm-mode "~/.emacs.d/nasm/nasm-mode.el" "" t)

    (add-to-list 'auto-mode-alist '("\\.asm\\'" . nasm-mode))
    (add-to-list 'auto-mode-alist '("\\.nasm\\'" . nasm-mode))

    ;; To set your own indentation level to LEVEL:
    ;; (add-hook 'nasm-mode-hook
    ;;           (lambda () (setq-default nasm-basic-offset LEVEL)))
    (add-hook 'nasm-mode-hook
              (lambda ()
                    (setq-default nasm-basic-offset 13)
                    (turn-off-indent)
                    ))
    #+end_src


*** haskell

***** lode-path and init
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/haskell-mode/")
      (require 'haskell-mode-autoloads)
      (add-to-list 'Info-default-directory-list "~/.emacs.d/haskell-mode/")
      (setq haskell-program-name "ghci")
      #+end_src

***** indent
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
      (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
      ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
      #+end_src

***** switch and split
      #+begin_src emacs-lisp :tangle ~/.emacs
      (defun haskell-split-window ()
        (interactive)
        (cond
         ((= 1 (count-windows))
              (split-window-vertically (floor (* 0.68 (window-height))))
              (other-window 1)
              (switch-to-buffer "*haskell*")
              (other-window 1))
         ((not (cl-find "*haskell*"
                         (mapcar (lambda (w) (buffer-name (window-buffer w)))
                                 (window-list))
                         :test 'equal))
              (other-window 1)
              (switch-to-buffer "*haskell*")
              (other-window -1))))


      (defun switch-to-buffer-*haskell* ()
        (interactive)
        (progn
              (setq the-buffer-before-switch-to-buffer-*haskell*
                (current-buffer))
              (if (cl-find "*haskell*"
                       (mapcar (lambda (w) (buffer-name w))
                               (buffer-list))
                       :test 'equal)
              (switch-to-buffer "*haskell*")
                (progn (run-haskell) (delete-other-windows)))
              (local-set-key (kbd "C-s C-h") (lambda ()
                                               (interactive)
                                               (switch-to-buffer the-buffer-before-switch-to-buffer-*haskell*)))))
      (global-set-key (kbd "C-s C-h") 'switch-to-buffer-*haskell*)
      #+end_src

***** compile
      When invoked, ‘haskell-compile’ tries to guess how to compile the
      Haskell program your currently visited buffer belongs to, by searching
      for a ‘.cabal’ file in the current of enclosing parent folders.  If a
      ‘.cabal’ file was found, the command defined in the
      ‘haskell-compile-cabal-build-command’ option is used.  Moreover, when
      requesting to compile a ‘.cabal’-file is detected and a negative prefix
      argument (e.g.  ‘C-- C-c C-c’) was given, the alternative
      ‘haskell-compile-cabal-build-command-alt’ is invoked.  By default,
      ‘haskell-compile-cabal-build-command-alt’ contains a ‘cabal clean -s’
      command in order to force a full rebuild.
      #+begin_src emacs-lisp :tangle ~/.emacs
      (eval-after-load "haskell-mode"
        '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))
      (eval-after-load "haskell-cabal"
        '(define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
      #+end_src

*** note on pretty-lambdas-for-haskell
    (font-lock-add-keywords MODE KEYWORDS &optional HOW)
    KEYWORDS should be a list; see the variable: font-lock-keywords

    in font-lock-keywords each element in a user-level keywords list
    should have one of these forms:
    MATCHER
    (MATCHER . SUBEXP)
    (MATCHER . FACENAME)
    (MATCHER . HIGHLIGHT)
    (MATCHER HIGHLIGHT ...)
    (eval . FORM)

*** examples
    #+begin_src emacs-lisp
    (add-hook
     'c-mode-hook
     (lambda ()
       (font-lock-add-keywords
            nil
            '(("\\<\\(FIXME\\):" 1 'font-lock-warning-face prepend)
              ("\\<\\(and\\|or\\|not\\)\\>" . 'font-lock-keyword-face)
              ))))
    #+end_src

*** pretty-lambdas-for-haskell
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun pretty-lambdas-for-haskell ()
      (interactive)
      (font-lock-add-keywords
       nil
       ;; i do not fully understand
       ;; how the arg:KEYWORDS of font-lock-add-keywords works
       ;; which is very complicated
       ;; but the following returns what i want
       ;; which is so very cool !!!
       ;; (regexp-opt '("function\n" "function ") t)
       `(("\\\\.*?->" (0 (progn
                               ;; \x->f(g x) change to λx.f(g x)
                               (compose-region (match-beginning 0)
                                               (+ (match-beginning 0) 1)
                                               "λ")
                               (compose-region (- (match-end 0) 2)
                                               (match-end 0)
                                               ":")
                               nil))))))

    (add-hook 'haskell-mode-hook
              'pretty-lambdas-for-haskell)
    (add-hook 'inferior-haskell-mode-hook
              'pretty-lambdas-for-haskell)
    #+end_src

*** agda
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/agda-mode/")

    (autoload 'agda2-mode "agda2-mode"
      "Major mode for editing Agda files (version ≥ 2)." t)

    (add-to-list 'auto-mode-alist '("\\.l?agda\\'" . agda2-mode))
    (modify-coding-system-alist 'file "\\.l?agda\\'" 'utf-8)

    (require 'agda2)

    (add-hook 'agda2-mode-hook
              (lambda ()
                ;; (add-to-list 'agda2-include-dirs "/home/xyh/friend/xieyuheng/agda-prelude/src/")
                ))
    #+end_src

*** idris-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/prop-menu-el/")
    (require 'prop-menu)
    (add-to-list 'load-path "~/.emacs.d/idris-mode/")
    (require 'idris-mode)

    (add-hook
     'idris-mode-hook
     (lambda ()
       (local-set-key (kbd "C-M-n") 'idris-next-error)
       (local-set-key (kbd "C-M-p") 'idris-previous-error)
       (local-set-key (kbd "M-n") 'forward-paragraph)
       (local-set-key (kbd "M-p") 'backward-paragraph)
       (local-set-key (kbd "<return>") 'newline)

       (turn-off-indent)))

    (eval-after-load 'idris-mode
      '(progn
        (local-set-key (kbd "<tab>") 'turn-off-indent)))
    #+end_src

*** jonprl
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/yasnippet/")
    (require 'yasnippet)

    (add-to-list 'load-path "~/.emacs.d/jonprl-mode/")
    (require 'jonprl-mode)
    #+end_src


*** clojure

***** clojure

      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/clojure-mode/")
      (require 'clojure-mode)

      ;; (defun clojure-easy-to-eval ()
      ;;   (interactive)
      ;;   (if (>= (+ 1 (point))
      ;;           (point-max))
      ;;       (message "C-<tab> : last sexp is evaled")
      ;;       (let ()
      ;;         (forward-sexp)
      ;;         (cider-eval-last-sexp))))

      (add-hook
       'clojure-mode-hook
       (lambda ()
         (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
         (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
         (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)))

      (defun run-clojure ()
        (interactive)
        ;; (run-scheme "java -cp /home/xyh/lang/clojure/clojure-1.8.0/clojure-1.8.0.jar clojure.main")
        (run-scheme "lein repl"))
      #+end_src

***** queue                           :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/queue/")
      (require 'queue)
      #+end_src

***** cider                           :no:

      #+begin_src emacs-lisp :tangle no
      (add-to-list 'load-path "~/.emacs.d/spinner.el/")
      (require 'spinner)

      (add-to-list 'load-path "~/.emacs.d/seq.el/")
      (require 'seq)

      (add-to-list 'load-path "~/.emacs.d/cider/")
      (require 'cider)

      ;; cider-mode (complementing clojure-mode)
      ;; that allows you to evaluate code in your Clojure source files
      ;; and load it directly in the REPL
      ;; (eval-after-load "clojure-mode" '(cider-mode t))
      (add-hook 'clojure-mode-hook (lambda () (cider-mode t)))

      ;; Enable eldoc in Clojure buffers:
      (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)


      ;; You can control the TAB key behavior in the REPL via
      ;; cider-repl-tab-command
      ;; default is command cider-repl-indent-and-complete-symbol
      ;; to only indent:
      ;; (setq cider-repl-tab-command 'indent-for-tab-command)

      ;; Prevent the auto-display of the REPL buffer in a separate window
      ;; after connection is established:
      ;; (setq cider-repl-pop-to-buffer-on-connect nil)

      ;; Stop the error buffer from popping up
      ;; while working in buffers other than the REPL
      (setq cider-popup-stacktraces nil)

      ;; Enable error buffer popping also in the REPL:
      ;; (setq cider-repl-popup-stacktraces t)

      ;; To auto-select the error buffer when it's displayed:
      ;; (setq cider-auto-select-error-buffer t)

      ;; in The REPL buffer name
      ;; display the port on which the nREPL server is running
      ;; Buffer name will look like cider-repl project-name:port
      (setq nrepl-buffer-name-show-port t)

      ;; Make C-c C-z switch to the CIDER REPL buffer in the current window:
      ;; (setq cider-repl-display-in-current-window t)

      ;; Limit the number of items of each collection the printer will print to 100:
      ;; (setq cider-repl-print-length 100) ; the default is nil, no limit

      ;; Change the result prefix for REPL evaluation (by default there's no prefix):
      ;; (set cider-repl-result-prefix ";; => ")
      ;; And here's the result of that change:
      ;; user> (+ 1 2)
      ;; ;; => 3

      ;; Change the result prefix for interactive evaluation (by default it's =>):
      ;; (set cider-interactive-eval-result-prefix ";; => ")
      ;; To remove the prefix altogether just set it to an empty string("").

      ;; Normally code you input in the REPL is
      ;; font-locked with cider-repl-input-face (after you press RET)
      ;; and results are font-locked with cider-repl-output-face
      ;; If you want them to be font-locked as in clojure-mode use the following:
      ;; (setq cider-repl-use-clojure-font-lock t)

      ;; You can control the C-c C-z key behavior of switching to the REPL buffer
      ;; with the cider-switch-to-repl-command variable.
      ;; default command cider-switch-to-relevant-repl-buffer
      ;; cider-switch-to-current-repl-buffer offers a simpler alternative
      ;; where CIDER will not attempt to match the correct REPL buffer
      ;; based on underlying project directories:
      ;; (setq cider-switch-to-repl-command 'cider-switch-to-current-repl-buffer)


      ;; to make the REPL history wrap around when its end is reached:
      (setq cider-repl-wrap-history t)

      ;; To adjust the maximum number of items kept in the REPL history:
      (setq cider-repl-history-size 1000) ; the default is 500

      ;; To store the REPL history in a file:
      ;; (setq cider-repl-history-file "path/to/file")
      ;; Note that the history is written to the file when you kill the REPL buffer
      ;; (which includes invoking cider-quit) or you quit Emacs
      #+end_src

*** erlang
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/erlmode/")
    (require 'erlmode-start)
    #+end_src

*** elixir
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/elixir-mode/")
    (require 'elixir-mode)
    (require 'inferior-elixir-mode)
    #+end_src

*** prolog

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/prolog/prolog-mode/")
    (require 'prolog)

    (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
    (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
    (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)

    (setq prolog-system 'swi)
    (setq prolog-indent-width 2)

    (setq auto-mode-alist
          (append '(("\\.pl$" . prolog-mode)
                    ("\\.m$" . mercury-mode))
                  auto-mode-alist))
    (add-hook
     'prolog-mode-hook
     (lambda ()
       (local-set-key (kbd "M-q") 'query-replace)
       (local-set-key (kbd "C-c C-k")
                      (lambda ()
                        (interactive)
                        (run-prolog t)
                        (other-window -1)))))

    (add-hook
     'prolog-inferior-mode-hook
     (lambda ()
       (local-set-key (kbd "C-c C-k")
                      (lambda ()
                        (interactive)
                        (run-prolog t)))))
    #+end_src

*** free-pascal
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/freepascal-mode/")
    (require 'pascal)
    (setq pascal-indent-level       3
              pascal-case-indent        2
              pascal-auto-newline       nil
              pascal-tab-always-indent  t
              pascal-auto-endcomments   t
              pascal-auto-lineup        '(all)
              pascal-type-keywords      '("array" "file" "packed" "char"
                                      "integer" "real" "string" "record")
              pascal-start-keywords     '("begin" "end" "function" "procedure"
                                      "repeat" "until" "while" "read" "readln"
                                      "reset" "rewrite" "write" "writeln")
              pascal-separator-keywords '("downto" "else" "mod" "div" "then"))
    #+end_src

*** C
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq-default c-basic-offset 2)
    #+end_src

*** python
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq py-install-directory "~/.emacs.d/python-mode/")
    (add-to-list 'load-path py-install-directory)
    (require 'python-mode)


    (defun python-easy-to-eval ()
      (interactive)
      (if (>= (+ 1 (point))
              (point-max))
          (message "C-<tab> : last sexp is evaled")
          (let ()
            (py-forward-statement)
            (py-execute-statement))))

    (add-hook
     'python-mode-hook
     (lambda ()
       (local-set-key (kbd "C-<tab>") 'python-easy-to-eval)))

    (add-hook
     'py-python-shell-mode-hook
     (lambda ()
       (local-set-key (kbd "M-<tab>") 'window->)))
    #+end_src

*** python-el                         :no:
    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/python-el/")
    (require 'python)

    (defadvice run-python (around python-emacspy-directory activate)
      (let ((process-environment
             (cons (concat "PYTHONPATH=" "~/.emacs.d/python-el/")
                   process-environment)))
        ad-do-it))

    (defun python-easy-to-eval ()
      (interactive)
      (if (>= (+ 1 (point))
              (point-max))
          (message "C-<tab> : last sexp is evaled")
          (let ()
            (python-next-statement)
            (python-send-defun))))

    (add-hook
     'python-mode-hook
     (lambda ()
       (local-set-key (kbd "C-<tab>") 'python-easy-to-eval)))
    #+end_src

*** hy
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/hy-mode/")
    (require 'hy-mode)
    #+end_src


*** java
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-indent-setup ()
      (c-set-offset 'arglist-intro '+))

    (add-hook 'java-mode-hook 'my-indent-setup)
    #+end_src

*** vala
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/vala-mode/")
    (autoload 'vala-mode "vala-mode" "Major mode for editing Vala code." t)
    (add-to-list 'auto-mode-alist '("\\.vala$" . vala-mode))
    (add-to-list 'auto-mode-alist '("\\.vapi$" . vala-mode))
    (add-to-list 'file-coding-system-alist '("\\.vala$" . utf-8))
    (add-to-list 'file-coding-system-alist '("\\.vapi$" . utf-8))
    #+end_src


*** nimrod
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/nimrod-mode/")
    (require 'nimrod-mode)
    #+end_src


*** ProofGeneral
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral-4.2/ProofGeneral/generic/")
    ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral/generic/")
    (load-file "~/.emacs.d/ProofGeneral/generic/proof-site.elc")

    ;; (require 'proof-site) must be away after org-mode is turned on
    ;; i don't know way

    ;; (defun org/prepare-for-coq-code-block ()
    ;;   (interactive)
    ;;   (require 'proof-site))

    ;; (eval-after-load "coq-mode"
    ;;   '(define-key coq-mode-map (kbd ";") 'c-electric-semi&comma))
    #+end_src

*** coq
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/coq/")

    ;; rebinding keys for interactively proof
    (add-hook 'coq-mode-hook
              (lambda ()
                (set (make-local-variable
                      'comment-style)  'extra-line)

                (local-set-key (kbd "M-p") 'backward-paragraph)
                (local-set-key (kbd "M-n") 'forward-paragraph)
                ;; M-p used to runs the command pg-previous-matching-input-from-input
                (local-set-key (kbd "C-M-n") 'proof-assert-next-command-interactive)
                (local-set-key (kbd "C-M-p") 'proof-undo-last-successful-command)
                ))

    ;; pretty-lambdas-for-coq

    ;; i do not fully understand
    ;; how the arg:KEYWORDS of font-lock-add-keywords works
    ;; which is very complicated
    ;; but the following returns what i want
    ;; which is so very cool !!!

    ;; (defun pretty-display-for-coq ()
    ;;   (interactive)
    ;;   ;; (font-lock-add-keywords
    ;;   ;;  nil
    ;;   ;;  `(("fun " (0
    ;;   ;;             (progn
    ;;   ;;               (compose-region (match-beginning 0)
    ;;   ;;                               (+ (match-beginning 0) 3)
    ;;   ;;                               "λ")
    ;;   ;;               nil)))))
    ;;   ;; (font-lock-add-keywords
    ;;   ;;  nil
    ;;   ;;  `(("=> " (0
    ;;   ;;            (progn
    ;;   ;;              (compose-region (match-beginning 0)
    ;;   ;;                              (+ (match-beginning 0) 2)
    ;;   ;;                              ".")
    ;;   ;;              nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("fun .*? =>" (0
    ;;                    (progn
    ;;                          ;; \x->f(g x) change to λx.f(g x)
    ;;                          (compose-region (match-beginning 0)
    ;;                                          (+ (match-beginning 0) 3)
    ;;                                          "λ")
    ;;                          (compose-region (- (match-end 0) 2)
    ;;                                          (match-end 0)
    ;;                                          ".")
    ;;                          nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("\\\\/" (0
    ;;                  (progn
    ;;                    (compose-region (match-beginning 0)
    ;;                                    (+ (match-beginning 0) 2)
    ;;                                    "∨")
    ;;                    nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("/\\\\" (0
    ;;                  (progn
    ;;                    (compose-region (match-beginning 0)
    ;;                                    (+ (match-beginning 0) 2)
    ;;                                    "∧")
    ;;                    nil)))))
    ;;   ;; use "forall " to match the word
    ;;   ;; and use "∀" to compose-region [0-6]
    ;;   ;; but not "∀ " to compose-region [0-7]
    ;;   ;; this is very important !!!
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("forall " (0
    ;;                 (progn
    ;;                   (compose-region (match-beginning 0)
    ;;                                   (+ (match-beginning 0) 6)
    ;;                                   "∀")
    ;;                   nil)))))
    ;;   (font-lock-add-keywords
    ;;    nil
    ;;    `(("exists " (0
    ;;                 (progn
    ;;                   (compose-region (match-beginning 0)
    ;;                                   (+ (match-beginning 0) 6)
    ;;                                   "∃")
    ;;                   nil))))))

    ;; (add-hook 'coq-mode-hook
    ;;           'pretty-display-for-coq)
    ;; (add-hook 'coq-goals-mode-hook
    ;;           'pretty-display-for-coq)
    ;; (add-hook 'coq-response-mode-hook
    ;;           'pretty-display-for-coq)
    #+end_src


*** perl (nothing need to be added)


*** ruby

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/inf-ruby/")
    (require 'inf-ruby)
    (autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
    (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

    (add-to-list 'load-path "~/.emacs.d/enhanced-ruby-mode/")
    (require 'enh-ruby-mode)
    (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
    (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
    (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))

    ;; (defun ruby-send-line ()
    ;;   (interactive)
    ;;   (move-beginning-of-line nil)
    ;;   (cua-set-mark)
    ;;   (move-end-of-line nil)
    ;;   (ruby-send-region (region-beginning) (region-end))
    ;;   (cua-set-mark)
    ;;   (move-end-of-line nil))

    ;; (defun ruby-easy-to-eval ()
    ;;   (interactive)
    ;;   (if (>= (+ 1 (point))
    ;;           (point-max))
    ;;       (message "C-<tab> : last sexp is evaled")
    ;;       (let ()
    ;;         (ruby-send-line)
    ;;         (next-line)
    ;;         (move-end-of-line nil))))

    ;; (add-hook
    ;;  'ruby-mode-hook
    ;;  (lambda ()
    ;;    (local-set-key (kbd "C-<tab>") 'ruby-easy-to-eval)))
    #+end_src


*** sql (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/sql/")
    (require 'sql)
    (require 'mysql)
    #+end_src

    如果你的 mysql 端口不是标准端口的话 需要:
    #+begin_src emacs-lisp
    (setq sql-mysql-options (list "-P 6871"))
    #+end_src

    通过下面的命令设置两个连接 mysql 的常用帐号:
    #+begin_src emacs-lisp
    (setq sql-connection-alist
              '((pool-a
             (sql-product 'mysql)
             (sql-server "ip1")
             (sql-user "user1")
             (sql-password "pwd1")
             (sql-database "db1")
             (sql-port 6871))
            (pool-b
             (sql-product 'mysql)
             (sql-server "ip2")
             (sql-user "user2")
             (sql-password "pwd2")
             (sql-database "db2")
             (sql-port 3306))))

    (defun sql-connect-preset (name)
      "Connect to a predefined SQL connection listed in `sql-connection-alist'"
      (eval `(let ,(cdr (assoc name sql-connection-alist))
            (flet ((sql-get-login (&rest what)))
              (sql-product-interactive sql-product)))))

    (defun mysql-a ()
      (interactive)
      (sql-connect-preset 'pool-a))

    (defun mysql-b ()
      (interactive)
      (sql-connect-preset 'pool-b))
    #+end_src


***** indent
      fuck
      there is no good indent-mode for sql
      all the following are stupid
      :tangle ~/.emacs
      #+begin_src emacs-lisp
      ;; (eval-after-load "sql"
      ;;   '(load-library "sql-indent"))


      ;; (eval-after-load "sql"
      ;;   '(load-library "tsql-indent"))
      (require 'tsql-indent)
      (add-hook 'sql-mode-hook
        (lambda ()
              (define-key sql-mode-map (kbd "<tab>") 'tsql-indent-line)))

      ;; (require 'sql-smie-mode)
      ;; (add-hook 'sql-mode-hook 'sql-smie-mode)
      #+end_src



*** lojban (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (load-file "~/.emacs.d/lojban.el")
    (load-file "~/.emacs.d/lojban-mode.el")
    (autoload 'lojban-mode "lojban-mode" nil t)
    #+end_src


*** lua (not using)

***** load
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/lua-mode/")

      (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
      (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
      (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
      #+end_src

***** key
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-hook 'lua-mode-hook  (lambda ()
              (define-key lua-mode-map (kbd "C-<tab>") 'lua-send-current-line)
              (define-key lua-mode-map (kbd "C-x C-e") 'lua-send-defun)
              (define-key lua-mode-map (kbd "C-x C-r") 'lua-send-region)
              (define-key lua-mode-map (kbd "C-c C-e") 'lua-send-defun)
              (define-key lua-mode-map (kbd "C-c C-r") 'lua-send-region)
              ))
      #+end_src


*** yaml
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/yaml-mode/")
    (require 'yaml-mode)
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))

    (add-hook 'yaml-mode-hook
                          '(lambda ()
                                 (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
    #+end_src


*** Makefile
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun insert-tab ()
      (interactive)
      (insert 9))


    (add-hook 'makefile-mode-hook
              '(lambda ()
                     (local-set-key (kbd "<tab>") 'insert-tab)))
    #+end_src

*** cmake
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/cmake-mode/")
    (require 'cmake-mode)
    #+end_src


*** BNF
    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-generic-mode 'bnf-mode
     () ;; comment char: inapplicable because # must be at start of line
     nil ;; keywords
     '(
       ("^#.*" . 'font-lock-comment-face) ;; comments at start of line
       ;; ("^<[^ \t\n]*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
       ;; ("<[^ \t\n]*?>" . 'font-lock-builtin-face) ;; other nonterminals
       ;; 下面的版本中<>里可以有空格
       ("^<.*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
       ("<.*?>" . 'font-lock-builtin-face) ;; other nonterminals
       ("::=" . 'font-lock-const-face) ;; "goes-to" symbol
       ("\|" . 'font-lock-warning-face) ;; "OR" symbol
       )
     '("\\.bnf\\'") ;; filename suffixes
     nil ;; extra function hooks
     "Major mode for BNF highlighting.")
    #+end_src


*** liquid-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;;; NOTES:
    ;;;   - two syntax matching types:
    ;;;     1) "regex" . font-lock-name
    ;;;     2) "regex" (capture-group-id font-lock-name)
    ;;;   - variable name regex: \\(?:\\w\\|\\.\\|_\\)+
    ;;;
    ;;; TODO:
    ;;;   - strings can be in single quotes
    ;;;   - detect string vs. object value types
    ;;;   - detect boolean operators (and|or)
    ;;;   - add groups for cycle tags
    ;;;   - for:
    ;;;     - add limit:n, offset:n
    ;;;     - add reversed
    ;;;     - add support for ranges

    (setq liquidKeywords
                  '(
                    ;;; core stuff
                    ("{%\\|%}\\|{{\\|}}" . font-lock-comment-face) ;;; liquid tag delimiters
                    ("{%\s*\\(assign\\|capture\\|endcapture\\|for\\|endfor\\|if\\|endif\\|comment\\|endcomment\\|else\\|elsif\\|unless\\|endunless\\|case\\|when\\|endcase\\|cycle\\)" (1 font-lock-keyword-face)) ;;; liquid construct tags
                    ("forloop" . font-lock-keyword-face)
                    ("forloop.\\(length\\|index0\\|index\\|rindex0\\|rindex\\|first\\|last\\)" (1 font-lock-variable-name-face))
                    ("{%\s*\\(?:assign\\|capture\\|for\\|if\\|unless\\|case\\|when\\)\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable after assign|capture|for|if

                    ("{{\s*\\(\\(?:\\w\\|\\.\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable/object being outputted

                    ;;; filter stuff (hack, only supports 2 chained filters)
                    ("\s+|\s+" . font-lock-comment-face) ;;; liquid tag delimiters
                    ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if
                    ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\w+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if

                    ;;; if/else stuff
                    ("{%\s*\\(?:if\\|unless\\)\s+\\(?:\\w\\|\\.\\)+\s+\\(contains\\|>\\|<\\|==\\|!=\\)" (1 font-lock-keyword-face)) ;;; liquid operators

                    ;;; for loop stuff
                    ("{%\s*for\s+\\w+\s+\\(in\\)" (1 font-lock-keyword-face)) ;;; the 'in' in "for temp in collection"
                    ("{%\s*for\s+\\w+\s+in\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; the 'collection' in "for temp in collection"
                    )
                  )
    (define-derived-mode liquid-mode html-mode
          (setq font-lock-defaults '(liquidKeywords))
          (setq mode-name "liquid mode")
          )
    #+end_src


*** fish
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/fish-mode/")
    (require 'fish-mode)
    #+end_src

* org-mode

*** publishing
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-publish-project-alist
          '(("the-little-language-designer"
             :base-directory "~/cicada-nymph/"
             :publishing-directory "~/cicada-nymph/"
             :publishing-function org-html-publish-to-html
             :section-numbers nil
             :with-toc nil
             :html-head "<link rel=\"stylesheet\"
                        href=\"../other/mystyle.css\"
                        type=\"text/css\"/>")))
    #+end_src

*** [prefix-command] C-o
    #+begin_src emacs-lisp :tangle ~/.emacs
    (define-prefix-command 'C-o-map)
    (global-set-key (kbd "C-o") 'C-o-map)
    ;; used by:
    ;; "C-o C-b" : org-iswitchb
    #+end_src

*** **-in-org
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun **-in-org ()
      "abc ==> *abc*"
      (interactive)
      (progn
            (insert "*")
            (org-end-of-line)
            (insert "*")))
    #+end_src

*** key binding
    #+begin_src emacs-lisp :tangle ~/.emacs
    (eval-after-load 'org
      '(progn

        ;; **-in-org
        (define-key org-mode-map (kbd "M-*") '**-in-org)

        ;; cruise
        (define-key org-mode-map (kbd "M-n") 'outline-next-visible-heading)
        (define-key org-mode-map (kbd "M-p") 'outline-previous-visible-heading)
        (define-key org-mode-map (kbd "<M-up>") nil)
        (define-key org-mode-map (kbd "<M-down>") nil)

        ;; text migration
        ;; ``org-metaup'' and ``org-metadown''
        ;; are really dangerous functions
        ;; so it should be as hard as possible to mis-type it
        (define-key org-mode-map (kbd "C-M-p") 'org-metaup)
        (define-key org-mode-map (kbd "C-M-n") 'org-metadown)

        ;; in babel
        (define-key org-mode-map (kbd "M-.") 'org-babel-next-src-block)
        (define-key org-mode-map (kbd "M-,") 'org-babel-previous-src-block)
        (define-key org-mode-map (kbd "C-s C-s") 'org-edit-src-code)
        ;; (turn-off-indent)
        ))

    ;; (add-hook
    ;;  'org-mode-hook
    ;;  (lambda ()

    ;;    ;; **-in-org
    ;;    (local-set-key (kbd "M-*") '**-in-org)

    ;;    ;; cruise
    ;;    (local-set-key (kbd "M-n") 'outline-next-visible-heading)
    ;;    (local-set-key (kbd "M-p") 'outline-previous-visible-heading)
    ;;    (local-set-key (kbd "<M-up>") nil)
    ;;    (local-set-key (kbd "<M-down>") nil)

    ;;    ;; text migration
    ;;    ;; ``org-metaup'' and ``org-metadown''
    ;;    ;; are really dangerous functions
    ;;    ;; so it should be as hard as possible to mis-type it
    ;;    (local-set-key (kbd "C-M-p") 'org-metaup)
    ;;    (local-set-key (kbd "C-M-n") 'org-metadown)

    ;;    ;; in babel
    ;;    (local-set-key (kbd "M-.") 'org-babel-next-src-block)
    ;;    (local-set-key (kbd "M-,") 'org-babel-previous-src-block)
    ;;    (local-set-key (kbd "C-s C-s") 'org-edit-src-code)
    ;;    ))

    (add-hook
     'org-src-mode-hook
     (lambda ()
       (local-set-key (kbd "C-s C-s") 'org-edit-src-exit)
       ))
    #+end_src

*** variable
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'org-mode-hook (setq case-fold-search nil))
    (setq org-startup-indented nil)
    (setq org-babel-no-eval-on-ctrl-c-ctrl-c t)
    ;; (setq org-agenda-window-setup )
    ;; (setq org-agenda-restore-windows-after-quit )

    (setq org-hide-leading-stars t)
    (setq org-odd-levels-only t)
    #+end_src

*** todo-keyword
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-todo-keywords
          '((sequence "><" "|" "><><" "|" "><><><")

            (sequence "todo")
            (sequence "待")

            (sequence "note" "|" "test")
            (sequence "記" "|" "測")
            ;; (sequence "记" "|" "测")
            ))
    #+end_src

*** tag
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-tags-column 38)
    #+end_src

*** [babel] load-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (org-babel-do-load-languages
       'org-babel-load-languages
       '(
             ;; (java . t)
             ;;(cicada . t)
             (scheme . t)
             (lisp . t)
             ;; (shen . t)
             ;; (clojure . t)
             (emacs-lisp . t)
             ;; (sml . t)
             ;; (caml . t)
             ;; (forth . t)
             ;; (sh . t)
             ;; (perl . t)
             ;; (ruby . t)
             ;; (haskell . t)
             ;; (C . t)
             (coq . t)
             ;; (sql . t)
             ;; (lojban . t)
             ;; (lua . t)
             ;; (fasm . t)
             ;; (nasm . t)
             ;; (bnf . t)
             ;; (yaml . t)
             ))
    #+end_src

*** [babel] edit
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'org-mode-hook (setq org-src-preserve-indentation nil))
    (add-hook 'org-mode-hook (setq org-src-do-not-insert-comma t))
    (add-hook 'org-mode-hook (setq org-edit-src-content-indentation 0))
    (add-hook 'org-mode-hook (setq org-src-window-setup 'current-window))
    (add-hook 'org-mode-hook (setq org-src-fontify-natively t))

    ;; (add-hook 'org-mode-hook (setq org-src-tab-acts-natively t))
    ;; if turn on the above variable
    ;; structure-template-alist will be unable to use

    (add-hook 'org-mode-hook (setq org-src-ask-before-returning-to-edit-buffer nil))
    #+end_src

*** [babel] structure-template-alist

***** note
      1. C-c C-v d
         org-babel-demarcate-block
      2. begin_src <lang-name> 会去搜索<lang-name>的 major-mode
         只要能搜索到就都能用编辑功能
      3. ob-<lang-name>.el 是用来提供更多的关于语言的其他功能的

***** basic
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-basic
            '(
              ;; just src
              ("sf" "#+end_src\n?\n#+begin_src" "<src lang=\"?\">\n\n</src>")
              ("s" "#+begin_src\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; picture
              ("picturef" "#+end_src\n?\n#+begin_src picture" "<src lang=\"?\">\n\n</src>")
              ("picture" "#+begin_src picture\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; not using
              ;; ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
              ;; ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
              ;; ("C" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
              ;; ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
              ;; ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
              ;; ("l" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>")
              ;; ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
              ;; ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
              ;; ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
              ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII")
              ;; ("A" "#+ASCII: ")
              ;; ("i" "#+INDEX: ?" "#+INDEX: ?")
              ;; ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")

              ))
      #+end_src

***** erlang-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-erlang-family
            '(
              ;; perl
              ("plf" "#+end_src\n?\n#+begin_src prolog" "<src lang=\"?\">\n\n</src>")
              ("pl" "#+begin_src prolog\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; erlang
              ("erlangf" "#+end_src\n?\n#+begin_src erlang" "<src lang=\"?\">\n\n</src>")
              ("erlang" "#+begin_src erlang\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lfe
              ("lfef" "#+end_src\n?\n#+begin_src lfe" "<src lang=\"?\">\n\n</src>")
              ("lfe" "#+begin_src lfe\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** lisp-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-lisp-family
            '(
              ;; scheme
              ("ssf" "#+end_src\n?\n#+begin_src scheme" "<src lang=\"?\">\n\n</src>")
              ("ss" "#+begin_src scheme\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; racket
              ("srf" "#+end_src\n?\n#+begin_src racket" "<src lang=\"?\">\n\n</src>")
              ("sr" "#+begin_src racket\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lisp
              ("lispf" "#+end_src\n?\n#+begin_src lisp" "<src lang=\"?\">\n\n</src>")
              ("lisp" "#+begin_src lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; shen
              ("shenf" "#+end_src\n?\n#+begin_src shen" "<src lang=\"?\">\n\n</src>")
              ("shen" "#+begin_src shen\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; clojure
              ("clojuref" "#+end_src\n?\n#+begin_src clojure" "<src lang=\"?\">\n\n</src>")
              ("clojure" "#+begin_src clojure\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; emacs-lisp
              ("seef" "#+end_src\n?\n#+begin_src emacs-lisp :tangle ~/.emacs" "<src lang=\"?\">\n\n</src>")
              ("see" "#+begin_src emacs-lisp :tangle ~/.emacs\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("sef" "#+end_src\n?\n#+begin_src emacs-lisp" "<src lang=\"?\">\n\n</src>")
              ("se" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** forth-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-forth-family
            '(
              ;; cicada-nymph
              ("cnf" "#+end_src\n?\n#+begin_src cicada-nymph" "<src lang=\"?\">\n\n</src>")
              ("cn" "#+begin_src cicada-nymph\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; cicada-language
              ("clf" "#+end_src\n?\n#+begin_src cicada-language" "<src lang=\"?\">\n\n</src>")
              ("cl" "#+begin_src cicada-language\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; forth
              ("forthf" "#+end_src\n?\n#+begin_src forth" "<src lang=\"?\">\n\n</src>")
              ("forth" "#+begin_src forth\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** ml-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-ml-family
            '(
              ;; sml
              ("smlf" "#+end_src\n?\n#+begin_src sml" "<src lang=\"?\">\n\n</src>")
              ("sml" "#+begin_src sml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; caml
              ("camlf" "#+end_src\n?\n#+begin_src caml" "<src lang=\"?\">\n\n</src>")
              ("caml" "#+begin_src caml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** asm-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-asm-family
            '(
              ;; fasm
              ("fasmf" "#+end_src\n?\n#+begin_src fasm" "<src lang=\"?\">\n\n</src>")
              ("fasm" "#+begin_src fasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; nasm
              ("nasmf" "#+end_src\n?\n#+begin_src nasm" "<src lang=\"?\">\n\n</src>")
              ("nasm" "#+begin_src nasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** mark-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-mark-language
            '(
              ;; yaml
              ("yamlf" "#+end_src\n?\n#+begin_src yaml" "<src lang=\"?\">\n\n</src>")
              ("yaml" "#+begin_src yaml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; css
              ("cssf" "#+end_src\n?\n#+begin_src css" "<src lang=\"?\">\n\n</src>")
              ("css" "#+begin_src css\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; bnf
              ("bnff" "#+end_src\n?\n#+begin_src bnf" "<src lang=\"?\">\n\n</src>")
              ("bnf" "#+begin_src bnf\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** c-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-c-family
            '(
              ;; c
              ("cf" "#+end_src\n?\n#+begin_src c" "<src lang=\"?\">\n\n</src>")
              ("c" "#+begin_src c\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; java
              ("javaf" "#+end_src\n?\n#+begin_src java" "<src lang=\"?\">\n\n</src>")
              ("java" "#+begin_src java\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; js
              ("jsf" "#+end_src\n?\n#+begin_src js" "<src lang=\"?\">\n\n</src>")
              ("js" "#+begin_src js\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; coffeescript
              ("cof" "#+end_src\n?\n#+begin_src coffee" "<src lang=\"?\">\n\n</src>")
              ("co" "#+begin_src coffee\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; py
              ("pyf" "#+end_src\n?\n#+begin_src python" "<src lang=\"?\">\n\n</src>")
              ("py" "#+begin_src python\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; lua
              ("luaf" "#+end_src\n?\n#+begin_src lua" "<src lang=\"?\">\n\n</src>")
              ("lua" "#+begin_src lua\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; perl
              ("perlf" "#+end_src\n?\n#+begin_src perl" "<src lang=\"?\">\n\n</src>")
              ("perl" "#+begin_src perl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; shell
              ("shf" "#+end_src\n?\n#+begin_src sh" "<src lang=\"?\">\n\n</src>")
              ("sh" "#+begin_src sh\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** human-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-human-language
            '(
              ;; lojban
              ("ljf" "#+end_src\n?\n#+begin_src lojban" "<src lang=\"?\">\n\n</src>")
              ("lj" "#+begin_src lojban\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** proof-language
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-proof-language
            '(
              ;; coq
              ("coqf" "#+end_src\n?\n#+begin_src coq" "<src lang=\"?\">\n\n</src>")
              ("coq" "#+begin_src coq\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** haskell
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-haskell-family
            '(
              ;; haskell
              ("hsf" "#+end_src\n?\n#+begin_src haskell" "<src lang=\"?\">\n\n</src>")
              ("hs" "#+begin_src haskell\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; agda
              ("agf" "#+end_src\n?\n#+begin_src agda2" "<src lang=\"?\">\n\n</src>")
              ("ag" "#+begin_src agda2\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; idris
              ("idf" "#+end_src\n?\n#+begin_src idris" "<src lang=\"?\">\n\n</src>")
              ("id" "#+begin_src idris\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ))
      #+end_src

***** other-family
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-other-family
            '(
              ;; fish
              ("fishf" "#+end_src\n?\n#+begin_src fish" "<src lang=\"?\">\n\n</src>")
              ("fish" "#+begin_src fish\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; sql
              ("sqlf" "#+end_src\n?\n#+begin_src sql" "<src lang=\"?\">\n\n</src>")
              ("sql" "#+begin_src sql\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; ruby
              ("rubyf" "#+end_src\n?\n#+begin_src ruby" "<src lang=\"?\">\n\n</src>")
              ("ruby" "#+begin_src ruby\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; tcl
              ("tclf" "#+end_src\n?\n#+begin_src tcl" "<src lang=\"?\">\n\n</src>")
              ("tcl" "#+begin_src tcl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

              ;; for many kinds of conf-modes
              ("conff" "#+end_src\n?\n#+begin_src conf :tangle " "<src lang=\"?\">\n\n</src>")
              ("conf" "#+begin_src conf :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("confuf" "#+end_src\n?\n#+begin_src conf-unix :tangle " "<src lang=\"?\">\n\n</src>")
              ("confu" "#+begin_src conf-unix :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ("confxf" "#+end_src\n?\n#+begin_src conf-xdefaults :tangle " "<src lang=\"?\">\n\n</src>")
              ("confx" "#+begin_src conf-xdefaults :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
              ))
      #+end_src

***** main
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq org-structure-template-alist
            (append
             org-structure-template-basic

             org-structure-template-mark-language
             org-structure-template-proof-language
             org-structure-template-human-language

             org-structure-template-lisp-family
             org-structure-template-forth-family
             org-structure-template-ml-family
             org-structure-template-erlang-family

             org-structure-template-asm-family
             org-structure-template-c-family

             org-structure-template-haskell-family

             org-structure-template-other-family

             ))
      #+end_src

*** [babel] evaluation
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'org-mode-hook (setq org-confirm-babel-evaluate nil))

    ;; default arguments to use when evaluating a source block
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache   . "no")
            (:noweb   . "yes")
            (:hlines  . "no")
            (:tangle  . "no")

            ;; shebang `#!' needs the following
            ;; (:padline . "no")

            (:padline . "yes")
            ))
    #+end_src

*** [agenda] setting
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-agenda-files "~/.agenda/file-name-list")

    (global-set-key (kbd "C-M-o") 'org-cycle-agenda-files)
    (global-set-key (kbd "C-o C-b") 'org-iswitchb)
    (global-set-key (kbd "C-o C-l") 'org-toggle-link-display)
    (global-set-key (kbd "C-c a") 'org-agenda)

     (add-hook
      'org-mode-hook
      (lambda ()
        ;; 原来的 org-cycle-agenda-files 是 C-,
        ;; 我需要重新绑定它
        (local-set-key (kbd "C-,") 'ska-jump-to-register)
        ))
    #+end_src

*** [agenda] org-agenda-files
    tangle take too long so just edit
    file:~/.org-agenda-files

*** org to html & pdf

***** s5                              :no:
      #+begin_src emacs-lisp
      (add-to-list 'load-path "~/.emacs.d/org-mode/contrib/lisp/")
      (require 'ox-s5)
      ;; (setq org-s5-theme "railscast")   ; based off `color-theme-railscasts'
      ;; (setq org-s5-theme "default")     ; the default S5 theme
      (setq org-s5-theme "i18n")        ; the i18n theme by the author of S5
      #+end_src

***** org-pres-mode
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/eimp/")
      (require 'eimp)

      (add-to-list 'load-path "~/.emacs.d/org-presie/")
      (require 'org-presie)
      #+end_src

***** org-tree-slide
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/org-tree-slide/")
      (require 'org-tree-slide)

      (add-hook
       'org-tree-slide-mode-play-hook
       (lambda ()
         (local-set-key (kbd "<f9>") 'org-tree-slide-move-previous-tree)
         (local-set-key (kbd "<f10>") 'org-tree-slide-move-next-tree)
         (local-set-key (kbd "<f11>") 'org-tree-slide-content)
         ))

      (global-set-key (kbd "<f8>") 'org-tree-slide-mode)

      ;; (define-key org-tree-slide-mode-map )

      ;; Reset the default setting

      ;; (define-key org-tree-slide-mode-map (kbd "<left>")  'backward-char)
      ;; (define-key org-tree-slide-mode-map (kbd "<right>") 'forward-char)
      ;; (setq org-tree-slide-skip-outline-level 4)
      ;; (org-tree-slide-narrowing-control-profile)
      ;; (setq org-tree-slide-skip-done nil)
      #+end_src

***** org-reveal
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/org-reveal/")
      (require 'ox-reveal)
      (setq org-reveal-root "/home/xyh/software/reveal.js/")
      (setq org-reveal-hlevel 2)
      #+end_src

* my org-mode

*** org-get-code-block-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun org-get-code-block-path ()
      (let* ((element (org-element-at-point))
             (type (org-element-type element))
             (parameters (org-element-property :parameters element))
             (tangle-begin
              (string-match (rx (seq
                                 ":tangle"
                                 (one-or-more " ")))
                            parameters))
             (tangle-end
              (string-match (rx (seq
                                 (one-or-more " ")))
                            parameters
                            tangle-begin))
             (path-begin
              (string-match (rx (seq
                                 (one-or-more (not (in " ")))))
                            parameters
                            tangle-end))
             (path-end
              (string-match (rx (seq
                                 (one-or-more (in " "))))
                            parameters
                            path-begin)))
        (unless (and (memq type '(example-block src-block))
                     (org-src--on-element-p element))
          (user-error "Not in a source or example block"))
        (substring parameters path-begin path-end)))

    (defun really-kill-buffer ()
      (interactive)
      (kill-buffer (current-buffer)))

    (defun org-switch-to-code-block-file ()
      (interactive)
      (find-file (org-get-code-block-path))
      (local-set-key (kbd "C-s C-a") 'really-kill-buffer))
    (global-set-key (kbd "C-s C-a") 'org-switch-to-code-block-file)
    #+end_src

* app

*** command-log-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/command-log-mode/")
    (require 'command-log-mode)

    (add-hook 'org-mode-hook 'command-log-mode)

    (add-hook 'elisp-mode-hook 'command-log-mode)
    (add-hook 'lisp-mode-hook 'command-log-mode)
    (add-hook 'scheme-mode-hook 'command-log-mode)

    (add-hook 'agda2-mode-hook 'command-log-mode)
    (add-hook 'cicada-nymph-mode-hook 'command-log-mode)
    #+end_src

*** w3m [installed by pacman]
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'w3m-load)

    ;; (setq browse-url-browser-function 'w3m-browse-url)
    ;; (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)

    ;; optional keyboard short-cut

    (add-hook
     'w3m-mode-hook
     (lambda ()
       (local-set-key (kbd "M-n") 'forward-paragraph)
       (local-set-key (kbd "M-p") 'backward-paragraph)

       (local-set-key (kbd "<down>") 'forward-paragraph)
       (local-set-key (kbd "<up>") 'backward-paragraph)

       (local-set-key (kbd "j") 'w3m-view-previous-page)
       (local-set-key (kbd "l") 'w3m-view-next-page)
       (local-set-key (kbd "i") 'w3m-previous-anchor)
       (local-set-key (kbd "k") 'w3m-next-anchor)

       (local-set-key (kbd "C-M-n") 'w3m-next-buffer)
       (local-set-key (kbd "C-M-p") 'w3m-previous-buffer)

       (local-set-key (kbd "<C-tab>") 'w3m-next-buffer)
       (local-set-key (kbd "<C-iso-lefttab>") 'w3m-previous-buffer)

       (local-set-key (kbd "e") 'w3m-edit-url)
       (local-set-key (kbd "E") 'w3m-edit-url)

       (local-set-key (kbd "q") 'quit-window)

       ;; in default setting
       ;; C-t is a prefix
       (local-set-key (kbd "C-t") 'isearch-forward)
       ))
    #+end_src

*** hippie-expand
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "C-h") 'hippie-expand)
    (setq hippie-expand-try-functions-list
              '(try-expand-dabbrev
            try-expand-dabbrev-visible
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill
            try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-list
            try-expand-line
            pcomplete
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol
            ))
    #+end_src

*** primary-clipboard-yank
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; ;; (eshell-command &optional COMMAND ARG)
    ;; ;; Execute the Eshell command string COMMAND
    ;; ;; With prefix ARG, insert output into the current buffer at point

    ;; (shell-command "xterm &")
    ;; (eshell-command "xterm &")

    ;; ;; 下面这句会开一个 out-put-buffer 然后显示输出的东西
    ;; (eshell-command "parcellite -p")
    ;; ;; == (eshell-command "parcellite -p" nil)


    ;; ;; 下面这个不开 out-put-buffer 会把光标停在粘贴的东西前面
    ;; (eshell-command "parcellite -p" nil)


    ;; ;; (eshell-command-result "parcellite -p")
    ;; ;; 下面这个会把光标停在粘贴的东西后面
    ;; (insert (eshell-command-result "parcellite -p"))

    ;; ;; 下面这个函数虽然跑的快
    ;; ;; 但是从 emacs 的 kill-ring 中粘贴东西的时候却会死掉
    ;; ;; (insert (shell-command-to-string "parcellite -p"))


    (defun primary-clipboard-yank ()
      (interactive)
      (insert (eshell-command-result "clipit -p")))
    (global-set-key (kbd "C-M-y") 'primary-clipboard-yank)
    #+end_src

*** gc optimization
    * gc-cons-threshold
      #+begin_src emacs-lisp :tangle ~/.emacs
      (setq gc-cons-threshold 20000000)
      #+end_src
    * Emacs's garbage collector is fairly primitive stop the world type.
      GC time can contribute significantly to the run-time of computation that allocates and frees a lot of memory.
    * Consider the following example:
      #+begin_src emacs-lisp
      (defun uuid ()
        (format "%08x-%08x-%08x-%08x"
                (random (expt 16 4))
                (random (expt 16 4))
                (random (expt 16 4))
                (random (expt 16 4))))

      (benchmark-run 1
        (let ((cache (flx-make-filename-cache)))
              (dolist (i (number-sequence 0 10000))
                (flx-process-cache (uuid) cache))))
              ;;; ⇒ (0.899678 9 0.33650300000000044)
      #+end_src
    * This means that roughly 30% of time is spent just doing garbage-collection.
    * flx can benefit significantly from garbage collection tuning.
    * By default Emacs will initiate GC every 0.76 MB allocated (gc-cons-threshold == 800000).
      If we increase this to 20 MB (gc-cons-threshold == 20000000) we get:
      #+begin_src emacs-lisp
      (benchmark-run 1
        (setq gc-cons-threshold 20000000)
        (let ((cache (flx-make-filename-cache)))
              (dolist (i (number-sequence 0 10000))
                (flx-process-cache (uuid) cache))))
              ;;; ⇒ (0.62035 1 0.05461100000000041)
      #+end_src

*** auto-overlay                      :no:
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/auto-overlays/")
    (require 'auto-overlays)
    (require 'auto-overlay-common)
    (require 'auto-overlay-flat)
    (require 'auto-overlay-line)
    (require 'auto-overlay-nested)
    (require 'auto-overlay-self)
    (require 'auto-overlay-word)
    (require 'auto-overlays-compat)
    #+end_src

***** test
      #+begin_src emacs-lisp
      (auto-overlay-load-definition
                'latex
                '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)"
                        (face . (background-color . "blue")))))
      #+end_src

*** ido

***** note
      * ido is part of emacs

***** main
      * use C-f during file selection to switch to regular find-file
      #+begin_src emacs-lisp :tangle ~/.emacs
      (ido-mode t)
      (ido-everywhere t)
      (setq ido-enable-flex-matching t)
      (setq ido-use-filename-at-point nil)
      (setq ido-auto-merge-work-directories-length 0)
      (setq ido-use-virtual-buffers t)
      (setq ido-default-buffer-method 'switch-buffer)
      #+end_src

***** ido-switch-buffer
      * default key-binding
        | RET     |                         | Select the buffer at the front of the list of matches.            |
        |         |                         | If the list is empty, possibly prompt to create new buffer.       |
        | C-j     | ido-select-text         | Use the current input string verbatim.                            |
        | C-s     | ido-next-match          | Put the first element at the end of the list.                     |
        | C-r     | ido-prev-match          | Put the last element at the start of the list.                    |
        | TAB     | ido-complete            | Complete a common suffix to the current string that matches       |
        |         |                         | all buffers.  If there is only one match, select that buffer.     |
        |         |                         | If there is no common suffix, show a list of all matching buffers |
        |         |                         | in a separate window.                                             |
        | C-e     | ido-edit-input          | Edit input string.                                                |
        | C-x C-b | ido-fallback-command    | Fallback to non-ido version of current command.                   |
        | C-t     | ido-toggle-regexp       | Toggle regexp searching.                                          |
        | C-p     | ido-toggle-prefix       | Toggle between substring and prefix matching.                     |
        | C-c     | ido-toggle-case         | Toggle case-sensitive searching of buffer names.                  |
        | ?       | ido-completion-help     | Show list of matching buffers in separate window.                 |
        | C-x C-f | ido-enter-find-file     | Drop into `ido-find-file'.                                        |
        | C-k     | ido-kill-buffer-at-head | Kill buffer at head of buffer list.                               |
        | C-a     | ido-toggle-ignore       | Toggle ignoring buffers listed in `ido-ignore-buffers'.           |
      #+begin_src emacs-lisp :tangle ~/.emacs
      (global-set-key (kbd "C-x b") 'list-buffers)
      (global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
      (add-hook 'ido-minibuffer-setup-hook
                (lambda ()
                  (local-set-key (kbd "C-s") 'ido-toggle-prefix)
                  (local-set-key (kbd "C-r") 'ido-toggle-regexp)
                  (local-set-key (kbd "C-n") 'ido-next-match)
                  (local-set-key (kbd "C-p") 'ido-prev-match)))
      #+end_src

***** ido-ubiquitions
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/ido-ubiquitous/")
      (require 'ido-ubiquitous)
      (ido-ubiquitous-mode t)
      #+end_src

***** ido-at-point
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/ido-at-point/")
      (require 'ido-at-point)
      (ido-at-point-mode)
      #+end_src

***** flx-ido                         :no:
      #+begin_src emacs-lisp
      (add-to-list 'load-path "~/.emacs.d/flx/")
      (require 'flx-ido)
      (ido-mode 1)
      (ido-everywhere 1)
      (flx-ido-mode 1)
      ;; disable ido faces to see flx highlights.
      (setq ido-use-faces nil)

      ;; If don't want to use the flx's highlights you can turn them off like this:
      ;; (setq flx-ido-use-faces nil)
      #+end_src

***** ido-vertical-mode
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/ido-vertical-mode/")
      (require 'ido-vertical-mode)
      (ido-mode 1)
      (ido-vertical-mode 1)
      #+end_src

***** ido-hacks                       :no:
      #+begin_src emacs-lisp
      (add-to-list 'load-path "~/.emacs.d/ido-hacks/")
      (require 'ido-hacks)
      #+end_src

*** smex
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/smex/")
    (require 'smex)

    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    #+end_src

*** cua-selection-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (cua-selection-mode 1)
    #+end_src

*** popwin
    *needed by guide-key*
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/popwin/")
    #+end_src

*** [NOT USING] guide-key
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/guide-key/")
    (require 'guide-key)

    (setq guide-key/guide-key-sequence
              '("C-x r"
            "C-x 4"
            "C-x 5"
            "C-c C-v"))
    (setq guide-key/highlight-command-regexp "rectangle")

    ;; (setq guide-key/guide-key-sequence '("C-x"))
    ;; (setq guide-key/recursive-key-sequence-flag t)

    (defun guide-key/my-hook-function-for-org-mode ()
      (guide-key/add-local-guide-key-sequence "C-c")
      (guide-key/add-local-guide-key-sequence "C-c C-x")
      (guide-key/add-local-guide-key-sequence "C-c C-v")
      (guide-key/add-local-highlight-command-regexp "org-"))
    (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)

    ;; (setq guide-key/guide-key-sequence
    ;;       '("C-x r" "C-x 4"
    ;;         (org-mode "C-c C-x")
    ;;         (outline-minor-mode "C-c @")))

    (setq guide-key/idle-delay 2.7)

    ;; This variable controls where a guide-key buffer is popped up.
    ;; A value of this variable is one of right, bottom, left, top. The default value is right.
    (setq guide-key/popup-window-position 'bottom)

    ;; This variable controls the size of text in guide buffer.
    ;; The default value is 0 (it means default size in Emacs).
    ;; If you want to enlarge text, set positive number. Otherwise, set negative number.
    (setq guide-key/text-scale-amount 0)


    ;; Enable guide-key-mode
    (guide-key-mode 1)
    #+end_src

*** muse
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/muse/lisp/")

    (require 'muse-mode); load authoring mode
    (require 'muse-html); load publishing styles I use
    (require 'muse-latex)
    (require 'muse-texinfo)
    (require 'muse-docbook)
    (require 'muse-project); publish files in projects


    (setq muse-html-content-coding "utf-8")
    (setq muse-html-charset-default "utf-8")
    (setq muse-html-coding-default "utf-8")

    ;; (custom-set-variables
    ;;  '(muse-file-extension nil)
    ;;  '(muse-mode-auto-p t)
    ;;  '(muse-file-extension "muse")
    ;;  '(muse-html-meta-content-encoding (quote utf-8))
    ;;  '(muse-html-charset-default "utf-8")
    ;;  '(muse-html-encoding-default (quote utf-8))
    ;;  '(muse-html-encoding-map "utf8")
    ;;  '(muse-colors-autogen-headings (quote outline))
    ;;  '(muse-html-meta-content-encoding (quote utf-8))
    ;;  '(muse-html-meta-content-type "text/xhtml; charset=utf-8"))

    (add-hook 'muse-mode-hook
     (lambda ()
       (local-set-key (kbd "M-<tab>") 'window->)
       (local-set-key (kbd "M-9") 'move-line-backword)
       (local-set-key (kbd "M-0") 'move-line-foreword)
       (local-set-key (kbd "C-c C-c") 'muse-project-publish)
       ))
    #+end_src

*** muse-project-alist
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq muse-project-alist
              '(

            ("cicada"
             ("~/cicada/readings"
              :default "cicada")
             (:base "xelatex"
              :path "~/cicada/readings/xelatex"))

            ("cicada--cn"
             ("~/cicada/readings-chinese"
              :default "cicada-chinese")
             (:base "xelatex"
              :path "~/cicada/readings-chinese/xelatex"))

            ))
    #+end_src

*** htmlize
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/htmlize/")

    (require 'htmlize)
    (setq htmlize-output-type 'css)
    ;; (setq htmlize-output-type 'inline-css)
    ;; (setq htmlize-output-type 'font)
    #+end_src

*** uniquify
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'uniquify)
    ;(setq uniquify-buffer-name-style 'reverse)
    (setq uniquify-buffer-name-style 'forward)
    #+end_src

*** hg
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/hg/")
    (require 'mercurial)
    (require 'mq)

    (add-hook 'hg-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-c h l") 'hg-log-repo-and-change-mode)))
    (defun hg-log-repo-and-change-mode ()
      (interactive)
      (hg-log-repo (hg-root))
      (vc-hg-log-view-mode))
    #+end_src

*** magit                             :no:
    * compile by
      EFLAGS="-L ~/.emacs.d/git-modes" make lisp
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/git-modes/")
    (add-to-list 'load-path "~/.emacs.d/magit/")
    (require 'magit)

    (setq magit-last-seen-setup-instructions "1.4.0")

    ;; And optionally tell `info` about the documentation
    (eval-after-load 'info
      '(progn (info-initialize)
              (add-to-list 'Info-directory-list "~/.emacs.d/magit/")))

    (global-set-key (kbd "C-x g") 'magit-status)
    #+end_src

*** send mail
    * Gmail SMTP server address: smtp.gmail.com
      Gmail SMTP user name: Your full Gmail address (e.g. example@gmail.com)
      Gmail SMTP password: Your Gmail password
      Gmail SMTP port: 465
      Gmail SMTP TLS/SSL required: yes
    * Gmail IMAP server address: imap.gmail.com
      Gmail IMAP user name: Your full Gmail address (e.g. "me@gmail.com")
      Gmail IMAP password: Your Gmail password
      Gmail IMAP port: 993
      Gmail IMAP TLS/SSL required: yes
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (setq send-mail-function 'mailclient-send-it)
    (setq send-mail-function 'smtpmail-send-it)
    (setq smtpmail-smtp-server "smtp.gmail.com")
    (setq smtpmail-smtp-service 25)
    #+end_src

*** message
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq user-full-name "XIE Yuheng"
          user-mail-address "xyheme@gmail.com"
          message-auto-save-directory "~/mail/draft")
    #+end_src

*** [NOT USING] gnus

***** tangle to ~/.emacs
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'load-path "~/.emacs.d/gnus/lisp/")
      (require 'gnus-load)
      ;; (setq debug-on-error t)
      #+end_src

***** tangle to ~/.gnus.el
      #+begin_src emacs-lisp :tangle ~/.gnus.el
      (setq user-full-name "XIE Yuheng")
      (setq user-mail-address "xyheme@gmail.com")

      (setq gnus-select-method '(nntp "freenews.netfront.net"))
      ;; (add-to-list 'gnus-secondary-select-methods '(nntp "news.gnus.org"))
      ;; (add-to-list 'gnus-secondary-select-methods '(nntp "forums.sybase.com"))


      ;; 香港新闻组
      ;; news.newsgroup.com.hk
      ;; freenews
      ;; freenews.netfront.net
      ;; sybase 新闻组(英文)
      ;; forums.sybase.com
      ;; 以上三个服务器在大陆以外且参预全球转信

      ;; 希网新闻组
      ;; news.cn99.com 或 news.yaako.com
      ;; 大陆唯一参预全球转信的新闻组服务器
      #+end_src

*** [NOT USING] bbdb
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/bbdb-2.35/lisp/")
    (require 'bbdb)
    (bbdb-initialize 'gnus 'message)
    (setq bbdb-north-american-phone-numbers-p nil)
    #+end_src

*** tramp
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq tramp-persistency-file-name "~/.emacs.d/about-tramp/.tramp-connection-history")

    (setq tramp-default-user "xyh"
              tramp-default-host "XYH")

    (setq tramp-default-method "ssh")
    #+end_src

*** hlinum
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/hlinum-mode/")
    (require 'hlinum)
    (hlinum-activate)
    #+end_src

*** region-state
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/region-state/")
    (require 'region-state)
    (region-state-mode)
    (setq region-state-display-place 'echo-area)
    ;; (setq region-state-display-place 'header-line)
    ;; (setq region-state-display-place 'mode-line)
    #+end_src

* helm
  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/emacs-async/")
  (require 'async)

  (add-to-list 'load-path "~/.emacs.d/helm/")
  (require 'helm-config)
  ;; (helm-mode 1)

  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-M-t") 'helm-occur)

  (global-set-key (kbd "C-x C-f") 'helm-find-files)

  (global-set-key (kbd "C-x C-b") 'helm-mini)
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match    t)

  (add-hook 'helm-after-initialize-hook
            (lambda ()
              (define-key helm-map (kbd "C-h") 'helm-execute-persistent-action)))

  ;; (add-to-list 'load-path "~/.emacs.d/pcache/")
  ;; (add-to-list 'load-path "~/.emacs.d/logito/")
  ;; (add-to-list 'load-path "~/.emacs.d/gh.el/")
  ;; (add-to-list 'load-path "~/.emacs.d/emacs-helm-open-github/")
  ;; (require 'helm-open-github)
  #+end_src

* irc

*** rcirc
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq rcirc-default-nick "xyh")
    (setq rcirc-default-port "6666")
    (setq rcirc-default-user-name "xieyuheng")
    (setq rcirc-default-full-name "XIE Yuheng")

    (eval-after-load 'rcirc '(rcirc-track-minor-mode 1))

    (setq rcirc-server-alist
          '(("irc.freenode.net" :port 6666
             :channels (
                        ;; "#hackvana"
                        ;; "#osdev"
                        ;; "#constructive-math"
                        ;; "##categorytheory"
                        ;; "##typetheory"
                        ;; "#kq"

                        "#forth"

                        ;; "#agda"
                        ;; "#idris"

                        "##prolog"
                        ;; "#erlang"
                        ;; "#erlang-lisp"

                        ;; "#clojure"
                        ;; "#racket"

                        "#szdiy"

                        "#ocaml"

                        "#archlinux-cn"
                        "#linux-cn"
                        "#cicada-language"


                        ;; "##Orz"

                        ;; "#scheme"
                        ;; "#guile"
                        ;; "#lisp"
                        ;; "#ccl"
                        ;; "#coq"
                        ;; "#shen"
                        ;; "#haskell"
                        ;; "#minikanren"

                        ;; "#fcitx"
                        ))))
    #+end_src

*** rcirc-groups
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-groups/")
    (require 'rcirc-groups)
    (require 'rcirc-notify-mode)
    #+end_src

*** rcirc-notify+
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-notify-plus/")
    (require 'rcirc-notify+)
    (setq rcirc-notify+-open t)
    #+end_src

*** rcirc-autoreconnect
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rcirc-autoreconnect/")
    (require 'rcirc-autoreconnect)
    (setq rcirc-autoreconnect t)
    #+end_src

*** helm-rcirc
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/helm-rcirc/")
    (require 'helm-rcirc)
    #+end_src

*** circe                             :no:
    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/circe/")
    (require 'circe)

    (setq circe-network-options
          `(("Freenode"
             :nick "xyh"
             :port 6667
             :channels (
                        "#szdiy"
                        ;; "#hackvana"
                        "#archlinux-cn"
                        ;; "#osdev"

                        ;; "#constructive-math"
                        ;; "##categorytheory"
                        ;; "##typetheory"

                        "#agda"
                        "#idris"

                        ;; "#kq"

                        "#forth"
                        "#cicada-language"

                        ;; "##Orz"

                        ;; "#scheme"
                        ;; "#guile"
                        ;; "#lisp"
                        ;; "#ccl"
                        ;; "#coq"
                        ;; "#shen"
                        ;; "#haskell"
                        ;; "#minikanren"
                        ;; "#erlang"
                        ;; "#erlang-lisp"

                        ;; "#fcitx"
                        ))))
    #+end_src

*** erc
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq erc-autojoin-channels-alist
          '(("freenode.net"
             "#constructive-math"
             "##categorytheory"
             "##typetheory"
             "#szdiy"
             "#archlinux-cn"
             "#forth")))
    #+end_src

* file viewer

*** ranger                            :no:

    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/ranger-git/")
    (require 'ranger)

    ;; zp for minimal ranger mode (deer)

    (setq ranger-cleanup-on-disable t)
    (setq ranger-cleanup-eagerly t)

    ;; toggled by zh
    (setq ranger-show-dotfiles nil)

    ;; function used to output header of primary ranger window
    ;;   must return a string that is placed in the header-line
    (setq ranger-header-func 'ranger-header-line)

    (setq ranger-parent-depth 1) ;; adjusted by z- and z+

    ;; toggled by zi
    ;;   literal v.s. find-file
    (setq ranger-show-literal nil)

    (setq ranger-ignored-extensions
          '("mkv" "iso" "mp4" "pdf" "djvu"))

    ;; 1 MB
    (setq ranger-max-preview-size 1)
    #+end_src

*** warden

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/warden/")
    (require 'warden)

    (global-set-key (kbd "C-s C-w") 'warden)
    #+end_src

* window

*** eyebrowse

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/eyebrowse/")
    (require 'eyebrowse)
    (eyebrowse-mode 1)

    ;; ((kbd "<") 'eyebrowse-prev-window-config)
    ;; ((kbd ">") 'eyebrowse-next-window-config)
    ;; ((kbd "'") 'eyebrowse-last-window-config)
    ;; ((kbd "\"") 'eyebrowse-close-window-config)
    ;; ((kbd ",") 'eyebrowse-rename-window-config)
    ;; ((kbd ".") 'eyebrowse-switch-to-window-config)
    ;; ((kbd "0") 'eyebrowse-switch-to-window-config-0)
    ;; ((kbd "1") 'eyebrowse-switch-to-window-config-1)
    ;; ((kbd "2") 'eyebrowse-switch-to-window-config-2)
    ;; ((kbd "3") 'eyebrowse-switch-to-window-config-3)
    ;; ((kbd "4") 'eyebrowse-switch-to-window-config-4)
    ;; ((kbd "5") 'eyebrowse-switch-to-window-config-5)
    ;; ((kbd "6") 'eyebrowse-switch-to-window-config-6)
    ;; ((kbd "7") 'eyebrowse-switch-to-window-config-7)
    ;; ((kbd "8") 'eyebrowse-switch-to-window-config-8)
    ;; ((kbd "9") 'eyebrowse-switch-to-window-config-9)
    #+end_src

* looks like

*** font

***** <f7>
      #+begin_src emacs-lisp :tangle ~/.emacs
      (defvar *toggle-font-for-the-show* nil)
      (defun toggle-font-for-the-show ()
        (interactive)
        (if (eq *toggle-font-for-the-show* t)
            (progn
              ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 20))
              ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
              ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 20))
              (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
              ;; (set-face-attribute 'default nil :family "monofur" :height 140)
              (set-face-attribute 'default nil :family "Envy Code R" :height 140)
              (setq *toggle-font-for-the-show* nil))
            (progn
              ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 32))
              ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 32))
              ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 34))
              (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 34))
              ;; (set-face-attribute 'default nil :family "monofur" :height 240)
              (set-face-attribute 'default nil :family "Envy Code R" :height 240)
              (setq *toggle-font-for-the-show* t))))
      (global-set-key (kbd "<f7>") 'toggle-font-for-the-show)
      #+end_src

***** note
      用下面所使用的连个函数配置 emacs 的字体的时候
      其他一些程序(比如 firefox)的字体配置也会跟着改变

      "AR PL SungtiL GB" 文鼎 PL 简报宋
      "AR PL KaitiM GB" 文鼎 PL 简中楷

      "AR PL UKai" 文鼎 PL 中楷
      "AR PL UMing" 文鼎 PL 细上海宋

      "WenQuanYi Micro Hei" 文泉驿微米黑
      "WenQuanYi Zen Hei" 文泉驿正黑
      "WenQuanYi Bitmap Song" 文泉驿点阵宋体

      (set-fontset-font NAME TARGET FONT-SPEC &optional FRAME ADD)
      + NAME is a fontset name string
        nil for the fontset of FRAME
        or t for the default fontset
      + TARGET
        1. may be a cons: (FROM . TO)
           where FROM and TO are characters
           In that case
           use FONT-SPEC for all characters
           in the range FROM and TO (inclusive)
        2. may be a script name symbol
           In that case
           use FONT-SPEC for all characters
           that belong to the script
        3. may be a charset
           In that case
           use FONT-SPEC for all characters in the charset
        4. may be nil
           In that case
           use FONT-SPEC for any characters
           for that no FONT-SPEC is specified
      use the following function in *ielm* buffer
      to print script name symbol in emacs
      #+begin_src emacs-lisp
      (char-table-extra-slot char-script-table 0)
      #+end_src

***** test
      λλλλλλ|
      中英等宽测试|
      sdasddassaas|
      iiiiiiiiiiii|
      λλλλλλλλλλλλ|

***** 楷
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H\-宮書" :size 20))
      #+end_src

***** 宋
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "HanaMinA" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "HAN NOM A" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-秀月" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-SiuNiu" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "simsun" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 20))
      #+end_src

***** 黑
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'han (font-spec :name "H-雲林呉竹体" :size 20))
      (set-fontset-font t 'han (font-spec :name "H-明蘭" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-minglan" :size 20))

      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans Mono CJK TC" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Light" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC DemiLight" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Medium" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "SourceHanSans" :size 32))
      ;; (set-fontset-font t 'han (font-spec :name "WenQuanYi Micro Hei Mono" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-儷黑" :size 20))
      ;; (set-fontset-font t 'han (font-spec :name "H-新雅蘭" :size 20))
      #+end_src

***** 英
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-face-attribute 'default nil :family "monaco" :height 130)
      ;; (set-face-attribute 'default nil :family "Envy Code R" :height 140)
      ;; (set-face-attribute 'default nil :family "Source Code Pro" :height 130)
      ;; (set-face-attribute 'default nil :family "Sauce Code Powerline" :height 130)

      ;; (set-face-attribute 'default nil :family "Source Code Pro for Powerline" :height 130)

      (set-face-attribute 'default nil :family "Input" :height 120)

      ;; (set-face-attribute 'default nil :family "Droid Sans Mono" :height 130)
      ;; (set-face-attribute 'default nil :family "FiraMono" :height 130)
      ;; (set-face-attribute 'default nil :family "mono" :height 140)
      ;; (set-face-attribute 'default nil :family "monofur" :height 140)
      ;; (set-face-attribute 'default nil :family "lmmono10" :height 140)
      ;; (set-face-attribute 'default nil :family "lmmonocaps10" :height 140)
      ;; (set-face-attribute 'default nil :family "lmmonolt10" :height 140)
      ;; (set-face-attribute 'default nil :family "Inconsolata" :height 140)
      ;; (set-face-attribute 'default nil :family "Cousine" :height 140)
      ;; (set-face-attribute 'default nil :family "PT Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Anonymous Pro" :height 140)
      ;; (set-face-attribute 'default nil :family "Nova Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Fira Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Cutive Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Oxygen Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Share Tech Mono" :height 140)
      ;; (set-face-attribute 'default nil :family "Anonymous Pro" :height 140)
      #+end_src

***** 符
      #+begin_src emacs-lisp :tangle ~/.emacs
      (set-fontset-font t 'symbol (font-spec :name "mono"))
      ;; (set-fontset-font t 'symbol (font-spec :name "STIXGeneral"))
      #+end_src

***** 希臘
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (set-fontset-font t 'greek (font-spec :name "Porson"))
      ;; (set-fontset-font t 'greek (font-spec :name "mono"))
      ;; (set-fontset-font t 'greek (font-spec :name "STIXGeneral"))
      ;; (set-fontset-font t 'greek (font-spec :name "Code2000"))
      ;; (set-fontset-font t 'greek (font-spec :name "ALPHA\-Demo"))
      (set-fontset-font t 'greek (font-spec :name "FreeMono"))

      ;; α  Α     β  Β     γ  Γ     δ  Δ     ε  Ε
      ;; ζ  Ζ     η  Η     θ  Θ     ι  Ι     κ  Κ
      ;; λ  Λ     μ  Μ     ν  Ν     ξ  Ξ     ο  Ο
      ;; π  Π     ρ  Ρ     ς  ΢     σ  Σ     τ  Τ
      ;; υ  Υ     φ  Φ     χ  Χ     ψ  Ψ     ω  Ω
      #+end_src

*** theme

***** molokai
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-to-list 'custom-theme-load-path "~/.emacs.d/molokai-theme/")
      ;; (setq molokai-theme-kit t)
      (load-theme 'molokai t)
      #+end_src

***** zenburn
      #+begin_src emacs-lisp
      (add-to-list 'custom-theme-load-path "~/.emacs.d/zenburn-emacs/")
      (load-theme 'zenburn t)
      #+end_src

*** translucent
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; 当前窗口和非当前窗口时透明度
    (setq alpha-list '((85 60) (100 100)))
    (defun translucent ()
      (interactive)
      (let* ((h (car alpha-list))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))
            (setq alpha-list (cdr (append alpha-list (list h))))))

    (setq alpha-list-on '((85 60) (100 100)))
    (defun translucent-on ()
      (interactive)
      (let* ((h (car alpha-list-on))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

    (setq alpha-list-off '((100 100) (85 60)))
    (defun translucent-off ()
      (interactive)
      (let* ((h (car alpha-list-off))
             (a (car h))
             (ab (car (cdr h))))
            (set-frame-parameter (selected-frame) 'alpha (list a ab))
            (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

    ;; (translucent-on)
    (translucent-off)

    (global-set-key (kbd "<f12>") 'translucent)
    #+end_src

*** [not using] frame title
    * display buffer name or absolute file path name in the frame title
    #+begin_src emacs-lisp
    (defun frame-title-string ()
      "Return the file name of current buffer, using ~ if under home directory"
      (let
              ((fname (or
                       (buffer-file-name (current-buffer))
                       (buffer-name)))
               (max-len 100))
            (when (string-match (getenv "HOME") fname)
              (setq fname (replace-match "~" t t fname)))
            (if (> (length fname) max-len)
            (setq fname
                      (concat "..."
                              (substring fname (- (length fname) max-len)))))
            fname))
    ;; (setq frame-title-format '(:eval (frame-title-string)))
    (setq frame-title-format '("emacs-pirate@"(:eval (frame-title-string))))
    #+end_src

*** no-bother
    #+begin_src emacs-lisp :tangle ~/.emacs
    (mouse-avoidance-mode 'animate)
    (setq inhibit-startup-message t)
    (setq initial-scratch-message "")

    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)

    (fset 'yes-or-no-p 'y-or-n-p)
    #+end_src

*** cursor
    #+begin_src emacs-lisp :tangle ~/.emacs
    (blink-cursor-mode -1)

    ;; (set-frame-parameter nil 'cursor-type 'hollow)
    (set-frame-parameter nil 'cursor-type 'box)
    ;; (set-frame-parameter nil 'cursor-type 'bar)
    ;; (set-frame-parameter nil 'cursor-type '(bar . 2))
    ;; (set-frame-parameter nil 'cursor-type 'hbar)
    ;; (set-frame-parameter nil 'cursor-type '(hbar . 8))
    #+end_src

*** rainbow-delimiters
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/rainbow-delimiters/")
    (require 'rainbow-delimiters)

    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'lfe-mode-hook 'rainbow-delimiters-mode)

    ;; (add-hook 'cicada-mode-hook 'rainbow-delimiters-mode)

    ;; (global-rainbow-delimiters-mode)
    #+end_src

*** [not using] display
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (display-battery-mode t)
    ;; (display-time-mode t)
    #+end_src

*** symon                             :no:
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/symon/")
    (require 'symon)
    (symon-mode)
    #+end_src

*** fullscreen
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq frame-resize-pixelwise t)
    #+end_src

* emacs server & eshell

*** note
    * 需要與 bash 或 zsh 配合使用
      給 emacsclient 以 "e" 爲其別名
      並注意設置 emacsclient 的命令行參數
    * 但是如果先有一个 emacs-sever
      再打开 emacs 時 就会有警告
      我保留对这个警告的显示
      因为它提示了当前 emacs-sever 的开启状态
      (server-force-delete)
    * 因此常使用的方式是
      将(server-start)写在.emacs 中
      将 alias e='emacsclient -c -a "" -e \(eshell\)'写在.bashrc 中
      第一个 emacs 在终端中用 emacs 打开
      之后在终端中使用 e 就会以这个 emacs 为 sever
      退出这第一个 emacs 之后就会关闭被它打开的 emacs-sever

*** emacs server
    #+begin_src emacs-lisp :tangle ~/.emacs
    (server-start)
    ;; (setq server-name "><")
    ;; (server-force-delete)
    #+end_src

*** load-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/eshell/")
    #+end_src

*** hook
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook
     'eshell-mode-hook
     (lambda ()
       (local-set-key (kbd "C-c h")
                      (lambda ()
                            (interactive)
                            (insert
                             (ido-completing-read "eshell history: "
                                              (delete-dups
                                               (ring-elements eshell-history-ring))))))
       (local-set-key (kbd "C-c C-h") 'eshell-list-history)))
    #+end_src

*** note how to use

***** startup scripts
      *for i use org-mode, this is not very useful*
      like most shells,
      eshell supports both login and profile/rc shell scripts
      The full filepaths for both are stored in the variables
      eshell-login-script and eshell-rc-script
      but by default the files login and profile are stored in ~/.eshell/

      It bears mention that the comment syntax is #

***** jump
      it maintains a ring the last 32 directories seen.

      To view the ring: ‘cd =’
      Changing to an index within the ring: ‘cd -4’
      Note that ‘cd -’ is the same as ‘cd -0’
      Use a regular expression: ‘cd =regexp’

      The ring is saved in ‘~/.eshell/lastdir’.
      You can increase the ring size by setting ‘eshell-last-dir-ring-size’.
      Perhaps this is good enough for you, making autojump unnecessary.
      The only benefit autojump offers is that it sorts the entries
      by how often you switched there instead of when you switched there.

*** alias
    * the auto-correcting aliasing
      if you type an invalid command too many times
      (governed by eshell-bad-command-tolerance, which is 3 by default)
      Eshell will offer to alias it to its intended command for you
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; eshell will write the alias definitions to eshell-aliases-file
    (setq eshell-aliases-file "~/.emacs.d/eshell/alias")
    ;; which in turn is governed by the eshell-directory-name
    (setq eshell-directory-name "~/.emacs.d/eshell/")
    #+end_src

*** commands history
    * to use ido-completing-read to access to eshells history
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'eshell-mode-hook
                     (lambda ()
                       (local-set-key (kbd "M-<tab>") 'window->)))
    #+end_src

* make multi eshell work much easier

*** eshell/delete-char-or-kill-buffer
    1. (goto-char (point-max)) == (end-of-buffer)
    2. 在 emacs 中 efb 的识别方式有很多 比如:
       1. (eq (following-char) 0)
          (char-equal (following-char) 0)
       2. (eq (point-max) (point))
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun eshell/delete-char-or-kill-buffer ()
      (interactive)

      (point-to-register ?e)
      (eshell-bol)

      (if (eq (point-max) (point))
              (progn
            (kill-buffer)
            (delete-frame))
            (progn
              (jump-to-register ?e)
              (delete-char 1))))

    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-d") 'eshell/delete-char-or-kill-buffer)))
    #+end_src

*** eshell-prompt-function
    #+begin_src emacs-lisp :tangle ~/.emacs
    (set 'eshell-prompt-function
         (lambda ()
           (concat "\n"
                   (if (eq eshell-last-command-status 0)
                       ""
                       (number-to-string eshell-last-command-status))
                   "  "
                   (if (= (user-uid) 0)
                       "[root]  "
                       "")
                   (eshell/pwd)
                   "\n"
                   )))
    #+end_src

*** self-defun [before eshell]

***** my-cd-back
      #+begin_src emacs-lisp :tangle ~/.emacs
      (defun my-cd-back ()
        (interactive)
        (insert "cd ..")
        (eshell-send-input))
      (add-hook 'eshell-mode-hook
                (lambda ()
                      (local-set-key (kbd "<C-M-backspace>") 'my-cd-back)))
      #+end_src

***** rebinding normal move-beginning-of-line
      #+begin_src emacs-lisp :tangle ~/.emacs
      (add-hook 'eshell-mode-hook
                (lambda ()
                      (local-set-key (kbd "C-S-a") 'move-beginning-of-line)))
      #+end_src

*** [open|new]-eshell-for-frame
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; in ~/.xbindkeysrc.scm
    ;; I have the following
    ;; (xbindkey '(shift mod4 x) "LC_CTYPE=zh_CN.UTF-8 emacsclient -c -e \"(open-eshell-for-frame :on)\"")
    ;; (xbindkey '(mod4 t) "LC_CTYPE=zh_CN.UTF-8 emacsclient -t -e \"(open-eshell-for-frame :on)\"")

    (defun frame-eshell-name ()
      (concatenate 'string "eshell:" (frame-parameter nil 'name)))

    (defun open-eshell-for-frame (&optional translucent)
      (set-frame-parameter nil 'name (number-to-string (number-generator)))
      (let ((.buffer-name (frame-eshell-name)))
        (eshell t)
        (delete-region 1 (buffer-size))
        (insert "* (eshell)\n"
                "  eshell number " (frame-parameter nil 'name) "\n"
                "  the main eshell for this frame\n")
        (eshell-interrupt-process)
        (rename-buffer .buffer-name)
        (cond ((eq translucent :on) (translucent-on))
              ((eq translucent :off) (translucent-off))
              (:else :do-nothing))))

    ;; can be used in 'emacs -nw'
    (defun new-eshell-for-frame (&optional translucent)
      (interactive)
      (let* ((.sub-number-string (number-to-string (number-generator)))
             (.buffer-name (concatenate 'string (frame-eshell-name) ":" .sub-number-string)))
        (eshell t)
        (delete-region 1 (buffer-size))
        (insert "* (eshell)\n"
                "  eshell number " (frame-parameter nil 'name) "\n"
                "  eshell sub-number " .sub-number-string "\n"
                "  a sub eshell of this frame\n")
        (eshell-interrupt-process)
        (rename-buffer .buffer-name)))

    (global-set-key (kbd "C-s e") 'new-eshell-for-frame)
    #+end_src

*** my-switch-to-eshell
    * 下面是黄金搭档 previous-buffer
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-switch-to-eshell ()
      (interactive)
      (cond
        ((not (member-string? (frame-eshell-name) (mapcar 'buffer-name (buffer-list))))
         (open-eshell-for-frame))
        (:else
         (switch-to-buffer (frame-eshell-name))))
      (local-set-key (kbd "C-s C-e") 'previous-buffer))
    (global-set-key (kbd "C-s C-e") 'my-switch-to-eshell)
    #+end_src

*** init call to (open-eshell-for-frame)
    #+begin_src emacs-lisp :tangle ~/.emacs
    (open-eshell-for-frame :off)
    #+end_src

* chinese

*** pangu-spacing                     :no:
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/pangu-spacing/")
    (require 'pangu-spacing)
    (global-pangu-spacing-mode 1)
    (setq pangu-spacing-real-insert-separtor t)
    #+end_src
* exvm
*** load
    #+begin_src emacs-lisp :tangle no
    (add-to-list 'load-path "~/.emacs.d/elpa/packages/cl-generic/")
    (require 'cl-generic)
    (add-to-list 'load-path "~/.emacs.d/xelb/")
    (add-to-list 'load-path "~/.emacs.d/exwm/")
    (require 'exwm)
    (require 'exwm-config)
    ;; (exwm-config-default)

    ;; All buffers created in EXWM mode are named "*EXWM*". You may want to change
    ;; it in `exwm-update-class-hook' and `exwm-update-title-hook', which are run
    ;; when a new window class name or title is available. Here's some advice on
    ;; this subject:
    ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
    ;; + Only renaming buffer in one hook and avoid it in the other. There's no
    ;;   guarantee on the order in which they are run.
    ;; + For applications with multiple windows (e.g. GIMP), the class names of all
    ;;   windows are probably the same. Using window titles for them makes more
    ;;   sense.
    ;; + Some application change its title frequently (e.g. browser, terminal).
    ;;   Its class name may be more suitable for such case.
    ;; In the following example, we use class names for all windows expect for
    ;; Java applications and GIMP.
    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))

    ;; `exwm-input-set-key' allows you to set a global key binding (available in
    ;; any case). Following are a few examples.
    ;; + We always need a way to go back to line-mode from char-mode
    (exwm-input-set-key (kbd "s-r") 'exwm-reset)
    ;; + Bind a key to switch workspace interactively
    (exwm-input-set-key (kbd "s-n") 'exwm-workspace-switch)
    ;; + Set shortcuts to switch to a certain workspace.
    (exwm-input-set-key (kbd "s-0")
                        (lambda () (interactive) (exwm-workspace-switch 0)))
    (exwm-input-set-key (kbd "s-1")
                        (lambda () (interactive) (exwm-workspace-switch 1)))
    (exwm-input-set-key (kbd "s-2")
                        (lambda () (interactive) (exwm-workspace-switch 2)))
    (exwm-input-set-key (kbd "s-3")
                        (lambda () (interactive) (exwm-workspace-switch 3)))
    ;; + Application launcher ('M-&' also works if the output buffer does not
    ;;   bother you). Note that there is no need for processes to be created by
    ;;   Emacs.
    (exwm-input-set-key (kbd "s-&")
                        (lambda (command)
                          (interactive (list (read-shell-command "$ ")))
                          (start-process-shell-command command nil command)))
    ;; + 'slock' is a simple X display locker provided by suckless tools. 'i3lock'
    ;;   is a more feature-rich alternative.
    (exwm-input-set-key (kbd "s-<f2>")
                        (lambda () (interactive) (start-process "" nil "slock")))

    ;; The following example demonstrates how to set a key binding only available
    ;; in line mode. It's simply done by first push the prefix key to
    ;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
    ;; The example shorten 'C-c q' to 'C-q'.
    (push ?\C-q exwm-input-prefix-keys)
    (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

    ;; The following example demonstrates how to use simulation keys to mimic the
    ;; behavior of Emacs. The argument to `exwm-input-set-simulation-keys' is a
    ;; list of cons cells (SRC . DEST), where SRC is the key sequence you press and
    ;; DEST is what EXWM actually sends to application. Note that SRC must be a key
    ;; sequence (of type vector or string), while DEST can also be a single key.
    (exwm-input-set-simulation-keys
     '(([?\C-b] . left)
       ([?\C-f] . right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-v] . prior)
       ([?\C-v] . next)))

    ;; Do not forget to enable EXWM. It will start by itself when things are ready.
    (exwm-enable)
    #+end_src
