#+TITLE:  init emacs ^-^
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* ===================================
* note
  * keep it simple
  * try to do not change default key-binding
  * add a thing only when you really need it
* lib
** xyh-emacs-lib
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/xyh-emacs-lib/")
   (require 'xyh-emacs-lib)

   (global-set-key (kbd "M-u") 'move-line-backword)
   (global-set-key (kbd "M-i") 'move-line-foreword)
   (global-set-key (kbd "M-[") 'change-parentheses)
   #+end_src
** jump-to-register
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-.") 'ska-point-to-register)
   (global-set-key (kbd "C-,") 'ska-jump-to-register)
   (defun ska-point-to-register()
     "Store cursorposition _fast_ in a register.
   Use ska-jump-to-register to jump back to the stored
   position."
     (interactive)
     (setq zmacs-region-stays t)
     (point-to-register 8))

   (defun ska-jump-to-register()
     "Switches between current cursorposition and position
   that was stored with ska-point-to-register."
     (interactive)
     (setq zmacs-region-stays t)
     (let ((tmp (point-marker)))
           (jump-to-register 8)
           (set-register 8 tmp)))
   #+end_src
** go-to-char
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (string c1 ...)
   ;; concatenate all the argument characters
   ;; and make the result a string

   ;; (search-forward STRING &optional BOUND NOERROR COUNT)

   ;; (read-char &optional PROMPT INHERIT-INPUT-METHOD SECONDS)

   (defun go-to-char (n char)
         "Move forward to Nth occurence of CHAR.
   Typing `go-to-char-key' again will move forwad to the next Nth
   occurence of CHAR."
         (interactive "p\ncGo to char: ")
         (search-forward (string char) nil nil n)
         (while (char-equal (read-char) char)
           (search-forward (string char) nil nil n))
         (setq unread-command-events (list last-input-event)))

   (define-key global-map (kbd "C-c c") 'go-to-char)
   #+end_src
** my-quote
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; so here is a encoding for registers:
   ;; n-w
   ;; ==>
   ;; (+ (* 52 (- ?n ?A))
   ;;    (* (- ?w ?A)))

   (setq next-whitespace-register
             (+ (* 52 (- ?n ?A))
            (* (- ?w ?A))))
   (setq end-of-line-register
             (+ (* 52 52 (- ?e ?A))
            (* 52 (- ?o ?A))
            (* (- ?l ?A))))
   (setq my-word-quote-register
             (+ (* 52 52 (- ?m ?A))
            (* 52 (- ?w ?A))
            (* (- ?q ?A))))
   (defun next-whitespace ()
     (interactive)
     (let ((searching-for-next-whitespace
            (search-forward (string 32) nil t 1)))
           (left-char 1)
           (if (null searching-for-next-whitespace)
           'non-nil
             nil)))

   (defun my-word-quote ()
     "abc ==> ``abc''"
     (interactive)
     (progn
           (insert "`")
           (point-to-register my-word-quote-register)

           (if (null (next-whitespace))
           (point-to-register next-whitespace-register)
             ;; else there is no next-whitespace
             (set-register next-whitespace-register
                           ':no-next-whitespace:))

           (jump-to-register my-word-quote-register)

           (end-of-line)
           (point-to-register end-of-line-register)

           (cond ((eq (get-register next-whitespace-register)
                      ':no-next-whitespace:)
              (jump-to-register end-of-line-register)
              (insert "'"))
             (t;else
              (if (< (get-register next-whitespace-register)
                     (get-register end-of-line-register))
                      (jump-to-register next-whitespace-register)
                    (jump-to-register end-of-line-register))
              (insert "'")))

           (jump-to-register my-word-quote-register)
           ))
   (global-set-key (kbd "M-'") 'my-word-quote)


   (defun my-line-quote ()
     "abc 123 ==> ``abc 123''"
     (interactive)
     (progn
           (insert "``")
           (org-end-of-line)
           (insert "''")))
   (global-set-key (kbd "C-x M-'") 'my-line-quote)
   #+end_src
** key board macros
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-<C-f1> ()
     (interactive)
     (forward-word)
     (delete-char 1)
     (insert "-")
     )
   (global-set-key (kbd "<C-f1>") 'my-<C-f1>)

   (defun my-<C-f2> ()
     (interactive)
     (forward-word)
     (delete-char 1)
     (insert "_")
     )
   (global-set-key (kbd "<C-f2>") 'my-<C-f2>)
   #+end_src
** dash (needed by something)
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/package/dash/")
   (require 'dash)
   #+end_src
** epl (needed by something)
   Emacs Package Library
   #+begin_src emacs-lisp  :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/package/epl/")
   (require 'epl)
   #+end_src
** pkg-info (needed by something)
   #+begin_src emacs-lisp  :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/package/pkg-info/")
   (require 'pkg-info)
   #+end_src
** load xrdb
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun xrdb ()
     (interactive)
     (eshell-command "xrdb ~/.Xresource"))
   #+end_src
** load-path
   * path is loaded as much separately as possible
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/package/")
   #+end_src
* key binding
** unbinding
   #+begin_src emacs-lisp :tangle "~/.emacs"
   ;; orientally: transpose-words
   (global-set-key (kbd "M-t") 'nil)
   #+end_src
** prefix-command and examples
   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-prefix-command 'C-s-map)
   (global-set-key (kbd "C-s") 'C-s-map)
   ;; used by:
   ;; "C-s C-r" : rename-buffer
   ;; "C-s C-s" : org-edit-src-code
   ;; "C-s C-x" : switch-to-buffer-*scheme*
   ;; "C-s C-c" : switch-to-buffer-*haskell*
   ;; "C-s C-e" : my-switch-to-eshell
   #+end_src

   #+begin_src emacs-lisp
   (define-prefix-command '存-map)
   (global-set-key (kbd "存") '存-map)
   (define-key 存-map (kbd "盘") 'save-buffer)

   (define-prefix-command 'ctl-z-map)
   (define-prefix-command '存-map)
   (define-prefix-command '盘-map)

   (global-set-key (kbd "C-z") 'ctl-z-map)
   (define-key ctl-z-map (kbd "存") '存-map)
   (define-key 存-map (kbd "盘") '盘-map)

   (define-key 盘-map (kbd "！") 'save-buffer)
   (define-key 盘-map (kbd "到") 'write-file)
   (define-key 盘-map (kbd "退出")
     (lambda ()
           (interactive)
           (save-buffer)
           (kill-emacs)))
   #+end_src

** cruise
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun window-> () (interactive) (other-window +1))
   (defun <-window () (interactive) (other-window -1))

   ;; 没有使用<C-tab>
   ;; 因为<C-tab>需要在org-mode中使用
   ;; 因为按<tab>的时候可以不放开Ctrl是方便的
   (global-set-key (kbd "M-<tab>") 'window->)
   (global-set-key (kbd "M-=") 'window->)
   (global-set-key (kbd "M--") '<-window)
   ;; (global-set-key (kbd "M-0") 'window->)
   ;; (global-set-key (kbd "M-9") '<-window)

   (global-set-key (kbd "C-x .") 'next-buffer)
   (global-set-key (kbd "C-x ,") 'previous-buffer)

   (global-set-key (kbd "C-M-.") 'next-buffer)
   (global-set-key (kbd "C-M-,") 'previous-buffer)

   (global-set-key (kbd "M-p") 'backward-paragraph)
   (global-set-key (kbd "M-n") 'forward-paragraph)
   #+end_src
** window resizing
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-M-h") 'shrink-window-horizontally)
   (global-set-key (kbd "C-M-l") 'enlarge-window-horizontally)
   (global-set-key (kbd "C-M-j") 'shrink-window)
   (global-set-key (kbd "C-M-k") 'enlarge-window)
   #+end_src
** path
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "<C-M-return>") 'pwd)
   #+end_src
** line wrap
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-M-g") 'global-visual-line-mode)
   #+end_src
** comment
   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-prefix-command '<menu>-map)
   (global-set-key (kbd "<menu>") '<menu>-map)

   (global-set-key (kbd "<menu> '") 'comment-region)
   (global-set-key (kbd "<menu> ;") 'uncomment-region)
   #+end_src
** edit
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; backward-kill-sentence

   ;; (defun say-not-binding ()
   ;;   (interactive)
   ;;   (message "this key have not binding"))

   (global-set-key (kbd "C-x <backspace>") 'delete-backward-char)
   #+end_src
** view
   + 如果不左右scroll
     emacs就会自动为把长的行折反到视野中来(org-mode除外)
   + M-< : beginning-of-buffer
     M-> : end-of-buffer
     + 不要与下面的绑定混淆
       M-, : org-babel-previous-src-block
       M-. : org-babel-next-src-block
   + C-v : scroll-up-command
     M-v : scroll-down-command
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun scroll-right-as-my-wish ()
     (interactive)
     (scroll-left -1 1))
   (defun scroll-left-as-my-wish ()
     (interactive)
     (scroll-left 1 1))
   (global-set-key (kbd "<prior>") 'scroll-right-as-my-wish)
   (global-set-key (kbd "<next>") 'scroll-left-as-my-wish)
   (setq hscroll-step 1
             hscroll-margin 6)
   #+end_src
** search
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-t") 'isearch-forward)
   (add-hook 'isearch-mode-hook
             (lambda ()
                   (define-key isearch-mode-map (kbd "C-t") 'isearch-repeat-forward)
                   ))
   #+end_src
** query-replace
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "M-q") 'query-replace)
   #+end_src
** help
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-/") 'help)
   #+end_src
** rename-buffer
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-s C-r") 'rename-buffer)
   #+end_src
** insert (some trick here)
   can't bind C-M-i to new function in normal way

   and TAB == C-i

   one can find:
   (kbd "C-i") == (kbd "TAB") == "	"
   (kbd "C-M-i") == [134217737]
   in elisp-repl
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (define-key input-decode-map [?\C-i] [control-i])
   ;; (global-set-key [control-i] 'insert-newline-below)

   (define-key input-decode-map [134217737] [C-M-i])
   (global-set-key [C-M-i] 'insert-newline-below)

   (defun insert-newline-below ()
     (interactive)
     (insert "\n")
     (backward-char 1))
   #+end_src
* general setting
** variable
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq case-fold-search nil)
   (setq case-replace nil)
   (setq indent-tabs-mode nil)
   (setq-default indent-tabs-mode nil)
   ;; 全局设置上面的变量并没有用
   ;;   设想如果我能用一个树状图来清晰地描述mode之间的继承与依赖关系
   ;;   而不是只有简单的major和minor两个层次
   ;;   并且我能方便的浏览这个树
   ;;   能像操作一个列表一样方便的调整这个树
   ;; 写一个不光有更好配置语言的
   ;; 而且有更好的设计的文本编辑器也许并没有那么难
   (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))



   (transient-mark-mode t)

   (setq column-number-mode t)

   (setq mouse-yank-at-point t)

   (setq kill-ring-max 200)

   ;(setq enable-recursive-minibuffers t)

   (setq scroll-margin 4
             scroll-conservatively 10000)

   ;(setq default-major-mode 'org-mode)

   (show-paren-mode t)
   (setq show-paren-style 'parentheses)
   #+end_src
** enable disable
   #+begin_src emacs-lisp :tangle ~/.emacs
   (put 'set-goal-column 'disabled nil)
   (put 'narrow-to-region 'disabled nil)
   (put 'upcase-region 'disabled nil)
   (put 'downcase-region 'disabled nil)
   #+end_src
** simple version control
   #+begin_src emacs-lisp
   ;; to keep the *~ style backup
   ;; is to:
   (setq make-backup-files t)
   #+end_src

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq
    backup-by-copying t
    version-control t
    delete-old-versions t
    kept-new-versions 10
    kept-old-versions 0
    dired-kept-versions 1
    )
   #+end_src
** variable about mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq modes-about-lisp
             '(scheme-mode
           inferior-scheme-mode

           lisp-mode
           lisp-interaction-mode

           emacs-lisp-mode
           ielm-mode
           inferior-emacs-lisp-mode
           ))

   (setq modes-about-haskell
             '(haskell-mode
           inferior-haskell-mode
           ))

   (setq modes-about-C
             '(c-mode
           ))

   (setq modes-about-cicada
             '(cicada-mode
           inferior-cicada-mode
           ))
   #+end_src
* little input method
** note
   输入法和文本编辑器相辅相成同等重要
   emcas因一个bug而不能使用input method framework
   启动emcas前需要更改环境变量LC_CTYPE来弥补这个问题
   #+begin_src sh
   LC_CTYPE=zh_CN.UTF-8 emacs
   #+end_src

   #+begin_src sh
   export LC_CTYPE=zh_CN.UTF-8
   emacs &
   #+end_src

   有的时候能直接用
   有的时候必须要用上面的方法
** <f1>
   point-to-register: C-x r SPC
   jump-to-register: C-x r j
   get-register
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (define-prefix-command '<f1>-map)
   ;; (global-set-key (kbd "<f1>") '<f1>-map)


   (defun init-<f1> ()
     (interactive)
     (progn
           (cond ((memq major-mode modes-about-lisp)
              (init-<f1>-for-lisp))

             ((eq major-mode 'org-mode)
              ;; for i am a LISPer
              (init-<f1>-for-lisp))

             ((eq major-mode 'coq-mode)
              (init-<f1>-for-coq))

             ((memq major-mode modes-about-haskell)
              (init-<f1>-for-haskell))

             ((memq major-mode modes-about-C)
              (init-<f1>-for-C))

             ((eq major-mode 'caml-mode)
              (init-<f1>-for-caml))

             (t
              (message "<f1> have do nothing in this major mode"))

             )))

   (global-set-key (kbd "<f1>") 'init-<f1>)


   (defun insert-lambda () (interactive) (insert "lambda"))

   ;; first-order-logic
   (defun insert-∧ () (interactive) (insert "∧"))
   (defun insert-∨ () (interactive) (insert "∨"))
   (defun insert-¬ () (interactive) (insert "¬"))
   (defun insert-→ () (interactive) (insert "→"))
   (defun insert-← () (interactive) (insert "←"))
   (defun insert-↔ () (interactive) (insert "↔"))
   (defun insert-∃ () (interactive) (insert "∃"))
   (defun insert-∀ () (interactive) (insert "∀"))

   ;; set theory
   (defun insert-∈ () (interactive) (insert "∈"))
   (defun insert-⋶ () (interactive) (insert "⋶"))
   (defun insert-є () (interactive) (insert "є"))
   (defun insert-э () (interactive) (insert "э"))
   (defun insert-⊂ () (interactive) (insert "⊂"))
   (defun insert-⊃ () (interactive) (insert "⊃"))
   (defun insert-⊄ () (interactive) (insert "⊄"))
   (defun insert-⊅ () (interactive) (insert "⊅"))
   (defun insert-⊆ () (interactive) (insert "⊆"))
   (defun insert-⊇ () (interactive) (insert "⊇"))
   (defun insert-∩ () (interactive) (insert "∩"))
   (defun insert-∪ () (interactive) (insert "∪"))
   (defun insert-∅ () (interactive) (insert "∅"))

   ;; about function
   (defun insert-↤ () (interactive) (insert "↤"))
   (defun insert-↦ () (interactive) (insert "↦"))
   (defun insert-<- () (interactive) (insert "<-"))
   (defun insert--> () (interactive) (insert "->"))

   ;; proof theory
   (defun insert-≡ () (interactive) (insert "≡"))
   (defun insert-ͱ () (interactive) (insert "ͱ"))
   (defun insert-⊢ () (interactive) (insert "⊢"))
   (defun insert-⊦ () (interactive) (insert "⊦"))

   ;; _ and ^
   (defun insert-∞ () (interactive) (insert "∞"))
   (defun insert-√ () (interactive) (insert "√"))
   (defun insert-¿ () (interactive) (insert "¿"))
   (defun insert-° () (interactive) (insert "°"))

   ;; mics
   (defun insert-ߊ () (interactive) (insert "ߊ"))
   (defun insert-▓ () (interactive) (insert "▓"))

   (defun init-<f1>-for-lisp ()
     (interactive)
     (progn
           ;; 需要快捷输入lambda
           (local-set-key (kbd "<f1> <f1>") 'insert-lambda)

           ;; connectives
           (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
           (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
           (local-set-key (kbd "<f1> -") 'insert-¬);; negation
           (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
           (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
           ;; quantifiers
           (local-set-key (kbd "<f1> a") 'insert-∀);; all
           (local-set-key (kbd "<f1> e") 'insert-∃);; exist

           ;; set thoery
           (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
           (local-set-key (kbd "<f1> 0") 'insert-∅)
           (local-set-key (kbd "<f1> [") 'insert-⊂)
           (local-set-key (kbd "<f1> ]") 'insert-⊃)
           (local-set-key (kbd "<f1> u") 'insert-∪)
           (local-set-key (kbd "<f1> n") 'insert-∩)


           (local-set-key (kbd "<f1> k") 'insert-√);; check
           (local-set-key (kbd "<f1> =") 'insert-≡)
           (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

           ;; _ and ^
           (local-set-key (kbd "<f1> o") 'insert-°)
           (local-set-key (kbd "<f1> 9") 'insert-∞)
           ))


   (defun init-<f1>-for-haskell ()
     (interactive)
     (progn
           ;; 需要快捷输入->
           (local-set-key (kbd "<f1> <f1>") 'insert-->)

           ;; connectives
           (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
           (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
           (local-set-key (kbd "<f1> n") 'insert-¬);; negation
           (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
           (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
           ;; quantifiers
           (local-set-key (kbd "<f1> a") 'insert-∀);; all
           (local-set-key (kbd "<f1> e") 'insert-∃);; exist

           ;; set thoery
           (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
           (local-set-key (kbd "<f1> 0") 'insert-∅)
           (local-set-key (kbd "<f1> [") 'insert-⊂)
           (local-set-key (kbd "<f1> ]") 'insert-⊃)

           (local-set-key (kbd "<f1> k") 'insert-√);; check
           (local-set-key (kbd "<f1> =") 'insert-≡)
           (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

           ;; _ and ^
           (local-set-key (kbd "<f1> o") 'insert-°)
           ))


   (defun init-<f1>-for-C ()
      (interactive)
      (progn
            (local-set-key (kbd "<f1> <f1> <f1>")
                           (lambda ()
                             (interactive)
                             (insert "main ()\n{\n  \n}")
                             (left-char 2)))
            (local-set-key (kbd "<f1> <f1> f")
                           (lambda ()
                             (interactive)
                             ;; ?C == 67
                             (progn
                           (insert "for (")
                           (c-indent-line-or-region)
                           (point-to-register ?C)
                           (insert "; ; )\n;")
                           (c-indent-line-or-region)
                           (right-char 2)
                           (c-indent-line-or-region)
                           (jump-to-register ?C))))
            ;; (local-set-key (kbd "<f1> <f1> c")
            ;;                (lambda ()
            ;;                  (interactive)
            ;;                  ;; ?C == 67
            ;;                  (progn
            ;;                    (insert "for (")
            ;;                    (c-indent-line-or-region)
            ;;                    (point-to-register ?C)
            ;;                    (insert "; ; )\n;")
            ;;                    (c-indent-line-or-region)
            ;;                    (right-char 2)
            ;;                    (c-indent-line-or-region)
            ;;                    (jump-to-register ?C))))

            (local-set-key (kbd "<f1> <f1> i")
                           (lambda ()
                             (interactive)
                             (insert "# include <.h>")
                             (left-char 3)))
            (local-set-key (kbd "<f1> <f1> d")
                           (lambda ()
                             (interactive)
                             (insert "# define ")))
            (local-set-key (kbd "<f1> t")
                           ;; t denote type
                           (lambda ()
                             (interactive)
                             (insert "/* ")
                             (point-to-register ?t)
                             (insert " ::  <-  */\n")
                             (insert "/*\n")
                             (insert "  CREATE:\n\n")
                             (insert "  READ:\n\n")
                             (insert "  WRITE:\n\n")
                             (insert "*/\n")
                             (jump-to-register ?t)
                             ))

            ;; connectives
            (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
            (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
            (local-set-key (kbd "<f1> n") 'insert-¬);; negation
            (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
            (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
            ;; quantifiers
            (local-set-key (kbd "<f1> a") 'insert-∀);; all
            (local-set-key (kbd "<f1> e") 'insert-∃);; exist

            ;; set thoery
            (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
            (local-set-key (kbd "<f1> 0") 'insert-∅)
            (local-set-key (kbd "<f1> [") 'insert-⊂)
            (local-set-key (kbd "<f1> ]") 'insert-⊃)

            (local-set-key (kbd "<f1> k") 'insert-√);; check
            (local-set-key (kbd "<f1> =") 'insert-≡)
            (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

            ;; _ and ^
            (local-set-key (kbd "<f1> o") 'insert-°)
            ))

   (defun init-<f1>-for-coq ()
     (interactive)
     (progn
           (local-set-key (kbd "<f1> <f1>")
                           (lambda ()
                             (interactive)
                             (progn
                           (insert "Eval compute in\n")
                           (indent-for-tab-command))))
           (local-set-key (kbd "<f1> p")
                      (lambda ()
                             (interactive)
                             (progn
                           (insert "Proof.\n")
                           (indent-for-tab-command)
                           (point-to-register ?c)
                           (insert "\nQed.")
                           (jump-to-register ?c))))

           ;; connectives
           (local-set-key (kbd "<f1> c") 'insert-∧);; conjunction
           (local-set-key (kbd "<f1> d") 'insert-∨);; disjunction
           (local-set-key (kbd "<f1> n") 'insert-¬);; negation
           (local-set-key (kbd "<f1> <right>") 'insert-→);; implication
           (local-set-key (kbd "<f1> <S-right>") 'insert-↔);; equivalence
           ;; quantifiers
           (local-set-key (kbd "<f1> a") 'insert-∀);; all
           ;; (local-set-key (kbd "<f1> e") 'insert-∃);; exist

           ;; set thoery
           (local-set-key (kbd "<f1> b") 'insert-∈);; belong to
           (local-set-key (kbd "<f1> 0") 'insert-∅)
           (local-set-key (kbd "<f1> [") 'insert-⊂)
           (local-set-key (kbd "<f1> ]") 'insert-⊃)

           (local-set-key (kbd "<f1> k") 'insert-√);; check
           (local-set-key (kbd "<f1> =") 'insert-≡)
           (local-set-key (kbd "<f1> i") 'insert-ͱ);; inference

           ;; _ and ^
           (local-set-key (kbd "<f1> o") 'insert-°)
           ))


   (defun init-<f1>-for-caml ()
     (interactive)
     (progn
           ;; 需要快捷输入lambda
           (local-set-key (kbd "<f1> <f1>")
                      (lambda ()
                            (interactive)
                            (progn
                              (insert "function ")
                              (insert "(")
                              (point-to-register ?m)
                              (insert ")")
                              (caml-indent-command)
                              (insert "\n")
                              (insert "-> ")
                              (caml-indent-command)
                              (jump-to-register ?m))))

           ;; connectives
           (local-set-key (kbd "<f1> c") 'insert-∧)        ;; conjunction
           (local-set-key (kbd "<f1> d") 'insert-∨)        ;; disjunction
           (local-set-key (kbd "<f1> -") 'insert-¬)         ;; negation
           (local-set-key (kbd "<f1> <right>") 'insert-→)  ;; implication
           (local-set-key (kbd "<f1> <S-right>") 'insert-↔) ;; equivalence
           ;; quantifiers
           (local-set-key (kbd "<f1> a") 'insert-∀) ;; all
           (local-set-key (kbd "<f1> e") 'insert-∃) ;; exist

           ;; set thoery
           (local-set-key (kbd "<f1> b") 'insert-∈) ;; belong to
           (local-set-key (kbd "<f1> 0") 'insert-∅)
           (local-set-key (kbd "<f1> [") 'insert-⊂)
           (local-set-key (kbd "<f1> ]") 'insert-⊃)
           (local-set-key (kbd "<f1> u") 'insert-∪)
           (local-set-key (kbd "<f1> n") 'insert-∩)


           (local-set-key (kbd "<f1> k") 'insert-√) ;; check
           (local-set-key (kbd "<f1> =") 'insert-≡)
           (local-set-key (kbd "<f1> i") 'insert-ͱ) ;; inference

           ;; _ and ^
           (local-set-key (kbd "<f1> o") 'insert-°)
           (local-set-key (kbd "<f1> 9") 'insert-∞)
           ))
   #+end_src
** <f2>
   #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (define-prefix-command '<f2>-map)
    ;; (global-set-key (kbd "<f2>") '<f2>-map)

    (defun init-<f2> ()
          (interactive)
          (cond ((memq major-mode modes-about-lisp)
             (init-<f2>-for-lisp))

            ((memq major-mode modes-about-cicada)
             (init-<f2>-for-cicada))

            ((eq major-mode 'org-mode)
             ;; for i am a LISPer
             (init-<f2>-for-lisp))

            ((eq major-mode 'coq-mode)
             (init-<f2>-for-coq))

            ((eq major-mode 'caml-mode)
             (init-<f2>-for-caml))

            ((memq major-mode modes-about-haskell)
             (init-<f2>-for-haskell))

            (t
             (message "<f2> have do nothing in this major mode"))

            ))
   (global-set-key (kbd "<f2>") 'init-<f2>)


    (defun insert-α () (interactive) (insert "α"))
    (defun insert-β () (interactive) (insert "β"))
    (defun insert-γ () (interactive) (insert "γ"))
    (defun insert-δ () (interactive) (insert "δ"))
    (defun insert-ε () (interactive) (insert "ε"))
    (defun insert-θ () (interactive) (insert "θ"))
    (defun insert-Θ () (interactive) (insert "Θ"))
    (defun insert-ι () (interactive) (insert "ι"))
    (defun insert-κ () (interactive) (insert "κ"))
    (defun insert-λ () (interactive) (insert "λ"))
    (defun insert-Λ () (interactive) (insert "Λ"))
    (defun insert-σ () (interactive) (insert "σ"))
    (defun insert-ς () (interactive) (insert "ς"))
    (defun insert-Σ () (interactive) (insert "Σ"))
    (defun insert-τ () (interactive) (insert "τ"))
    (defun insert-ζ () (interactive) (insert "ζ"))
    (defun insert-ω () (interactive) (insert "ω"))
    (defun insert-Ω () (interactive) (insert "Ω"))
    (defun insert-π () (interactive) (insert "π"))
    (defun insert-Π () (interactive) (insert "Π"))
    (defun insert-ρ () (interactive) (insert "ρ"))
    (defun insert-φ () (interactive) (insert "φ"))
    (defun insert-Φ () (interactive) (insert "Φ"))
    (defun insert-υ () (interactive) (insert "υ"))
    (defun insert-ν () (interactive) (insert "ν"))
    (defun insert-χ () (interactive) (insert "χ"))
    (defun insert-Ψ () (interactive) (insert "Ψ"))
    (defun insert-ψ () (interactive) (insert "ψ"))
    (defun insert-μ () (interactive) (insert "μ"))
    (defun insert-η () (interactive) (insert "η"))
    (defun insert-Γ () (interactive) (insert "Γ"))
    (defun insert-Δ () (interactive) (insert "Δ"))
    (defun insert-ξ () (interactive) (insert "ξ"))
    (defun insert-Ξ () (interactive) (insert "Ξ"))

    (defun init-<f2>-for-lisp ()
          (interactive)
          (progn
            ;; 需要快捷输入λ
            (local-set-key (kbd "<f2> <f2>") 'insert-λ)

            (local-set-key (kbd "<f2> a") 'insert-α)
            (local-set-key (kbd "<f2> b") 'insert-β)
            (local-set-key (kbd "<f2> c") 'insert-γ)
            (local-set-key (kbd "<f2> C") 'insert-Γ)
            (local-set-key (kbd "<f2> g") 'insert-γ)
            (local-set-key (kbd "<f2> G") 'insert-Γ)
            (local-set-key (kbd "<f2> d") 'insert-δ)
            (local-set-key (kbd "<f2> D") 'insert-Δ)
            (local-set-key (kbd "<f2> e") 'insert-ε)
            (local-set-key (kbd "<f2> f") 'insert-φ)
            (local-set-key (kbd "<f2> F") 'insert-Φ)
            ;; th = Θ, θ
            (local-set-key (kbd "<f2> h") 'insert-θ)
            (local-set-key (kbd "<f2> H") 'insert-Θ)
            (local-set-key (kbd "<f2> i") 'insert-η)
            ;;(local-set-key (kbd "<f2> i") 'insert-ι)
            (local-set-key (kbd "<f2> k") 'insert-κ)
            (local-set-key (kbd "<f2> l") 'insert-λ)
            (local-set-key (kbd "<f2> L") 'insert-Λ)
            (local-set-key (kbd "<f2> m") 'insert-μ)
            (local-set-key (kbd "<f2> n") 'insert-ν)
            (local-set-key (kbd "<f2> o") 'insert-ω)
            (local-set-key (kbd "<f2> O") 'insert-Ω)
            (local-set-key (kbd "<f2> p") 'insert-π)
            (local-set-key (kbd "<f2> P") 'insert-Π)
            (local-set-key (kbd "<f2> r") 'insert-ρ)
            (local-set-key (kbd "<f2> s") 'insert-σ)
            ;; final sigma
            ;;(local-set-key (kbd "<f2> s") 'insert-ς)
            (local-set-key (kbd "<f2> S") 'insert-Σ)
            (local-set-key (kbd "<f2> t") 'insert-τ)
            (local-set-key (kbd "<f2> u") 'insert-υ)
            (local-set-key (kbd "<f2> v") nil)
            (local-set-key (kbd "<f2> x") 'insert-ξ)
            (local-set-key (kbd "<f2> X") 'insert-Ξ)
            ;; ps = ψ, Ψ
            (local-set-key (kbd "<f2> y") 'insert-Ψ)
            (local-set-key (kbd "<f2> Y") 'insert-ψ)
            (local-set-key (kbd "<f2> z") 'insert-ζ)
            ))

   (defun init-<f2>-for-cicada ()
          (interactive)
          (progn
            ;; 需要快捷输入λ
            (local-set-key (kbd "<f2> <f2>") 'insert-λ)

            (local-set-key (kbd "<f2> a") 'insert-α)
            (local-set-key (kbd "<f2> b") 'insert-β)
            (local-set-key (kbd "<f2> c") 'insert-γ)
            (local-set-key (kbd "<f2> C") 'insert-Γ)
            (local-set-key (kbd "<f2> g") 'insert-γ)
            (local-set-key (kbd "<f2> G") 'insert-Γ)
            (local-set-key (kbd "<f2> d") 'insert-δ)
            (local-set-key (kbd "<f2> D") 'insert-Δ)
            (local-set-key (kbd "<f2> e") 'insert-ε)
            (local-set-key (kbd "<f2> f") 'insert-φ)
            (local-set-key (kbd "<f2> F") 'insert-Φ)
            ;; th = Θ, θ
            (local-set-key (kbd "<f2> h") 'insert-θ)
            (local-set-key (kbd "<f2> H") 'insert-Θ)
            (local-set-key (kbd "<f2> i") 'insert-η)
            ;;(local-set-key (kbd "<f2> i") 'insert-ι)
            (local-set-key (kbd "<f2> k") 'insert-κ)
            (local-set-key (kbd "<f2> l") 'insert-λ)
            (local-set-key (kbd "<f2> L") 'insert-Λ)
            (local-set-key (kbd "<f2> m") 'insert-μ)
            (local-set-key (kbd "<f2> n") 'insert-ν)
            (local-set-key (kbd "<f2> o") 'insert-ω)
            (local-set-key (kbd "<f2> O") 'insert-Ω)
            (local-set-key (kbd "<f2> p") 'insert-π)
            (local-set-key (kbd "<f2> P") 'insert-Π)
            (local-set-key (kbd "<f2> r") 'insert-ρ)
            (local-set-key (kbd "<f2> s") 'insert-σ)
            ;; final sigma
            ;;(local-set-key (kbd "<f2> s") 'insert-ς)
            (local-set-key (kbd "<f2> S") 'insert-Σ)
            (local-set-key (kbd "<f2> t") 'insert-τ)
            (local-set-key (kbd "<f2> u") 'insert-υ)
            (local-set-key (kbd "<f2> v") nil)
            (local-set-key (kbd "<f2> x") 'insert-ξ)
            (local-set-key (kbd "<f2> X") 'insert-Ξ)
            ;; ps = ψ, Ψ
            (local-set-key (kbd "<f2> y") 'insert-Ψ)
            (local-set-key (kbd "<f2> Y") 'insert-ψ)
            (local-set-key (kbd "<f2> z") 'insert-ζ)
            ))



    (defun init-<f2>-for-haskell ()
          (interactive)
          (progn
            ;; 需要快捷输入λ
            (local-set-key (kbd "<f2> <f2>") (lambda ()
                                           (interactive)
                                           (insert "(\\ -> )")
                                           (left-char 5)))
            (local-set-key (kbd "<f2> <right>") (lambda ()
                                                  (interactive)
                                                  (insert "->")))
            (local-set-key (kbd "<f2> <left>") (lambda ()
                                             (interactive)
                                             (insert "<-")))

            (local-set-key (kbd "<f2> a") 'insert-α)
            (local-set-key (kbd "<f2> b") 'insert-β)
            (local-set-key (kbd "<f2> c") 'insert-γ)
            (local-set-key (kbd "<f2> C") 'insert-Γ)
            (local-set-key (kbd "<f2> g") 'insert-γ)
            (local-set-key (kbd "<f2> G") 'insert-Γ)
            (local-set-key (kbd "<f2> d") 'insert-δ)
            (local-set-key (kbd "<f2> D") 'insert-Δ)
            (local-set-key (kbd "<f2> e") 'insert-ε)
            (local-set-key (kbd "<f2> f") 'insert-φ)
            (local-set-key (kbd "<f2> F") 'insert-Φ)
            ;; th = Θ, θ
            (local-set-key (kbd "<f2> h") 'insert-θ)
            (local-set-key (kbd "<f2> H") 'insert-Θ)
            (local-set-key (kbd "<f2> i") 'insert-η)
            ;;(local-set-key (kbd "<f2> i") 'insert-ι)
            (local-set-key (kbd "<f2> k") 'insert-κ)
            (local-set-key (kbd "<f2> l") 'insert-λ)
            (local-set-key (kbd "<f2> L") 'insert-Λ)
            (local-set-key (kbd "<f2> m") 'insert-μ)
            (local-set-key (kbd "<f2> n") 'insert-ν)
            (local-set-key (kbd "<f2> o") 'insert-ω)
            (local-set-key (kbd "<f2> O") 'insert-Ω)
            (local-set-key (kbd "<f2> p") 'insert-π)
            (local-set-key (kbd "<f2> P") 'insert-Π)
            (local-set-key (kbd "<f2> r") 'insert-ρ)
            (local-set-key (kbd "<f2> s") 'insert-σ)
            ;; final sigma
            ;;(local-set-key (kbd "<f2> s") 'insert-ς)
            (local-set-key (kbd "<f2> S") 'insert-Σ)
            (local-set-key (kbd "<f2> t") 'insert-τ)
            (local-set-key (kbd "<f2> u") 'insert-υ)
            (local-set-key (kbd "<f2> v") nil)
            (local-set-key (kbd "<f2> x") 'insert-ξ)
            (local-set-key (kbd "<f2> X") 'insert-Ξ)
            ;; ps = ψ, Ψ
            (local-set-key (kbd "<f2> y") 'insert-Ψ)
            (local-set-key (kbd "<f2> Y") 'insert-ψ)
            (local-set-key (kbd "<f2> z") 'insert-ζ)
            ))


    (defun init-<f2>-for-coq ()
          (interactive)
          (progn
            ;; 需要快捷输入λ
            (local-set-key (kbd "<f2> <f2>") 'insert-λ)

            (local-set-key (kbd "<f2> a") 'insert-α)
            (local-set-key (kbd "<f2> b") 'insert-β)
            (local-set-key (kbd "<f2> c") 'insert-γ)
            (local-set-key (kbd "<f2> C") 'insert-Γ)
            (local-set-key (kbd "<f2> g") 'insert-γ)
            (local-set-key (kbd "<f2> G") 'insert-Γ)
            (local-set-key (kbd "<f2> d") 'insert-δ)
            (local-set-key (kbd "<f2> D") 'insert-Δ)
            (local-set-key (kbd "<f2> e") 'insert-ε)
            (local-set-key (kbd "<f2> f") 'insert-φ)
            (local-set-key (kbd "<f2> F") 'insert-Φ)
            ;; th = Θ, θ
            (local-set-key (kbd "<f2> h") 'insert-θ)
            (local-set-key (kbd "<f2> H") 'insert-Θ)
            (local-set-key (kbd "<f2> i") 'insert-η)
            ;;(local-set-key (kbd "<f2> i") 'insert-ι)
            (local-set-key (kbd "<f2> k") 'insert-κ)
            (local-set-key (kbd "<f2> l") 'insert-λ)
            (local-set-key (kbd "<f2> L") 'insert-Λ)
            (local-set-key (kbd "<f2> m") 'insert-μ)
            (local-set-key (kbd "<f2> n") 'insert-ν)
            (local-set-key (kbd "<f2> o") 'insert-ω)
            (local-set-key (kbd "<f2> O") 'insert-Ω)
            (local-set-key (kbd "<f2> p") 'insert-π)
            (local-set-key (kbd "<f2> P") 'insert-Π)
            (local-set-key (kbd "<f2> r") 'insert-ρ)
            (local-set-key (kbd "<f2> s") 'insert-σ)
            ;; final sigma
            ;;(local-set-key (kbd "<f2> s") 'insert-ς)
            (local-set-key (kbd "<f2> S") 'insert-Σ)
            (local-set-key (kbd "<f2> t") 'insert-τ)
            (local-set-key (kbd "<f2> u") 'insert-υ)
            (local-set-key (kbd "<f2> v") nil)
            (local-set-key (kbd "<f2> x") 'insert-ξ)
            (local-set-key (kbd "<f2> X") 'insert-Ξ)
            ;; ps = ψ, Ψ
            (local-set-key (kbd "<f2> y") 'insert-Ψ)
            (local-set-key (kbd "<f2> Y") 'insert-ψ)
            (local-set-key (kbd "<f2> z") 'insert-ζ)
            ))


   (defun init-<f2>-for-caml ()
          (interactive)
          (progn
            (local-set-key (kbd "<f2> <f2>")
                           (lambda ()
                            (interactive)
                            (progn
                          (insert "| ")
                          (insert "(")
                          (point-to-register ?m)
                          (insert ")")
                          (caml-indent-command)
                          (insert "\n")
                          (insert "-> ")
                          (caml-indent-command)
                          (jump-to-register ?m))))

            (local-set-key (kbd "<f2> a") 'insert-α)
            (local-set-key (kbd "<f2> b") 'insert-β)
            (local-set-key (kbd "<f2> c") 'insert-γ)
            (local-set-key (kbd "<f2> C") 'insert-Γ)
            (local-set-key (kbd "<f2> g") 'insert-γ)
            (local-set-key (kbd "<f2> G") 'insert-Γ)
            (local-set-key (kbd "<f2> d") 'insert-δ)
            (local-set-key (kbd "<f2> D") 'insert-Δ)
            (local-set-key (kbd "<f2> e") 'insert-ε)
            (local-set-key (kbd "<f2> f") 'insert-φ)
            (local-set-key (kbd "<f2> F") 'insert-Φ)
            ;; th = Θ, θ
            (local-set-key (kbd "<f2> h") 'insert-θ)
            (local-set-key (kbd "<f2> H") 'insert-Θ)
            (local-set-key (kbd "<f2> i") 'insert-η)
            ;;(local-set-key (kbd "<f2> i") 'insert-ι)
            (local-set-key (kbd "<f2> k") 'insert-κ)
            (local-set-key (kbd "<f2> l") 'insert-λ)
            (local-set-key (kbd "<f2> L") 'insert-Λ)
            (local-set-key (kbd "<f2> m") 'insert-μ)
            (local-set-key (kbd "<f2> n") 'insert-ν)
            (local-set-key (kbd "<f2> o") 'insert-ω)
            (local-set-key (kbd "<f2> O") 'insert-Ω)
            (local-set-key (kbd "<f2> p") 'insert-π)
            (local-set-key (kbd "<f2> P") 'insert-Π)
            (local-set-key (kbd "<f2> r") 'insert-ρ)
            (local-set-key (kbd "<f2> s") 'insert-σ)
            ;; final sigma
            ;;(local-set-key (kbd "<f2> s") 'insert-ς)
            (local-set-key (kbd "<f2> S") 'insert-Σ)
            (local-set-key (kbd "<f2> t") 'insert-τ)
            (local-set-key (kbd "<f2> u") 'insert-υ)
            (local-set-key (kbd "<f2> v") nil)
            (local-set-key (kbd "<f2> x") 'insert-ξ)
            (local-set-key (kbd "<f2> X") 'insert-Ξ)
            ;; ps = ψ, Ψ
            (local-set-key (kbd "<f2> y") 'insert-Ψ)
            (local-set-key (kbd "<f2> Y") 'insert-ψ)
            (local-set-key (kbd "<f2> z") 'insert-ζ)
            ))
   #+end_src
* language
** ----------------------------------
** load progmodes
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/progmodes/")
   #+end_src
** ----------------------------------
** repl-space
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/repl-space/")
   (require 'repl-space)
   #+end_src
** ----------------------------------
** edit sexp
*** load-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/edit-sexp/")
    #+end_src
*** mark and cruise
    the follow functions are belong to lisp.el
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "s-z") 'mark-defun)
    (global-set-key (kbd "s-a") 'mark-sexp)

    (global-set-key (kbd "s-w") 'backward-sexp)
    (global-set-key (kbd "s-s") 'forward-sexp)

    (defun in-> () (interactive) (down-list))
    (global-set-key (kbd "s-e") 'in->)

    (defun <-out () (interactive) (backward-up-list))
    (global-set-key (kbd "s-q") '<-out)

    (defun out-> () (interactive) (up-list))
    (global-set-key (kbd "s-d") 'out->)

    ;; the following is for emacs-nox which can not see s-
    (define-key input-decode-map [134217825] [M-a])
    (global-set-key [M-a] 'mark-sexp)

    ;; (global-set-key (kbd "C-M-p") 'backward-sexp)
    ;; (global-set-key (kbd "C-M-n") 'forward-sexp)

    ;; (global-set-key (kbd "C-M-f") 'in->)

    ;; (global-set-key (kbd "C-M-b") '<-out)
    #+end_src
*** paredit
    file:~/.emacs.d/edit-sexp/paredit.el
    #+begin_src emacs-lisp :tangle ~/.emacs
    (autoload 'enable-paredit-mode
      "paredit"
      "Turn on pseudo-structural editing of Lisp code." t)

    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    (add-hook 'inferior-scheme-mode-hook  #'enable-paredit-mode)

    (add-hook 'racket-repl-mode-hook      #'enable-paredit-mode)
    (add-hook 'racket-mode-hook           #'enable-paredit-mode)


    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'slime-repl-mode-hook       #'enable-paredit-mode)
    (add-hook 'slime-mode-hook            #'enable-paredit-mode)



    (add-hook 'lfe-mode-hook              #'enable-paredit-mode)
    (add-hook 'inferior-lfe-mode-hook     #'enable-paredit-mode)

    (add-hook 'shen-mode-hook             #'enable-paredit-mode)
    (add-hook 'inferior-shen-mode-hook    #'enable-paredit-mode)

    (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
    (add-hook 'cider-repl-mode-hook       #'enable-paredit-mode)


    ;; (add-hook 'ielm-mode-hook             #'enable-paredit-mode)

    ;; the following is about the *scratch* buffer
    ;; (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    ;; 不知道为什么这里就算使用maybe-map-paredit-newline也总是绑定不到 RET
    ;; 只有在下面的mode中不使用enable-paredit-mode
    ;; *scratch* buffer中的RET才能正常
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)


    (add-hook 'coq-mode-hook              #'enable-paredit-mode)

    ;; (add-hook 'haskell-mode-hook          #'enable-paredit-mode)

    ;; (add-hook 'c-mode-hook                #'enable-paredit-mode)


    (defun maybe-map-paredit-newline ()
      (cond
       ((memq major-mode '(inferior-scheme-mode
                               inferior-shen-mode
                               inferior-emacs-lisp-mode
                               lisp-interaction-mode
                               inferior-haskell-mode))
            (local-set-key (kbd "RET") 'comint-send-input))
       ((memq major-mode '(scheme-mode
                               emacs-lisp-mode
                               lisp-mode
                               lisp-interaction-mode))
            (local-set-key (kbd "RET") 'paredit-newline))
       ))
    (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

    ;; for i want to use paredit a lot of place out of LISP
    ;; i comment out the binding of:
    ;; ";" -> paredit-semicolon
    ;; "M-;" -> paredit-comment-dwim
    ;; in the paredit.el
    (defun maybe-map-paredit-semicolon ()
      (cond
       ((memq major-mode modes-about-lisp)
            (progn
              (local-set-key (kbd ";") 'paredit-semicolon)
              (local-set-key (kbd "M-;") 'paredit-comment-dwim)))
       ))
    (add-hook 'paredit-mode-hook 'maybe-map-paredit-semicolon)
    #+end_src
*** >< a easier way to insert "(" ")" (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (defun my-insert-9 () (interactive) (insert "9"))
    (defun my-insert-0 () (interactive) (insert "0"))

    (add-hook 'scheme-mode-hook
              (lambda ()
                    (local-set-key (kbd "9") 'paredit-open-round)
                    (local-set-key (kbd "0") 'paredit-close-round)
                    (local-set-key (kbd "(") 'my-insert-9)
                    (local-set-key (kbd ")") 'my-insert-0)
                    ))
    #+end_src
*** >< mini-parentheses-editor
    parentheses /pəˈrɛnθəsiːz/
    is plural form of parenthesis /pəˈrɛnθəsɪs/

    下面这些函数并不是全局可见的
    但是只要paredit被load一次之后就可以使用了
    而路过org-mode中的lisp代码块的时候paredit就能被load到
    而我几乎总是会路过这种代码块的

    下面的绑定有的时候会以不明显地方式改变 org-mode 中文本的内容
    所以 暂时不用了
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (global-set-key (kbd "M-(")         'paredit-wrap-round)
    ;; (global-set-key (kbd "M-s")         'paredit-splice-sexp)
    ;; (global-set-key (kbd "M-r")         'paredit-raise-sexp)
    (global-set-key (kbd "<C-right>")   'paredit-forward-slurp-sexp)
    (global-set-key (kbd "<C-left>")    'paredit-forward-barf-sexp)
    (global-set-key (kbd "M-\"")        'paredit-meta-doublequote)
    (global-set-key (kbd "<C-M-right>") 'paredit-backward-barf-sexp)
    (global-set-key (kbd "<C-M-left>")  'paredit-backward-slurp-sexp)
    ;; (global-set-key (kbd "C-d")         'paredit-forward-delete)
    ;; (global-set-key (kbd "<backspace>") 'paredit-backward-delete)
    ;; (global-set-key (kbd "C-k")         'paredit-kill)
    #+end_src
*** >< paredit-everywhere
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (require 'mini-paredit)

    (add-hook 'haskell-mode-hook            'mini-paredit-mode)
    (add-hook 'inferior-haskell-mode-hook   'mini-paredit-mode)

    (add-hook 'c-mode-hook                  'mini-paredit-mode)

    (add-hook 'coq-mode-hook                'mini-paredit-mode)

    (add-hook 'lua-mode-hook                'mini-paredit-mode)

    (add-hook 'sml-mode-hook                'mini-paredit-mode)
    #+end_src
*** >< experiment
    1. 从simple.el中可以学到很多
       file:/usr/local/share/emacs/24.3/lisp/simple.el.gz
       尤其是当找到一个函数是在这里定义的时候

    下面是三组有用的函数
    其中what-cursor-position是在simple.el中定义的
    #+begin_src emacs-lisp
    (looking-at "")
    (what-cursor-position)
    (insert (what-cursor-position))
    (setq kkk (what-cursor-position))
    (insert kkk)

    (following-char)
    (memq 67 '("C"))
    (char-to-string 67)

    (point)

    (message "kkk")
    #+end_src
** scheme and other LISP
*** load-path
    some scheme related files are under this dir
    for hack
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/scheme/")
    (add-to-list 'load-path "~/.emacs.d/scheme/cmuscheme-init-repl/")
    #+end_src
*** scheme-mode
    file used by cmuscheme to init a *scheme* buffer
    for a prescribed interpreter's repl

    one can change the directory to save these files
    by editing the function ``scheme-start-file'' in cmuscheme.el
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-ikarus.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-csi.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-guile.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-petite.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-racket.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-mit-scheme.scm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'cmuscheme)

    (setq scheme-program-name "ikarus")

    (defun switch-to-buffer-*scheme* ()
      (interactive)
      (switch-to-scheme 1);; (switch-to-buffer "*scheme*")
      (local-set-key (kbd "C-s C-x") 'previous-buffer))
    (global-set-key (kbd "C-s C-x") 'switch-to-buffer-*scheme*)

    (defun split-window-with-named-buffer (buffer-name-string)
      (interactive)
      (cond
       ((= 1 (count-windows))
            (progn
              ;; 下面这两个的组合总能行为正确
              (split-window-vertically (floor (* 0.68 (window-height))))
              (other-window 1)
              (switch-to-buffer buffer-name-string)
              (other-window -1)))

       ;; 只允许出现一个scheme窗口
       ;; 因此当发现有别的窗口的时候就在那个窗口中打开所需要的buffer
       ((not (cl-find buffer-name-string
                  (mapcar (lambda (w) (buffer-name (window-buffer w)))
                          (window-list))
                  :test 'equal))
            (progn
              (other-window 1)
              (switch-to-buffer buffer-name-string)
              (other-window -1)))))

    (defun scheme-send-last-sexp-split-window ()
      (interactive)
      (scheme-send-last-sexp)
      (split-window-with-named-buffer "*scheme*"))

    (defun scheme-send-definition-split-window ()
      (interactive)
      (scheme-send-definition)
      (split-window-with-named-buffer "*scheme*"))

    (add-hook
     'scheme-mode-hook
     (lambda ()
       (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
       (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
       ))
    #+end_src
*** scheme-here
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'scheme-here)
    (add-hook 'inferior-scheme-mode-hook
              (lambda ()
                    (define-key scheme-mode-map (kbd "C-s C-a") 'scheme-here-send-sexp)))
    #+end_src
*** parenface (not using)
    i actually like these parentheses
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (require 'parenface)
    (set-face-foreground 'paren-face "DimGray")
    #+end_src
*** pretty-lambdas-for-lisp (not using)
    * not using
      for no good font
    #+begin_src emacs-lisp
    (defun pretty-lambdas-for-lisp ()
      (interactive)
      (font-lock-add-keywords
       nil `(("(\\(lambda\\>\\)"
              (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                            993
                                            ;; 923 : Λ
                                            ;; 955 : λ
                                            ;; 411 : ƛ
                                            ;; 654 : ʎ
                                            ;; 992 : Ϡ
                                            ;; 993 : ϡ
                                            )
                            nil))))))


    (add-hook 'scheme-mode-hook
              'pretty-lambdas-for-lisp)
    (add-hook 'inferior-scheme-mode-hook
              'pretty-lambdas-for-lisp)

    (add-hook 'emacs-lisp-mode-hook
              'pretty-lambdas-for-lisp)
    (add-hook 'ielm-mode-hook
              'pretty-lambdas-for-lisp)

    (add-hook 'lisp-mode-hook
              'pretty-lambdas-for-lisp)
    (add-hook 'lisp-interaction-mode-hook
              'pretty-lambdas-for-lisp)

    (add-hook 'org-mode-hook
              'pretty-lambdas-for-lisp)
    #+end_src
** scheme-add-keywords
   设计良好的高亮与缩进很重要
   它可以增加代码的可读性
   并帮助检查代码的部分错误
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; 下面的实现方式并不完备
   ;; scheme-mode中原本的实现不是如此
   (defun scheme-add-keywords (face-name keyword-rules)
     (let* ((keyword-list (mapcar #'(lambda (x)
                                      (symbol-name (cdr x)))
                                      keyword-rules))
            (keyword-regexp (concat "(\\("
                                    (regexp-opt keyword-list)
                                    "\\)[ \n]")))
           (font-lock-add-keywords 'scheme-mode
                                   `((,keyword-regexp 1 ',face-name))))
     (mapc #'(lambda (x)
                   (put (cdr x)
                    'scheme-indent-function
                    (car x)))
           keyword-rules))
   ;; 前面的数字被认为是参数项的个数
   ;; 参数项完全换行时强缩进 其他项弱缩进
   ;; 非语法关键词 所有项在完全换行时都不缩进
   (scheme-add-keywords
     'font-lock-keyword-face
     '(
           ;; 下面scheme中需要高亮的词
           (0 . set!)
           (0 . set-car!)
           (0 . set-cdr!)
           (0 . vector-set!)
           (1 . quote)
           (1 . quasiquote)
           (1 . unquote)
           (1 . if)
           (1 . apply)
           (1 . letrec*)
           (1 . while)
           ;; 来自扩展的
           (1 . letcc)
           (1 . pmatch)
           (2 . pmatch-who)
           (0 . guard)
           (0 . add-to-list!)
           (0 . add-to-list-end!)
           (0 . append!)
           (0 . insert-a-val-to-a-field-of-a-wlist!)
           (0 . to-a-field-of-a-wlist--let-us-insert-a-val!)

           ;; 来自ikarus
           (1 . make-parameter)
           (1 . parameterize)

           ;; 下面scheme中我还没用到以后可能需要高亮的词
           (1 . when)
           (1 . unless)
           (2 . let1)
           (1 . error)

           ;; 下面是我的解释器中需要高亮的词
           (1 . λ)
           (0 . begin*)
           (1 . def)
           (1 . doc)
           (2 . rewrite-doc)

           ;; 下面是 /home/xyh/scheme-toys/~.scm 中需要高亮的词
           (1 . ~?)
           (1 . ~)
           (0 . ~+~)
           (2 . ~map)
           (1 . ~fun+)
           (1 . copy~)
           (1 . <~!)
           (1 . <~)
           (1 . take~)

           ;; 下面是mk中需要高亮的词
           ;; core:
           ;; Logical operators:
           (2 . ==)
           (1 . fresh)
           (0 . conde)
           ;; Interface operators:
           (2 . run)
           (1 . run*)

           ;; 下面是mk的元代码中需要高亮的词
           ;; [(lambdag@ (p) e) (lambda (p) e)]
           ;; (1 . lambdag@)
           ;; [(lambdaf@ () e) (lambda () e)]
           ;; (1 . lambdaf@)

           (1 . λᴳ)
           (1 . λ~)

           ;;
           (0 . set-pointer!)
           (1 . define-pointer)
           ;; 下面是vvv-mimic-ccc.scm中需要高亮的词
           (0 . vons)
           (0 . vnr)
           (0 . v0r)
           (0 . v1r)
           (0 . v2r)
           (0 . v3r)
           (0 . v4r)
           (0 . v5r)
           (0 . v6r)
           (0 . v7r)
           (0 . v8r)
           (0 . v9r)
           (0 . set-vnr!)
           (0 . set-v0r!)
           (0 . set-v1r!)
           (0 . set-v2r!)
           (0 . set-v3r!)
           (0 . set-v4r!)
           (0 . set-v5r!)
           (0 . set-v6r!)
           (0 . set-v7r!)
           (0 . set-v8r!)
           (0 . set-v9r!)

           (0 . vonz)
           (0 . vnz)
           (0 . v0z)
           (0 . v1z)
           (0 . v2z)
           (0 . v3z)
           (0 . v4z)
           (0 . v5z)
           (0 . v6z)
           (0 . v7z)
           (0 . v8z)
           (0 . v9z)
           (0 . set-vnz!)
           (0 . set-v0z!)
           (0 . set-v1z!)
           (0 . set-v2z!)
           (0 . set-v3z!)
           (0 . set-v4z!)
           (0 . set-v5z!)
           (0 . set-v6z!)
           (0 . set-v7z!)
           (0 . set-v8z!)
           (0 . set-v9z!)

           (0 . conz)
           (0 . caz)
           (0 . cdz)
           (0 . set-caz!)
           (0 . set-cdz!)

           ;; 其它可能临时用到的高亮
           (0 . *λ)
           (0 . *l)

           ;; 我练习写解释器所需要的高亮
           (1 . define-primitive)
           ))
   #+end_src
** racket
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/racket-mode/")
   (require 'racket-mode)
   #+end_src
** ----------------------------------
** common lisp
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (setq inferior-lisp-program "/usr/local/bin/clisp")
   ;; (setq inferior-lisp-program "/usr/local/bin/sbcl")
   ;; (setq inferior-lisp-program "/usr/local/bin/sbcl --dynamic-space-size 1000")
   ;; (setq inferior-lisp-program "/usr/local/bin/mkcl")
   ;; (setq inferior-lisp-program "~/lang/lisp/ccl/lx86cl64")
   ;; (setq inferior-lisp-program "sbcl")
   ;; (setq inferior-lisp-program "ecl")
   (setq inferior-lisp-program "ccl")

   (add-hook 'lisp-mode-hook
             (lambda ()
               (local-set-key (kbd "M-q") 'query-replace)
               ))
   #+end_src
** lisp-add-keywords
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun lisp-add-keywords (face-name keyword-rules)
     (let* ((keyword-list
             (mapcar #'(lambda (x)
                         (symbol-name (cdr x)))
                     keyword-rules))
            (keyword-regexp
             (concat "(\\("
                     (regexp-opt keyword-list)
                     "\\)[ \n]")))
       (font-lock-add-keywords
        'lisp-mode
        `((,keyword-regexp 1 ',face-name))))
     (mapc #'(lambda (x)
               (put (cdr x)
                    'lisp-indent-function
                    (car x)))
           keyword-rules))

   ;; note that
   ;; a macro will be turned into keyword by slime
   ;; slime will override the following definition
   ;; but slime does not help some of the colors
   (lisp-add-keywords
    'font-lock-keyword-face
    '(
      (0 . quote)
      (0 . function)
      (0 . values)

      (1 . defin)
      (1 . with)

      (1 . apply)
      (1 . funcall)

      (2 . deftest)
      (3 . ensure)

      (1 . cat)
      (1 . orz)

      (1 . add1!)
      (1 . sub1!)
      (2 . set!)
      (2 . set-car!)
      (2 . set-cdr!)
      (2 . set-end-car!)
      (2 . set-end-cdr!)

      (1 . multiple-value-let)
      ;; (1 . let-fun)
      (1 . help)
      ))
   #+end_src
** slime
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; setup load-path and autoloads
   (add-to-list 'load-path "~/.emacs.d/slime/")
   (setq slime-contribs '(slime-fancy))
   (require 'slime-autoloads)


   (setf common-lisp-hyperspec-root "/home/xyh/lang/lisp/hyperspec/"
         slime-complete-symbol-function 'slime-fuzzy-complete-symbol
         lisp-indent-function 'common-lisp-indent-function)


   (add-hook 'slime-mode-hook
             (lambda ()
               (local-set-key (kbd "M-l")  'slime-documentation-lookup)
               (local-set-key (kbd "C-M-h")  'slime-fuzzy-complete-symbol)
               (local-set-key (kbd "C-M-.") 'next-buffer)
               (local-set-key (kbd "C-M-,") 'previous-buffer)
               ))

   ;; (require 'slime)


   ;; the following are not working
   ;; so I just edit the slime.el

   (add-hook 'slime-repl-mode-hook
             (lambda ()
               (local-set-key (kbd "C-M-.") 'next-buffer)
               (local-set-key (kbd "C-M-,") 'previous-buffer)
               ))




   ;; (defun switch-to-buffer-*slime* ()
   ;;   (interactive)
   ;;   (slime-switch-to-output-buffer)
   ;;   (local-set-key (kbd "C-s C-x") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-x") 'switch-to-buffer-*slime*)




   ;; (add-hook
   ;;  'slime-mode-hook
   ;;  (lambda ()
   ;;    (local-set-key (kbd "C-x C-e") 'slime-send-last-sexp-split-window)
   ;;    ))
   #+end_src
** ----------------------------------
** elisp
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-elisp-mode-keywords()
     (font-lock-add-keywords
      nil
      '(("\\<\\(setq\\)" . 'font-lock-keyword-face))))
   (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode-keywords)
   #+end_src
** emacs-lisp-add-keywords
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun emacs-lisp-add-keywords (face-name keyword-rules)
     (let* ((keyword-list
             (mapcar #'(lambda (x)
                         (symbol-name (cdr x)))
                     keyword-rules))
            (keyword-regexp
             (concat "(\\("
                     (regexp-opt keyword-list)
                     "\\)[ \n]")))
       (font-lock-add-keywords
        'emacs-lisp-mode
        `((,keyword-regexp 1 ',face-name))))
     (mapc #'(lambda (x)
               (put (cdr x)
                    'emacs-lisp-indent-function
                    (car x)))
           keyword-rules))

   (emacs-lisp-add-keywords
    'font-lock-keyword-face
    '(
      (1 . add-hook)
      ))
   #+end_src
** general seting
   Non-nil means print recursive structures using #N= and #N# syntax.
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq print-circle t)
   #+end_src
** ielm = run-elisp-repl
   不知道哪个傻逼起的ielm这个名字
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun elisp-repl ()
     (interactive)
     (ielm))

   (defun member-string? (x l)
     (cond ((null l) nil)
           ((string-equal x (car l))
            t)
           (else
            (member-string? x (cdr l)))
           ))

   (defun switch-to-buffer-*elisp-repl* ()
     (interactive)
     (if (member-string? "*elisp-repl*" (mapcar 'buffer-name (buffer-list)))
             (switch-to-buffer "*elisp-repl*")
           (progn
             (ielm)
             (rename-buffer "*elisp-repl*")))
     (local-set-key (kbd "C-s e") 'previous-buffer))
   (global-set-key (kbd "C-s e") 'switch-to-buffer-*elisp-repl*)
   #+end_src
** ----------------------------------
** shen
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/shen-mode/")
   (require 'shen-mode)
   (require 'inf-shen) ; <- for interaction with an external shen process

   (defun switch-to-buffer-*inferior-shen* ()
     (interactive)
     (if (member-string? "*inferior-shen*" (mapcar 'buffer-name (buffer-list)))
             (switch-to-buffer "*inferior-shen*")
           (switch-to-shen t))
     (local-set-key (kbd "C-s C-w") 'previous-buffer))
   (global-set-key (kbd "C-s C-w") 'switch-to-buffer-*inferior-shen*)
   #+end_src
** ----------------------------------
** sawfish (not using)
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/sawfish/")
   (autoload 'sawfish-mode "sawfish" "sawfish-mode" t)
   (setq auto-mode-alist (cons '("\\.sawfishrc$"  . sawfish-mode) auto-mode-alist)
             auto-mode-alist (cons '("\\.jl$"         . sawfish-mode) auto-mode-alist)
             auto-mode-alist (cons '("\\.sawfish/rc$" . sawfish-mode) auto-mode-alist))
   #+end_src
** ----------------------------------
** markdown
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/markdown-mode/")
   (autoload 'markdown-mode "markdown-mode"
          "Major mode for editing Markdown files" t)
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

   (add-hook
    'markdown-mode-hook
    (lambda ()
      (local-set-key (kbd "M-p") 'backward-paragraph)
      (local-set-key (kbd "M-n") 'forward-paragraph)
      (turn-off-indent)
      ))
   #+end_src
** ----------------------------------
** [not using] DOS
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/DOS/")
   (require 'ntcmd)
   (add-to-list 'auto-mode-alist '("\\.cmd$" . ntcmd-mode))
   (add-to-list 'auto-mode-alist '("\\.bas$" . ntcmd-mode))
   (add-to-list 'auto-mode-alist '("\\.bat$" . ntcmd-mode))

   ;; (require 'dos)
   ;; (require 'batch-mode)
   ;; (require 'cmd-mode)
   #+end_src
** ----------------------------------
** lfe
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/lfe/")
   (require 'lfe-mode)
   (require 'inferior-lfe)
   (require 'lfe-start)
   #+end_src
** ----------------------------------
** cicada
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cicada-mode/")
   (require 'cicada-mode)
   (require 'inferior-cicada-mode)

   ;; (define-prefix-command 'C-s-map)
   ;; (global-set-key (kbd "C-s") 'C-s-map)
   (defun switch-to-buffer-*cicada* ()
     (interactive)
     (if (member-string? "*cicada*" (mapcar 'buffer-name (buffer-list)))
             (let ()
           (switch-to-buffer "*cicada*")
           (local-set-key (kbd "C-s C-d") 'previous-buffer))
           (let ()
             (run-cicada "cicada"))))
   (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*cicada*)

   (add-hook 'cicada-mode-hook
    (lambda ()
      (local-set-key (kbd "C-h") 'hippie-expand)
      (local-set-key (kbd "M-q") 'query-replace)
      (local-set-key (kbd "C-c C-c")
                     'cicada-send-region-and-split-window)
      (local-set-key (kbd "C-<tab>")
                     'cicada-send-line-and-split-window-and-goto-next-line)))
   #+end_src
** cicada-nymph
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cicada-nymph-mode/")
   (require 'cicada-nymph-mode)
   (require 'inferior-cicada-nymph-mode)

   ;; (define-prefix-command 'C-s-map)
   ;; (global-set-key (kbd "C-s") 'C-s-map)
   (defun switch-to-buffer-*cicada-nymph* ()
     (interactive)
     (if (member-string? "*cicada-nymph*" (mapcar 'buffer-name (buffer-list)))
             (let ()
           (switch-to-buffer "*cicada-nymph*")
           (local-set-key (kbd "C-s C-d") 'previous-buffer))
           (let ()
             (run-cicada-nymph "cicada-nymph"))))
   (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*cicada-nymph*)

   (add-hook 'cicada-nymph-mode-hook
    (lambda ()
      (local-set-key (kbd "C-h") 'hippie-expand)
      (local-set-key (kbd "M-q") 'query-replace)
      (local-set-key (kbd "C-c C-c")
                     'cicada-nymph-send-region-and-split-window)
      (local-set-key (kbd "C-<tab>")
                     'cicada-nymph-send-line-and-split-window-and-goto-next-line)))
   #+end_src
** return-stack
   #+begin_src emacs-lisp :tangle "~/.emacs"
   (add-to-list 'load-path "~/.emacs.d/return-stack-mode/")
   (require 'return-stack-mode)
   #+end_src
** ----------------------------------
** retro
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/retro/")

   (autoload 'retro-mode "retro-mode.el" "retro mode" t)
   (add-to-list 'auto-mode-alist '("\\.rx\\'" . retro-mode))
   #+end_src
** ----------------------------------
** forth
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun switch-to-buffer-*forth* ()
     (interactive)
     (if (member-string? "*forth*" (mapcar 'buffer-name (buffer-list)))
             (switch-to-buffer "*forth*")
           (let ((forth-name
              ;; "gforth"
              ;; "retro"
              (read-from-minibuffer "run which forth? : ")
              ))
             (run-forth forth-name)))
     (local-set-key (kbd "C-s C-f") 'previous-buffer))
   (global-set-key (kbd "C-s C-f") 'switch-to-buffer-*forth*)
   #+end_src
** gforth
   file:~/.emacs.d/gforth.el/forth-mode.el
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/gforth.el/")

   (require 'forth-mode)

   (autoload 'forth-mode "gforth.el")
   (setq auto-mode-alist (cons '("\\.f\\'" . forth-mode)
                                   auto-mode-alist))

   (defun forth-send-paragraph-split-window ()
     (interactive)
     (split-window-with-named-buffer "*forth*")
     (forth-send-paragraph))

   ;; 利用forth-send-region来实现forth-send-line
   ;; 因为不想使用forth-send-paragraph
   (defun forth-send-line ()
     (interactive)
     (move-beginning-of-line nil)
     (cua-set-mark)
     (move-end-of-line nil)
     (forth-send-region (region-beginning) (region-end))
     (cua-set-mark))

   (defun forth-send-line-split-window ()
     (interactive)
     (split-window-with-named-buffer "*forth*")
     (forth-send-line))

   (defun forth-send-line-and-goto-next-line ()
     (interactive)
     (forth-send-line)
     (next-line))


   (add-hook
    'forth-mode-hook
    (function (lambda ()

                    (setq forth-indent-level 4)
                    (setq forth-minor-indent-level 2)
                    (setq forth-hilight-level 3)

                    (local-set-key (kbd "C-h") 'hippie-expand)

                    (local-set-key (kbd "C-x C-e") 'forth-send-line-split-window)
                    (local-set-key (kbd "C-<tab>") 'forth-send-line-and-goto-next-line)
                    (local-set-key (kbd "<return>") 'newline)

                    (turn-off-indent)
                    (local-set-key (kbd "M-q") 'query-replace)

                    ;; (setq comment-start "("!;\ )
                    ;; (setq comment-end " !;\"!;\ )
                    ;; (setq comment-padding" "!;\ )

                    )))
   #+end_src
** ----------------------------------
** tcl
   #+begin_src emacs-lisp :tangle "~/.emacs"
   (setq tcl-application "tclsh")


   (defun tcl-eval-defun-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-eval-defun))

   (defun tcl-send-line ()
     (interactive)
     (move-beginning-of-line nil)
     (cua-set-mark)
     (move-end-of-line nil)
     (tcl-eval-region (region-beginning) (region-end))
     (cua-set-mark))

   (defun tcl-send-line-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-send-line))

   (defun tcl-send-line-and-goto-next-line ()
     (interactive)
     (tcl-send-line)
     (next-line))

   (defun tcl-send-line-and-goto-next-line-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-send-line)
     (next-line))

   (add-hook
    'tcl-mode-hook
    (function (lambda ()
      ;; note that how a function definition in tcl is viewed as a line
      (local-set-key (kbd "C-<tab>") 'tcl-send-line-and-goto-next-line-split-window)
      (local-set-key (kbd "C-x C-e") 'tcl-send-line-split-window)
      (local-set-key (kbd "C-c C-e") 'tcl-eval-defun-split-window)
      )))
   #+end_src
** ----------------------------------
** sml
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/sml/")
   ;; (defun switch-to-buffer-about-sml ()
   ;;   (interactive)
   ;;   (cond ((member-string? "*hamlet*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*hamlet*"))
   ;;         ((member-string? "*mosml*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*mosml*"))
   ;;         ((member-string? "*poly*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*poly*"))
   ;;         ((member-string? "*sml*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*sml*"))
   ;;         (else
   ;;          ;; (run-sml "sml" "")
   ;;          (run-sml "hamlet" "")
   ;;          ))
   ;;   ;; 然后总能通过向左一个buffer回到之前的buffer
   ;;   ;; 这是笨的解决方法，某些情况下一定会出问题
   ;;   (local-set-key (kbd "C-s C-q") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-q") 'switch-to-buffer-about-sml)
   #+end_src
*** 版本1
    sml-mode-6.4.el
    #+begin_src emacs-lisp :tangle ~/.emacs
    (autoload 'sml-mode "sml-mode" "Major mode for editing SML." t)
    (autoload 'run-sml "sml-proc" "Run an inferior SML process." t)
    (add-to-list 'auto-mode-alist '("\\.\\(sml\\|sig\\)\\'" . sml-mode))

    (setq sml-program-name "sml")
    ;; (setq sml-program-name "hamlet")

    (require 'sml-mode)

    (add-hook
     'sml-mode-hook
     (lambda ()
       (define-key sml-mode-map (kbd "C-x C-e") 'sml-send-function)
       ;; (local-set-key (kbd "C-x C-e") 'sml-send-function)
       )
     'turn-off-indent)
    #+end_src
*** 版本2
    sml-mode-color.el
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    ;; *** set this path to the sml executable (sml.bat on Windows)
    ;; (setq sml-prog-name "/usr/bin/hamlet")

    (autoload 'sml-mode "sml-mode-color" () t)
    (add-to-list 'auto-mode-alist '("\\.sml$" . sml-mode))
    (add-to-list 'auto-mode-alist '("\\.sig$" . sml-mode))

    (add-hook 'sml-mode-hook
       (lambda ()
             (setq indent-tabs-mode nil)
             (setq sml-indent-args 2)
             (local-set-key (kbd "M-SPC") 'just-one-space)))

    (add-hook 'sml-shell-hook
       (lambda ()
             (send-string sml-process-name
               (concat "use \""
                       sml-mode-dir
                       "/inferior-setup.sml\";\n"))))
    #+end_src
*** 版本3
    sml-mode-kkk.el
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (autoload 'sml-mode "sml-mode" "Major mode for editing ML programs." t)

    (setq auto-mode-alist
              (cons '(("\\.sml$" . sml-mode)
                      ("\\.ML$"  . sml-mode)) auto-mode-alist))

    (setq sml-mode-hook
              '(lambda() "ML mode hacks"
             (setq sml-indent-level 2         ; conserve on horiz. space
                       indent-tabs-mode nil)))    ; whatever

    ;; (setq sml-load-hook
    ;;       '(lambda() "Highlights." (require 'sml-hilite)))

    ;; (if window-system
    ;;     (setq hilit-background-mode   t ; monochrome (alt: 'dark or 'light)
    ;;           hilit-inhibit-hooks     nil
    ;;           hilit-inhibit-rebinding nil
    ;;           hilit-quietly           t))

    ;; Alternatively, you can (require 'sml-font) which uses the font-lock
    ;; package instead.
    #+end_src
** ocaml-mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/ocaml-mode/")

   (add-to-list 'auto-mode-alist '("\\.ml[iylp]?$" . caml-mode))
   (autoload 'caml-mode "caml" "Major mode for editing OCaml code." t)
   (autoload 'run-caml "inf-caml" "Run an inferior OCaml process." t)
   (autoload 'camldebug "camldebug" "Run ocamldebug on program." t)
   (add-to-list 'interpreter-mode-alist '("ocamlrun" . caml-mode))
   (add-to-list 'interpreter-mode-alist '("ocaml" . caml-mode))


   ;; (if window-system (require 'caml-hilit))
   (if window-system (require 'caml-font))

   (defun switch-to-buffer-*inferior-caml* ()
      (interactive)
     (if (member-string? "*inferior-caml*" (mapcar 'buffer-name (buffer-list)))
          (switch-to-buffer "*inferior-caml*")
        (run-caml "ocaml"))
      (local-set-key (kbd "C-s C-q") 'previous-buffer))
    (global-set-key (kbd "C-s C-q") 'switch-to-buffer-*inferior-caml*)

   (defun caml-eval-phrase-split-window ()
     (interactive)
     (caml-eval-phrase 1)
     (split-window-with-named-buffer "*inferior-caml*"))

   ;; 因为<tab>在caml-mode中不支持区域缩进
   ;; 所以给C-<tab>绑定一个方便多行缩进的函数
   (defun caml-indent-line-by-line ()
     (interactive)
     (caml-indent-command)
     (next-line))

   (add-hook
    'caml-mode-hook
    (lambda ()
      (local-set-key (kbd "C-x C-e") 'caml-eval-phrase-split-window)
      (local-set-key (kbd "C-<tab>") 'caml-indent-line-by-line)
      (local-set-key (kbd "M-p") 'caml-backward-to-less-indent)
      (local-set-key (kbd "M-n") 'caml-forward-to-less-indent)

      (setq comment-style 'multi-line)
      ))


   ;; (defun pretty-lambdas-for-caml ()
   ;;   (interactive)
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("\\(function[\n ]\\)" (0
   ;;                    (progn
   ;;                          (compose-region (match-beginning 0)
   ;;                                          (+ (match-beginning 0) 8)
   ;;                                          "λ")
   ;;                          nil)))
   ;;          )))
   ;; (font-lock-add-keywords
   ;;  'caml-mode
   ;;  `(("\\(function[\n ]\\)"
   ;;         (0
   ;;          (progn
   ;;            (compose-region (match-beginning 0)
   ;;                            (+ (match-beginning 0) 8)
   ;;                            "λ")
   ;;            nil)))))

   ;; ;; (add-hook 'caml-mode-hook 'pretty-lambdas-for-caml)
   #+end_src
** ocaml
   no such things as ocaml-mode
   there are:
   caml-mode
   inferior-caml-mode
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/ocaml/")


   (setq auto-mode-alist
             (cons '("\\.ml[iyl]?$" .  caml-mode) auto-mode-alist))
   (autoload 'caml-mode "ocaml" (interactive)
     "Major mode for editing Caml code." t)
   (autoload 'camldebug "camldebug" (interactive) "Debug caml mode")
   (require 'ocaml)
   (if window-system (require 'caml-font))
   #+end_src
** tuareg-mode for ocaml (not using)
   这个mode运行很慢
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/tuareg/")
   (require 'tuareg)
   ;; (require 'caml)
   #+end_src
** ----------------------------------
** asm
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; may set this variable in `asm-mode-set-comment-hook',
   ;; which is called near the beginning of mode initialization.
   (add-hook 'asm-mode-set-comment-hook
             (lambda ()
                   (setq asm-comment-char ?\#)
                   ))

   (defun asm-indent-line-by-line ()
     (interactive)
     (asm-indent-line)
     (next-line))

   (add-hook 'asm-mode-hook
             (lambda ()
                   (local-set-key (kbd "C-<tab>") 'asm-indent-line-by-line)
                   ))
   #+end_src
** gas (not using)
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/gas-mode/")

   (require 'gas-mode)
   (add-to-list 'auto-mode-alist '("\\.S\\'" . gas-mode))
   #+end_src
** fasm
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/fasm-mode/")
   (require 'fasm-mode)
   (add-to-list 'auto-mode-alist '("\\.fasm$" . fasm-mode))
   (add-to-list 'auto-mode-alist '("\\.inc$"  . fasm-mode))
   (add-to-list 'auto-mode-alist '("\\.s$"    . fasm-mode))

   (defun fasm-indent-line-and-next-line ()
     (interactive)
     (fasm-indent-line)
     (next-line))

   (add-hook 'fasm-mode-hook
             (lambda ()
                   ;; (setq tab-width 13)
                   ;; (setq indent-tabs-mode t)
                   ;; (local-set-key (kbd "<tab>") 'fasm-indent-line)
                   ;; (local-set-key (kbd "C-<tab>") 'fasm-indent-line-and-next-line)
                   ;; (turn-off-indent)
                   ))
   #+end_src
** nasm
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/nasm/")
   (autoload 'nasm-mode "~/.emacs.d/nasm/nasm-mode.el" "" t)

   (add-to-list 'auto-mode-alist '("\\.asm\\'" . nasm-mode))
   (add-to-list 'auto-mode-alist '("\\.nasm\\'" . nasm-mode))

   ;; To set your own indentation level to LEVEL:
   ;; (add-hook 'nasm-mode-hook
   ;;           (lambda () (setq-default nasm-basic-offset LEVEL)))
   (add-hook 'nasm-mode-hook
             (lambda ()
                   (setq-default nasm-basic-offset 13)
                   (turn-off-indent)
                   ))
   #+end_src
** ----------------------------------
** haskell
*** lode-path and init
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/haskell-mode/")
    (require 'haskell-mode-autoloads)
    (add-to-list 'Info-default-directory-list "~/.emacs.d/haskell-mode/")
    (setq haskell-program-name "ghci")
    #+end_src
*** indent
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
    (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
    ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
    #+end_src
*** switch and split
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun haskell-split-window ()
      (interactive)
      (cond
       ((= 1 (count-windows))
            (split-window-vertically (floor (* 0.68 (window-height))))
            (other-window 1)
            (switch-to-buffer "*haskell*")
            (other-window 1))
       ((not (cl-find "*haskell*"
                       (mapcar (lambda (w) (buffer-name (window-buffer w)))
                               (window-list))
                       :test 'equal))
            (other-window 1)
            (switch-to-buffer "*haskell*")
            (other-window -1))))


    (defun switch-to-buffer-*haskell* ()
      (interactive)
      (progn
            (setq the-buffer-before-switch-to-buffer-*haskell*
              (current-buffer))
            (if (cl-find "*haskell*"
                     (mapcar (lambda (w) (buffer-name w))
                             (buffer-list))
                     :test 'equal)
            (switch-to-buffer "*haskell*")
              (progn (run-haskell) (delete-other-windows)))
            (local-set-key (kbd "C-s C-c") (lambda ()
                                             (interactive)
                                             (switch-to-buffer the-buffer-before-switch-to-buffer-*haskell*)))))
    (global-set-key (kbd "C-s C-c") 'switch-to-buffer-*haskell*)
    #+end_src
*** compile
    When invoked, ‘haskell-compile’ tries to guess how to compile the
    Haskell program your currently visited buffer belongs to, by searching
    for a ‘.cabal’ file in the current of enclosing parent folders.  If a
    ‘.cabal’ file was found, the command defined in the
    ‘haskell-compile-cabal-build-command’ option is used.  Moreover, when
    requesting to compile a ‘.cabal’-file is detected and a negative prefix
    argument (e.g.  ‘C-- C-c C-c’) was given, the alternative
    ‘haskell-compile-cabal-build-command-alt’ is invoked.  By default,
    ‘haskell-compile-cabal-build-command-alt’ contains a ‘cabal clean -s’
    command in order to force a full rebuild.
    #+begin_src emacs-lisp :tangle ~/.emacs
    (eval-after-load "haskell-mode"
      '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))
    (eval-after-load "haskell-cabal"
      '(define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
    #+end_src
** note on pretty-lambdas-for-haskell
   (font-lock-add-keywords MODE KEYWORDS &optional HOW)
   KEYWORDS should be a list; see the variable: font-lock-keywords

   in font-lock-keywords each element in a user-level keywords list
   should have one of these forms:
   MATCHER
   (MATCHER . SUBEXP)
   (MATCHER . FACENAME)
   (MATCHER . HIGHLIGHT)
   (MATCHER HIGHLIGHT ...)
   (eval . FORM)
** examples
   #+begin_src emacs-lisp
   (add-hook
    'c-mode-hook
    (lambda ()
      (font-lock-add-keywords
           nil
           '(("\\<\\(FIXME\\):" 1 'font-lock-warning-face prepend)
             ("\\<\\(and\\|or\\|not\\)\\>" . 'font-lock-keyword-face)
             ))))
   #+end_src
** pretty-lambdas-for-haskell
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun pretty-lambdas-for-haskell ()
     (interactive)
     (font-lock-add-keywords
      nil
      ;; i do not fully understand
      ;; how the arg:KEYWORDS of font-lock-add-keywords works
      ;; which is very complicated
      ;; but the following returns what i want
      ;; which is so very cool !!!
      ;; (regexp-opt '("function\n" "function ") t)
      `(("\\\\.*?->" (0 (progn
                              ;; \x->f(g x) change to λx.f(g x)
                              (compose-region (match-beginning 0)
                                              (+ (match-beginning 0) 1)
                                              "λ")
                              (compose-region (- (match-end 0) 2)
                                              (match-end 0)
                                              ":")
                              nil))))))

   (add-hook 'haskell-mode-hook
             'pretty-lambdas-for-haskell)
   (add-hook 'inferior-haskell-mode-hook
             'pretty-lambdas-for-haskell)
   #+end_src
** ----------------------------------
** clojure
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/clojure-mode/")
   (require 'clojure-mode)
   #+end_src
** queue
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/queue/")
   (require 'queue)
   #+end_src
** [not using] cider
   * CIDER (formerly nrepl.el) is the Clojure IDE and REPL for Emacs
     built on top of nREPL(the Clojure networked REPL server)
     CIDER depends on clojure-mode, dash.el and pkg-info
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cider/")
   (require 'cider)

   ;; cider-mode (complementing clojure-mode)
   ;; that allows you to evaluate code in your Clojure source files
   ;; and load it directly in the REPL
   ;; (eval-after-load "clojure-mode" '(cider-mode t))
   (add-hook 'clojure-mode-hook (lambda () (cider-mode t)))

   ;; Enable eldoc in Clojure buffers:
   (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)


   ;; You can control the TAB key behavior in the REPL via
   ;; cider-repl-tab-command
   ;; default is command cider-repl-indent-and-complete-symbol
   ;; to only indent:
   ;; (setq cider-repl-tab-command 'indent-for-tab-command)

   ;; Prevent the auto-display of the REPL buffer in a separate window
   ;; after connection is established:
   ;; (setq cider-repl-pop-to-buffer-on-connect nil)

   ;; Stop the error buffer from popping up
   ;; while working in buffers other than the REPL
   (setq cider-popup-stacktraces nil)

   ;; Enable error buffer popping also in the REPL:
   ;; (setq cider-repl-popup-stacktraces t)

   ;; To auto-select the error buffer when it's displayed:
   ;; (setq cider-auto-select-error-buffer t)

   ;; in The REPL buffer name
   ;; display the port on which the nREPL server is running
   ;; Buffer name will look like cider-repl project-name:port
   (setq nrepl-buffer-name-show-port t)

   ;; Make C-c C-z switch to the CIDER REPL buffer in the current window:
   ;; (setq cider-repl-display-in-current-window t)

   ;; Limit the number of items of each collection the printer will print to 100:
   ;; (setq cider-repl-print-length 100) ; the default is nil, no limit

   ;; Change the result prefix for REPL evaluation (by default there's no prefix):
   ;; (set cider-repl-result-prefix ";; => ")
   ;; And here's the result of that change:
   ;; user> (+ 1 2)
   ;; ;; => 3

   ;; Change the result prefix for interactive evaluation (by default it's =>):
   ;; (set cider-interactive-eval-result-prefix ";; => ")
   ;; To remove the prefix altogether just set it to an empty string("").

   ;; Normally code you input in the REPL is
   ;; font-locked with cider-repl-input-face (after you press RET)
   ;; and results are font-locked with cider-repl-output-face
   ;; If you want them to be font-locked as in clojure-mode use the following:
   ;; (setq cider-repl-use-clojure-font-lock t)

   ;; You can control the C-c C-z key behavior of switching to the REPL buffer
   ;; with the cider-switch-to-repl-command variable.
   ;; default command cider-switch-to-relevant-repl-buffer
   ;; cider-switch-to-current-repl-buffer offers a simpler alternative
   ;; where CIDER will not attempt to match the correct REPL buffer
   ;; based on underlying project directories:
   ;; (setq cider-switch-to-repl-command 'cider-switch-to-current-repl-buffer)


   ;; to make the REPL history wrap around when its end is reached:
   (setq cider-repl-wrap-history t)

   ;; To adjust the maximum number of items kept in the REPL history:
   (setq cider-repl-history-size 1000) ; the default is 500

   ;; To store the REPL history in a file:
   ;; (setq cider-repl-history-file "path/to/file")
   ;; Note that the history is written to the file when you kill the REPL buffer
   ;; (which includes invoking cider-quit) or you quit Emacs
   #+end_src
** ----------------------------------
** erlang
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/erlmode/")
   (require 'erlmode-start)
   #+end_src
** elixir
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/elixir-mode/")
   (require 'elixir-mode)
   (require 'inferior-elixir-mode)
   #+end_src
** ----------------------------------
** prolog
   #+begin_src emacs-lisp :tangle ~/.emacs
   (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
   (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
   (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)
   (setq prolog-system 'swi)
   ;; (setq auto-mode-alist (append '(("\\.pl$" . prolog-mode)
   ;;                                 ("\\.m$" . mercury-mode))
   ;;                                auto-mode-alist))
   #+end_src
** ----------------------------------
** free-pascal
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/freepascal-mode/")
   (require 'pascal)
   (setq pascal-indent-level       3
             pascal-case-indent        2
             pascal-auto-newline       nil
             pascal-tab-always-indent  t
             pascal-auto-endcomments   t
             pascal-auto-lineup        '(all)
             pascal-type-keywords      '("array" "file" "packed" "char"
                                     "integer" "real" "string" "record")
             pascal-start-keywords     '("begin" "end" "function" "procedure"
                                     "repeat" "until" "while" "read" "readln"
                                     "reset" "rewrite" "write" "writeln")
             pascal-separator-keywords '("downto" "else" "mod" "div" "then"))
   #+end_src
** C
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq-default c-basic-offset 2)
   #+end_src
** java
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-indent-setup ()
     (c-set-offset 'arglist-intro '+))

   (add-hook 'java-mode-hook 'my-indent-setup)
   #+end_src
** vala
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/vala-mode/")
   (autoload 'vala-mode "vala-mode" "Major mode for editing Vala code." t)
   (add-to-list 'auto-mode-alist '("\\.vala$" . vala-mode))
   (add-to-list 'auto-mode-alist '("\\.vapi$" . vala-mode))
   (add-to-list 'file-coding-system-alist '("\\.vala$" . utf-8))
   (add-to-list 'file-coding-system-alist '("\\.vapi$" . utf-8))
   #+end_src
** ----------------------------------
** nimrod
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/nimrod-mode/")
   (require 'nimrod-mode)
   #+end_src
** ----------------------------------
** ProofGeneral
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral-4.2/ProofGeneral/generic/")
   ;; (add-to-list 'load-path "~/.emacs.d/ProofGeneral/generic/")
   (load-file "~/.emacs.d/ProofGeneral/generic/proof-site.elc")

   ;; (require 'proof-site) must be away after org-mode is turned on
   ;; i don't know way

   ;; (defun org/prepare-for-coq-code-block ()
   ;;   (interactive)
   ;;   (require 'proof-site))

   ;; (eval-after-load "coq-mode"
   ;;   '(define-key coq-mode-map (kbd ";") 'c-electric-semi&comma))
   #+end_src
** coq
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/coq/")

   ;; rebinding keys for interactively proof
   (add-hook 'coq-mode-hook
             (lambda ()
               (set (make-local-variable
                     'comment-style)  'extra-line)

               (local-set-key (kbd "M-p") 'backward-paragraph)
               (local-set-key (kbd "M-n") 'forward-paragraph)
               ;; M-p used to runs the command pg-previous-matching-input-from-input
               (local-set-key (kbd "C-M-n") 'proof-assert-next-command-interactive)
               (local-set-key (kbd "C-M-p") 'proof-undo-last-successful-command)
               ))

   ;; pretty-lambdas-for-coq

   ;; i do not fully understand
   ;; how the arg:KEYWORDS of font-lock-add-keywords works
   ;; which is very complicated
   ;; but the following returns what i want
   ;; which is so very cool !!!

   ;; (defun pretty-display-for-coq ()
   ;;   (interactive)
   ;;   ;; (font-lock-add-keywords
   ;;   ;;  nil
   ;;   ;;  `(("fun " (0
   ;;   ;;             (progn
   ;;   ;;               (compose-region (match-beginning 0)
   ;;   ;;                               (+ (match-beginning 0) 3)
   ;;   ;;                               "λ")
   ;;   ;;               nil)))))
   ;;   ;; (font-lock-add-keywords
   ;;   ;;  nil
   ;;   ;;  `(("=> " (0
   ;;   ;;            (progn
   ;;   ;;              (compose-region (match-beginning 0)
   ;;   ;;                              (+ (match-beginning 0) 2)
   ;;   ;;                              ".")
   ;;   ;;              nil)))))
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("fun .*? =>" (0
   ;;                    (progn
   ;;                          ;; \x->f(g x) change to λx.f(g x)
   ;;                          (compose-region (match-beginning 0)
   ;;                                          (+ (match-beginning 0) 3)
   ;;                                          "λ")
   ;;                          (compose-region (- (match-end 0) 2)
   ;;                                          (match-end 0)
   ;;                                          ".")
   ;;                          nil)))))
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("\\\\/" (0
   ;;                  (progn
   ;;                    (compose-region (match-beginning 0)
   ;;                                    (+ (match-beginning 0) 2)
   ;;                                    "∨")
   ;;                    nil)))))
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("/\\\\" (0
   ;;                  (progn
   ;;                    (compose-region (match-beginning 0)
   ;;                                    (+ (match-beginning 0) 2)
   ;;                                    "∧")
   ;;                    nil)))))
   ;;   ;; use "forall " to match the word
   ;;   ;; and use "∀" to compose-region [0-6]
   ;;   ;; but not "∀ " to compose-region [0-7]
   ;;   ;; this is very important !!!
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("forall " (0
   ;;                 (progn
   ;;                   (compose-region (match-beginning 0)
   ;;                                   (+ (match-beginning 0) 6)
   ;;                                   "∀")
   ;;                   nil)))))
   ;;   (font-lock-add-keywords
   ;;    nil
   ;;    `(("exists " (0
   ;;                 (progn
   ;;                   (compose-region (match-beginning 0)
   ;;                                   (+ (match-beginning 0) 6)
   ;;                                   "∃")
   ;;                   nil))))))

   ;; (add-hook 'coq-mode-hook
   ;;           'pretty-display-for-coq)
   ;; (add-hook 'coq-goals-mode-hook
   ;;           'pretty-display-for-coq)
   ;; (add-hook 'coq-response-mode-hook
   ;;           'pretty-display-for-coq)
   #+end_src
** ----------------------------------
** perl (nothing need to be added)
** ----------------------------------
** ruby
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/inf-ruby/")
   (require 'inf-ruby)
   (autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
   (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

   (add-to-list 'load-path "~/.emacs.d/enhanced-ruby-mode/")
   (require 'enh-ruby-mode)
   (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
   (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
   (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
   #+end_src
** ----------------------------------
** sql (not using)
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/sql/")
   (require 'sql)
   (require 'mysql)
   #+end_src

   如果你的mysql端口不是标准端口的话 需要:
   #+begin_src emacs-lisp
   (setq sql-mysql-options (list "-P 6871"))
   #+end_src

   通过下面的命令设置两个连接mysql的常用帐号:
   #+begin_src emacs-lisp
   (setq sql-connection-alist
             '((pool-a
            (sql-product 'mysql)
            (sql-server "ip1")
            (sql-user "user1")
            (sql-password "pwd1")
            (sql-database "db1")
            (sql-port 6871))
           (pool-b
            (sql-product 'mysql)
            (sql-server "ip2")
            (sql-user "user2")
            (sql-password "pwd2")
            (sql-database "db2")
            (sql-port 3306))))

   (defun sql-connect-preset (name)
     "Connect to a predefined SQL connection listed in `sql-connection-alist'"
     (eval `(let ,(cdr (assoc name sql-connection-alist))
           (flet ((sql-get-login (&rest what)))
             (sql-product-interactive sql-product)))))

   (defun mysql-a ()
     (interactive)
     (sql-connect-preset 'pool-a))

   (defun mysql-b ()
     (interactive)
     (sql-connect-preset 'pool-b))
   #+end_src

*** indent
    fuck
    there is no good indent-mode for sql
    all the following are stupid
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    ;; (eval-after-load "sql"
    ;;   '(load-library "sql-indent"))


    ;; (eval-after-load "sql"
    ;;   '(load-library "tsql-indent"))
    (require 'tsql-indent)
    (add-hook 'sql-mode-hook
      (lambda ()
            (define-key sql-mode-map (kbd "<tab>") 'tsql-indent-line)))

    ;; (require 'sql-smie-mode)
    ;; (add-hook 'sql-mode-hook 'sql-smie-mode)
    #+end_src

** ----------------------------------
** lojban (not using)
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (load-file "~/.emacs.d/lojban.el")
   (load-file "~/.emacs.d/lojban-mode.el")
   (autoload 'lojban-mode "lojban-mode" nil t)
   #+end_src
** ----------------------------------
** lua (not using)
*** load
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/lua-mode/")

    (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
    #+end_src
*** key
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-hook 'lua-mode-hook  (lambda ()
            (define-key lua-mode-map (kbd "C-x C-e") 'lua-send-current-line)
            (define-key lua-mode-map (kbd "C-c C-e") 'lua-send-defun)
            (define-key lua-mode-map (kbd "C-c C-r") 'lua-send-region)
            ))
    #+end_src
** ----------------------------------
** yaml
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/yaml-mode/")
   (require 'yaml-mode)
   (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))

   (add-hook 'yaml-mode-hook
                         '(lambda ()
                                (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
   #+end_src
** ----------------------------------
** Makefile
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun insert-tab ()
     (interactive)
     (insert 9))


   (add-hook 'makefile-mode-hook
             '(lambda ()
                    (local-set-key (kbd "<tab>") 'insert-tab)))
   #+end_src
** cmake
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cmake-mode/")
   (require 'cmake-mode)
   #+end_src
** ----------------------------------
** BNF
   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-generic-mode 'bnf-mode
    () ;; comment char: inapplicable because # must be at start of line
    nil ;; keywords
    '(
      ("^#.*" . 'font-lock-comment-face) ;; comments at start of line
      ;; ("^<[^ \t\n]*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
      ;; ("<[^ \t\n]*?>" . 'font-lock-builtin-face) ;; other nonterminals
      ;; 下面的版本中<>里可以有空格
      ("^<.*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
      ("<.*?>" . 'font-lock-builtin-face) ;; other nonterminals
      ("::=" . 'font-lock-const-face) ;; "goes-to" symbol
      ("\|" . 'font-lock-warning-face) ;; "OR" symbol
      )
    '("\\.bnf\\'") ;; filename suffixes
    nil ;; extra function hooks
    "Major mode for BNF highlighting.")
   #+end_src
** ----------------------------------
** liquid-mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;;; NOTES:
   ;;;   - two syntax matching types:
   ;;;     1) "regex" . font-lock-name
   ;;;     2) "regex" (capture-group-id font-lock-name)
   ;;;   - variable name regex: \\(?:\\w\\|\\.\\|_\\)+
   ;;;
   ;;; TODO:
   ;;;   - strings can be in single quotes
   ;;;   - detect string vs. object value types
   ;;;   - detect boolean operators (and|or)
   ;;;   - add groups for cycle tags
   ;;;   - for:
   ;;;     - add limit:n, offset:n
   ;;;     - add reversed
   ;;;     - add support for ranges

   (setq liquidKeywords
                 '(
                   ;;; core stuff
                   ("{%\\|%}\\|{{\\|}}" . font-lock-comment-face) ;;; liquid tag delimiters
                   ("{%\s*\\(assign\\|capture\\|endcapture\\|for\\|endfor\\|if\\|endif\\|comment\\|endcomment\\|else\\|elsif\\|unless\\|endunless\\|case\\|when\\|endcase\\|cycle\\)" (1 font-lock-keyword-face)) ;;; liquid construct tags
                   ("forloop" . font-lock-keyword-face)
                   ("forloop.\\(length\\|index0\\|index\\|rindex0\\|rindex\\|first\\|last\\)" (1 font-lock-variable-name-face))
                   ("{%\s*\\(?:assign\\|capture\\|for\\|if\\|unless\\|case\\|when\\)\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable after assign|capture|for|if

                   ("{{\s*\\(\\(?:\\w\\|\\.\\)+\\)" (1 font-lock-variable-name-face)) ;;; variable/object being outputted

                   ;;; filter stuff (hack, only supports 2 chained filters)
                   ("\s+|\s+" . font-lock-comment-face) ;;; liquid tag delimiters
                   ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if
                   ("{{\s*\\(?:\\w\\|\\.\\)+\s+|\s+\\w+\s+|\s+\\(\\w+\\)" (1 font-lock-type-face)) ;;; variable after assign|capture|for|if

                   ;;; if/else stuff
                   ("{%\s*\\(?:if\\|unless\\)\s+\\(?:\\w\\|\\.\\)+\s+\\(contains\\|>\\|<\\|==\\|!=\\)" (1 font-lock-keyword-face)) ;;; liquid operators

                   ;;; for loop stuff
                   ("{%\s*for\s+\\w+\s+\\(in\\)" (1 font-lock-keyword-face)) ;;; the 'in' in "for temp in collection"
                   ("{%\s*for\s+\\w+\s+in\s+\\(\\(?:\\w\\|\\.\\|_\\)+\\)" (1 font-lock-variable-name-face)) ;;; the 'collection' in "for temp in collection"
                   )
                 )
   (define-derived-mode liquid-mode html-mode
         (setq font-lock-defaults '(liquidKeywords))
         (setq mode-name "liquid mode")
         )
   #+end_src
** ----------------------------------
* org
** load-path
   #+begin_src emacs-lisp :tangle "~/.emacs"
   (add-to-list 'load-path "~/.emacs.d/org-mode/lisp")
   (add-to-list 'load-path "~/.emacs.d/org-mode/contrib/lisp" t)
   #+end_src
** publishing
   #+begin_src emacs-lisp :tangle "~/.emacs"
   (setq org-publish-project-alist
         '(("the-little-language-designer"
            :base-directory "~/cicada-nymph/"
            :publishing-directory "~/cicada-nymph/"
            :publishing-function org-html-publish-to-html
            :section-numbers nil
            :with-toc nil
            :html-head "<link rel=\"stylesheet\"
                       href=\"../other/mystyle.css\"
                       type=\"text/css\"/>")))
   #+end_src
** [prefix-command] C-o
   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-prefix-command 'C-o-map)
   (global-set-key (kbd "C-o") 'C-o-map)
   ;; used by:
   ;; "C-o C-b" : org-iswitchb
   #+end_src
** **-in-org
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun **-in-org ()
     "abc ==> *abc*"
     (interactive)
     (progn
           (insert "*")
           (org-end-of-line)
           (insert "*")))
   #+end_src
** key binding
   #+begin_src emacs-lisp :tangle ~/.emacs
   (eval-after-load 'org
     '(progn

       ;; **-in-org
       (define-key org-mode-map (kbd "M-*") '**-in-org)

       ;; cruise
       (define-key org-mode-map (kbd "M-n") 'outline-next-visible-heading)
       (define-key org-mode-map (kbd "M-p") 'outline-previous-visible-heading)
       (define-key org-mode-map (kbd "<M-up>") nil)
       (define-key org-mode-map (kbd "<M-down>") nil)

       ;; text migration
       ;; ``org-metaup'' and ``org-metadown''
       ;; are really dangerous functions
       ;; so it should be as hard as possible to mis-type it
       (define-key org-mode-map (kbd "C-M-p") 'org-metaup)
       (define-key org-mode-map (kbd "C-M-n") 'org-metadown)

       ;; in babel
       (define-key org-mode-map (kbd "M-.") 'org-babel-next-src-block)
       (define-key org-mode-map (kbd "M-,") 'org-babel-previous-src-block)
       (define-key org-mode-map (kbd "C-s C-s") 'org-edit-src-code)

       ))

   ;; (add-hook
   ;;  'org-mode-hook
   ;;  (lambda ()

   ;;    ;; **-in-org
   ;;    (local-set-key (kbd "M-*") '**-in-org)

   ;;    ;; cruise
   ;;    (local-set-key (kbd "M-n") 'outline-next-visible-heading)
   ;;    (local-set-key (kbd "M-p") 'outline-previous-visible-heading)
   ;;    (local-set-key (kbd "<M-up>") nil)
   ;;    (local-set-key (kbd "<M-down>") nil)

   ;;    ;; text migration
   ;;    ;; ``org-metaup'' and ``org-metadown''
   ;;    ;; are really dangerous functions
   ;;    ;; so it should be as hard as possible to mis-type it
   ;;    (local-set-key (kbd "C-M-p") 'org-metaup)
   ;;    (local-set-key (kbd "C-M-n") 'org-metadown)

   ;;    ;; in babel
   ;;    (local-set-key (kbd "M-.") 'org-babel-next-src-block)
   ;;    (local-set-key (kbd "M-,") 'org-babel-previous-src-block)
   ;;    (local-set-key (kbd "C-s C-s") 'org-edit-src-code)
   ;;    ))

   (add-hook
    'org-src-mode-hook
    (lambda ()
      (local-set-key (kbd "C-s C-s") 'org-edit-src-exit)
      ))
   #+end_src
** variable
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;(setq org-startup-indented t)
   (setq org-startup-indented nil)
   (setq org-babel-no-eval-on-ctrl-c-ctrl-c t)
   ;; (setq org-agenda-window-setup )
   ;; (setq org-agenda-restore-windows-after-quit )
   #+end_src
** todo-keyword
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-todo-keywords
         '((sequence "><" "|" "><><" "|" "><><><")

           (sequence "todo")
           (sequence "待")

           (sequence "note" "|" "test")
           (sequence "記" "|" "測")
           (sequence "记" "|" "测")
           ))
   #+end_src
** [babel] load-language
   #+begin_src emacs-lisp :tangle ~/.emacs
   (org-babel-do-load-languages
      'org-babel-load-languages
      '(
            ;; (java . t)
            ;;(cicada . t)
            (scheme . t)
            (lisp . t)
            ;; (shen . t)
            ;; (clojure . t)
            (emacs-lisp . t)
            ;; (sml . t)
            ;; (caml . t)
            ;; (forth . t)
            ;; (sh . t)
            ;; (perl . t)
            ;; (ruby . t)
            ;; (haskell . t)
            ;; (C . t)
            (coq . t)
            ;; (sql . t)
            ;; (lojban . t)
            ;; (lua . t)
            ;; (fasm . t)
            ;; (nasm . t)
            ;; (bnf . t)
            ;; (yaml . t)
            ))
   #+end_src
** [babel] edit
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook 'org-mode-hook (setq org-src-preserve-indentation nil))
   (add-hook 'org-mode-hook (setq org-edit-src-content-indentation 0))
   (add-hook 'org-mode-hook (setq org-src-window-setup 'current-window))
   (add-hook 'org-mode-hook (setq org-src-fontify-natively t))

   ;; (add-hook 'org-mode-hook (setq org-src-tab-acts-natively t))
   ;; if turn on the above variable
   ;; structure-template-alist will be unable to use

   (add-hook 'org-mode-hook (setq org-src-ask-before-returning-to-edit-buffer nil))
   #+end_src
** [babel] structure-template-alist
*** note
    1. C-c C-v d
       org-babel-demarcate-block
    2. begin_src <lang-name> 会去搜索<lang-name>的major-mode
       只要能搜索到就都能用编辑功能
    3. ob-<lang-name>.el是用来提供更多的关于语言的其他功能的
*** basic
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-basic
          '(
            ;; just src
            ("sf" "#+end_src\n?\n#+begin_src" "<src lang=\"?\">\n\n</src>")
            ("s" "#+begin_src\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; picture
            ("picturef" "#+end_src\n?\n#+begin_src picture" "<src lang=\"?\">\n\n</src>")
            ("picture" "#+begin_src picture\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; not using
            ;; ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
            ;; ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
            ;; ("C" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
            ;; ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
            ;; ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
            ;; ("l" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>")
            ;; ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
            ;; ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
            ;; ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
            ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII")
            ;; ("A" "#+ASCII: ")
            ;; ("i" "#+INDEX: ?" "#+INDEX: ?")
            ;; ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")

            ))
    #+end_src
*** erlang-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-erlang-family
          '(
            ;; erlang
            ("erlangf" "#+end_src\n?\n#+begin_src erlang" "<src lang=\"?\">\n\n</src>")
            ("erlang" "#+begin_src erlang\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; lfe
            ("lfef" "#+end_src\n?\n#+begin_src lfe" "<src lang=\"?\">\n\n</src>")
            ("lfe" "#+begin_src lfe\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** lisp-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-lisp-family
          '(
            ;; scheme
            ("ssf" "#+end_src\n?\n#+begin_src scheme" "<src lang=\"?\">\n\n</src>")
            ("ss" "#+begin_src scheme\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; lisp
            ("lispf" "#+end_src\n?\n#+begin_src lisp" "<src lang=\"?\">\n\n</src>")
            ("lisp" "#+begin_src lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; shen
            ("shenf" "#+end_src\n?\n#+begin_src shen" "<src lang=\"?\">\n\n</src>")
            ("shen" "#+begin_src shen\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; clojure
            ("clojuref" "#+end_src\n?\n#+begin_src clojure" "<src lang=\"?\">\n\n</src>")
            ("clojure" "#+begin_src clojure\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; emacs-lisp
            ("seef" "#+end_src\n?\n#+begin_src emacs-lisp :tangle ~/.emacs" "<src lang=\"?\">\n\n</src>")
            ("see" "#+begin_src emacs-lisp :tangle ~/.emacs\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("sef" "#+end_src\n?\n#+begin_src emacs-lisp" "<src lang=\"?\">\n\n</src>")
            ("se" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** forth-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-forth-family
          '(
            ;; cicada
            ("cf" "#+end_src\n?\n#+begin_src cicada" "<src lang=\"?\">\n\n</src>")
            ("c" "#+begin_src cicada\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; cicada-nymph
            ("cnf" "#+end_src\n?\n#+begin_src cicada-nymph" "<src lang=\"?\">\n\n</src>")
            ("cn" "#+begin_src cicada-nymph\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; forth
            ("forthf" "#+end_src\n?\n#+begin_src forth" "<src lang=\"?\">\n\n</src>")
            ("forth" "#+begin_src forth\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** ml-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-ml-family
          '(
            ;; sml
            ("smlf" "#+end_src\n?\n#+begin_src sml" "<src lang=\"?\">\n\n</src>")
            ("sml" "#+begin_src sml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; caml
            ("camlf" "#+end_src\n?\n#+begin_src caml" "<src lang=\"?\">\n\n</src>")
            ("caml" "#+begin_src caml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** asm-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-asm-family
          '(
            ;; fasm
            ("fasmf" "#+end_src\n?\n#+begin_src fasm" "<src lang=\"?\">\n\n</src>")
            ("fasm" "#+begin_src fasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; nasm
            ("nasmf" "#+end_src\n?\n#+begin_src nasm" "<src lang=\"?\">\n\n</src>")
            ("nasm" "#+begin_src nasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** mark-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-mark-language
          '(
            ;; yaml
            ("yamlf" "#+end_src\n?\n#+begin_src yaml" "<src lang=\"?\">\n\n</src>")
            ("yaml" "#+begin_src yaml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; css
            ("cssf" "#+end_src\n?\n#+begin_src css" "<src lang=\"?\">\n\n</src>")
            ("css" "#+begin_src css\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; bnf
            ("bnff" "#+end_src\n?\n#+begin_src bnf" "<src lang=\"?\">\n\n</src>")
            ("bnf" "#+begin_src bnf\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** c-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-c-family
          '(
            ;; C
            ("Cf" "#+end_src\n?\n#+begin_src C" "<src lang=\"?\">\n\n</src>")
            ("C" "#+begin_src C\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; java
            ("javaf" "#+end_src\n?\n#+begin_src java" "<src lang=\"?\">\n\n</src>")
            ("java" "#+begin_src java\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; javascript
            ("jsf" "#+end_src\n?\n#+begin_src javascript" "<src lang=\"?\">\n\n</src>")
            ("js" "#+begin_src javascript\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; lua
            ("luaf" "#+end_src\n?\n#+begin_src lua" "<src lang=\"?\">\n\n</src>")
            ("lua" "#+begin_src lua\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; perl
            ("perlf" "#+end_src\n?\n#+begin_src perl" "<src lang=\"?\">\n\n</src>")
            ("perl" "#+begin_src perl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; shell
            ("shf" "#+end_src\n?\n#+begin_src sh" "<src lang=\"?\">\n\n</src>")
            ("sh" "#+begin_src sh\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** human-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-human-language
          '(
            ;; lojban
            ("ljf" "#+end_src\n?\n#+begin_src lojban" "<src lang=\"?\">\n\n</src>")
            ("lj" "#+begin_src lojban\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** proof-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-proof-language
          '(
            ;; coq
            ("coqf" "#+end_src\n?\n#+begin_src coq" "<src lang=\"?\">\n\n</src>")
            ("coq" "#+begin_src coq\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src
*** other-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-other-family
          '(
            ;; sql
            ("sqlf" "#+end_src\n?\n#+begin_src sql :result value" "<src lang=\"?\">\n\n</src>")
            ("sql" "#+begin_src sql :result value\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; ruby
            ("rubyf" "#+end_src\n?\n#+begin_src ruby" "<src lang=\"?\">\n\n</src>")
            ("ruby" "#+begin_src ruby\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; tcl
            ("tclf" "#+end_src\n?\n#+begin_src tcl" "<src lang=\"?\">\n\n</src>")
            ("tcl" "#+begin_src tcl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; haskell
            ("hsf" "#+end_src\n?\n#+begin_src haskell" "<src lang=\"?\">\n\n</src>")
            ("hs" "#+begin_src haskell\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("xmonadf" "#+end_src\n?\n#+begin_src haskell :tangle \"~/.xmonad/xmonad.hs\"" "<src lang=\"?\">\n\n</src>")
            ("xmonad" "#+begin_src haskell :tangle \"~/.xmonad/xmonad.hs\"\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; for many kinds of conf-modes
            ("conff" "#+end_src\n?\n#+begin_src conf :tangle " "<src lang=\"?\">\n\n</src>")
            ("conf" "#+begin_src conf :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("confuf" "#+end_src\n?\n#+begin_src conf-unix :tangle " "<src lang=\"?\">\n\n</src>")
            ("confu" "#+begin_src conf-unix :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("confxf" "#+end_src\n?\n#+begin_src conf-xdefaults :tangle " "<src lang=\"?\">\n\n</src>")
            ("confx" "#+begin_src conf-xdefaults :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ))
    #+end_src
*** main
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-alist
          (append
           org-structure-template-basic

           org-structure-template-mark-language
           org-structure-template-proof-language
           org-structure-template-human-language

           org-structure-template-lisp-family
           org-structure-template-forth-family
           org-structure-template-ml-family
           org-structure-template-erlang-family

           org-structure-template-asm-family
           org-structure-template-c-family

           org-structure-template-other-family

           ))
    #+end_src
** [babel] evaluation
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook 'org-mode-hook (setq org-confirm-babel-evaluate nil))

   ;; default arguments to use when evaluating a source block
   (setq org-babel-default-header-args
         '((:session . "none")
           (:results . "replace")
           (:exports . "code")
           (:cache   . "no")
           (:noweb   . "yes")
           (:hlines  . "no")
           (:tangle  . "no")

           ;; shebang `#!' needs the following
           ;; (:padline . "no")

           (:padline . "yes")
           ))
   #+end_src
** [agenda] setting
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-agenda-files "~/.org-agenda-files")

   (global-set-key (kbd "C-M-o") 'org-cycle-agenda-files)
   (global-set-key (kbd "C-o C-b") 'org-iswitchb)
   (global-set-key (kbd "C-c a") 'org-agenda)

    (add-hook
     'org-mode-hook
     (lambda ()
       ;; 原来的 org-cycle-agenda-files 是 C-,
       ;; 我需要重新绑定它
       (local-set-key (kbd "C-,") 'ska-jump-to-register)
       ))
   #+end_src
** [agenda] org-agenda-files
   tangle take too long so just edit
   file:~/.org-agenda-files
** org to html & pdf
*** s5
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/org-mode/contrib/lisp/")
    (require 'ox-s5)
    ;; (setq org-s5-theme "railscast")   ; based off `color-theme-railscasts'
    ;; (setq org-s5-theme "default")     ; the default S5 theme
    (setq org-s5-theme "i18n")        ; the i18n theme by the author of S5
    #+end_src
*** org-pres-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/eimp/")
    (require 'eimp)

    (add-to-list 'load-path "~/.emacs.d/org-presie/")
    (require 'org-presie)
    #+end_src
*** org-tree-slide
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/org-tree-slide/")
    (require 'org-tree-slide)

    (add-hook
     'org-tree-slide-mode-play-hook
     (lambda ()
       (local-set-key (kbd "<f9>") 'org-tree-slide-move-previous-tree)
       (local-set-key (kbd "<f10>") 'org-tree-slide-move-next-tree)
       (local-set-key (kbd "<f11>") 'org-tree-slide-content)
       ))

    (global-set-key (kbd "<f8>") 'org-tree-slide-mode)

    ;; (define-key org-tree-slide-mode-map )

    ;; Reset the default setting

    ;; (define-key org-tree-slide-mode-map (kbd "<left>")  'backward-char)
    ;; (define-key org-tree-slide-mode-map (kbd "<right>") 'forward-char)
    ;; (setq org-tree-slide-skip-outline-level 4)
    ;; (org-tree-slide-narrowing-control-profile)
    ;; (setq org-tree-slide-skip-done nil)
    #+end_src
*** org-reveal
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/org-reveal/")
    (require 'ox-reveal)
    (setq org-reveal-root "/home/xyh/software/reveal.js/")
    (setq org-reveal-hlevel 2)
    #+end_src
* feature
** w3m [installed by pacman]
   #+begin_src emacs-lisp :tangle ~/.emacs
   (require 'w3m-load)
   (setq browse-url-browser-function 'w3m-browse-url)
   (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)
   ;; optional keyboard short-cut

   (add-hook
    'w3m-mode-hook
    (lambda ()
      (local-set-key (kbd "M-n") 'forward-paragraph)
      (local-set-key (kbd "M-p") 'backward-paragraph)

      (local-set-key (kbd "<down>") 'forward-paragraph)
      (local-set-key (kbd "<up>") 'backward-paragraph)

      (local-set-key (kbd "j") 'w3m-view-previous-page)
      (local-set-key (kbd "l") 'w3m-view-next-page)
      (local-set-key (kbd "i") 'w3m-previous-anchor)
      (local-set-key (kbd "k") 'w3m-next-anchor)

      (local-set-key (kbd "C-M-n") 'w3m-next-buffer)
      (local-set-key (kbd "C-M-p") 'w3m-previous-buffer)

      (local-set-key (kbd "<C-tab>") 'w3m-next-buffer)
      (local-set-key (kbd "<C-iso-lefttab>") 'w3m-previous-buffer)

      (local-set-key (kbd "e") 'w3m-edit-url)
      (local-set-key (kbd "E") 'w3m-edit-url)

      (local-set-key (kbd "q") 'quit-window)

      ;; in default setting
      ;; C-t is a prefix
      (local-set-key (kbd "C-t") 'isearch-forward)
      ))
   #+end_src
** hippie-expand
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-h") 'hippie-expand)
   (setq hippie-expand-try-functions-list
             '(try-expand-dabbrev
           try-expand-dabbrev-visible
           try-expand-dabbrev-all-buffers
           try-expand-dabbrev-from-kill
           try-complete-file-name-partially
           try-complete-file-name
           try-expand-all-abbrevs
           try-expand-list
           try-expand-line
           pcomplete
           try-complete-lisp-symbol-partially
           try-complete-lisp-symbol
           ))
   #+end_src
** primary-clipboard-yank
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; ;; (eshell-command &optional COMMAND ARG)
   ;; ;; Execute the Eshell command string COMMAND
   ;; ;; With prefix ARG, insert output into the current buffer at point

   ;; (shell-command "xterm &")
   ;; (eshell-command "xterm &")

   ;; ;; 下面这句会开一个out-put-buffer然后显示输出的东西
   ;; (eshell-command "parcellite -p")
   ;; ;; == (eshell-command "parcellite -p" nil)


   ;; ;; 下面这个不开out-put-buffer会把光标停在粘贴的东西前面
   ;; (eshell-command "parcellite -p" nil)


   ;; ;; (eshell-command-result "parcellite -p")
   ;; ;; 下面这个会把光标停在粘贴的东西后面
   ;; (insert (eshell-command-result "parcellite -p"))

   ;; ;; 下面这个函数虽然跑的快
   ;; ;; 但是从emacs的kill-ring中粘贴东西的时候却会死掉
   ;; ;; (insert (shell-command-to-string "parcellite -p"))


   (defun primary-clipboard-yank ()
     (interactive)
     (insert (eshell-command-result "clipit -p")))
   (global-set-key (kbd "C-M-y") 'primary-clipboard-yank)
   #+end_src
** gc optimization
   * gc-cons-threshold
     #+begin_src emacs-lisp :tangle ~/.emacs
     (setq gc-cons-threshold 20000000)
     #+end_src
   * Emacs's garbage collector is fairly primitive stop the world type.
     GC time can contribute significantly to the run-time of computation that allocates and frees a lot of memory.
   * Consider the following example:
     #+begin_src emacs-lisp
     (defun uuid ()
       (format "%08x-%08x-%08x-%08x"
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 4))))

     (benchmark-run 1
       (let ((cache (flx-make-filename-cache)))
             (dolist (i (number-sequence 0 10000))
               (flx-process-cache (uuid) cache))))
             ;;; ⇒ (0.899678 9 0.33650300000000044)
     #+end_src
   * This means that roughly 30% of time is spent just doing garbage-collection.
   * flx can benefit significantly from garbage collection tuning.
   * By default Emacs will initiate GC every 0.76 MB allocated (gc-cons-threshold == 800000).
     If we increase this to 20 MB (gc-cons-threshold == 20000000) we get:
     #+begin_src emacs-lisp
     (benchmark-run 1
       (setq gc-cons-threshold 20000000)
       (let ((cache (flx-make-filename-cache)))
             (dolist (i (number-sequence 0 10000))
               (flx-process-cache (uuid) cache))))
             ;;; ⇒ (0.62035 1 0.05461100000000041)
     #+end_src
** [not using] auto-overlay
   :tangle ~/.emacs
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/auto-overlays/")
   (require 'auto-overlays)
   (require 'auto-overlay-common)
   (require 'auto-overlay-flat)
   (require 'auto-overlay-line)
   (require 'auto-overlay-nested)
   (require 'auto-overlay-self)
   (require 'auto-overlay-word)
   (require 'auto-overlays-compat)
   #+end_src
*** test
    #+begin_src emacs-lisp
    (auto-overlay-load-definition
              'latex
              '(word ("\\\\[[:alpha:]]*?\\([^[:alpha:]]\\|$\\)"
                      (face . (background-color . "blue")))))
    #+end_src
** ido
*** main
    use C-f during file selection to switch to regular find-file
    #+begin_src emacs-lisp :tangle ~/.emacs
    (ido-mode t)
    (ido-everywhere t)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length 0)
    (setq ido-use-virtual-buffers t)
    #+end_src
*** ido-ubiquitions
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/package/ido-ubiquitous/")
    (require 'ido-ubiquitous)
    (ido-ubiquitous-mode t)
    #+end_src
*** flx-ido
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/flx/")
    (require 'flx-ido)
    (ido-mode 1)
    (ido-everywhere 1)
    (flx-ido-mode 1)
    ;; disable ido faces to see flx highlights.
    (setq ido-use-faces nil)
    #+end_src

    If don't want to use the flx's highlights you can turn them off like this:
    #+begin_src emacs-lisp :tangle no
    (setq flx-ido-use-faces nil)
    #+end_src
*** ido-vertical-mode
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/ido-vertical-mode/")
    (require 'ido-vertical-mode)
    (ido-mode 1)
    (ido-vertical-mode 1)
    #+end_src
** smex
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/package/smex/")
   (require 'smex)

   (global-set-key (kbd "M-x") 'smex)
   (global-set-key (kbd "M-X") 'smex-major-mode-commands)
   #+end_src
** cua-selection-mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   (cua-selection-mode 1)
   #+end_src
** popwin
   *needed by guide-key*
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/popwin/")
   #+end_src
** [NOT USING] guide-key
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/guide-key/")
   (require 'guide-key)

   (setq guide-key/guide-key-sequence
             '("C-x r"
           "C-x 4"
           "C-x 5"
           "C-c C-v"))
   (setq guide-key/highlight-command-regexp "rectangle")

   ;; (setq guide-key/guide-key-sequence '("C-x"))
   ;; (setq guide-key/recursive-key-sequence-flag t)

   (defun guide-key/my-hook-function-for-org-mode ()
     (guide-key/add-local-guide-key-sequence "C-c")
     (guide-key/add-local-guide-key-sequence "C-c C-x")
     (guide-key/add-local-guide-key-sequence "C-c C-v")
     (guide-key/add-local-highlight-command-regexp "org-"))
   (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)

   ;; (setq guide-key/guide-key-sequence
   ;;       '("C-x r" "C-x 4"
   ;;         (org-mode "C-c C-x")
   ;;         (outline-minor-mode "C-c @")))

   (setq guide-key/idle-delay 2.7)

   ;; This variable controls where a guide-key buffer is popped up.
   ;; A value of this variable is one of right, bottom, left, top. The default value is right.
   (setq guide-key/popup-window-position 'bottom)

   ;; This variable controls the size of text in guide buffer.
   ;; The default value is 0 (it means default size in Emacs).
   ;; If you want to enlarge text, set positive number. Otherwise, set negative number.
   (setq guide-key/text-scale-amount 0)


   ;; Enable guide-key-mode
   (guide-key-mode 1)
   #+end_src
** rcirc
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/irc/")
   (require 'rcirc)

   ;; (require 'rcirc-ding)
   ;; (setq alert "~/play/Tanna_japonensis_v01.wav")
   ;; (defun my-rcirc-print-hook (process sender response target text)
   ;;   (when (and (string-match (regexp-quote (rcirc-nick process)) text)
   ;;              (not (string= (rcirc-nick process) sender))
   ;;              (not (string= (rcirc-server-name process) sender)))
   ;;     (start-process "beep" nil "aplay" (expand-file-name alert))))
   ;; (add-hook 'rcirc-print-hooks 'my-rcirc-print-hook)
   ;; ;; Starting from Emacs 24.3 rcirc-print-hooks is deprecated use rcirc-print-functions instead
   ;; (add-hook 'rcirc-print-functions 'my-rcirc-print-hook)


   (setq rcirc-default-nick "xyh")
   ;; (setq rcirc-default-port "6666")
   (setq rcirc-default-user-name "xieyuheng")
   (setq rcirc-default-full-name "XIE Yuheng")

   (setq rcirc-server-alist
          '(("irc.freenode.net" :port 6697 :encryption tls
             :channels ("#forth"
                        "#cicada-language"
                        "#szdiy"
                        "#scheme"
                        ;; "#guile"
                        ;; "#lisp"
                        "#ccl"
                        ;; "#coq"
                        ;; "#shen"
                        ;; "#haskell"
                        ;; "#minikanren"
                        ;; "#erlang"
                        ;; "#erlang-lisp"
                        ;; "#osdev"
                        ;; "#fcitx"
                        "#archlinux-cn"
                        ))))

   ;; gnutls.c: [1] Note that
   ;; the security level of the Diffie-Hellman key exchange
   ;; has been lowered to 256 bits
   ;; and this may allow decryption of the session data
   ;; If you’re getting this warning, add the following to your init file:
   (setq gnutls-min-prime-bits 1024)
   #+end_src
** circe
   #+begin_src emacs-lisp :tangle "~/.emacs"
   (add-to-list 'load-path "~/.emacs.d/circe/lisp")
   (require 'circe)

   (setq circe-network-options
         `(("Freenode"
            :nick "xyh"
            :channels ("#forth"
                       "#cicada-language"
                       "#szdiy"
                       "#scheme"
                       ;; "#guile"
                       ;; "#lisp"
                       ;; "#ccl"
                       ;; "#coq"
                       ;; "#shen"
                       ;; "#haskell"
                       ;; "#minikanren"
                       ;; "#erlang"
                       ;; "#erlang-lisp"
                       ;; "#osdev"
                       ;; "#fcitx"
                       "#archlinux-cn"
                       ))))
   #+end_src
** muse
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/muse/lisp/")

   (require 'muse-mode); load authoring mode
   (require 'muse-html); load publishing styles I use
   (require 'muse-latex)
   (require 'muse-texinfo)
   (require 'muse-docbook)
   (require 'muse-project); publish files in projects


   (setq muse-html-content-coding "utf-8")
   (setq muse-html-charset-default "utf-8")
   (setq muse-html-coding-default "utf-8")

   ;; (custom-set-variables
   ;;  '(muse-file-extension nil)
   ;;  '(muse-mode-auto-p t)
   ;;  '(muse-file-extension "muse")
   ;;  '(muse-html-meta-content-encoding (quote utf-8))
   ;;  '(muse-html-charset-default "utf-8")
   ;;  '(muse-html-encoding-default (quote utf-8))
   ;;  '(muse-html-encoding-map "utf8")
   ;;  '(muse-colors-autogen-headings (quote outline))
   ;;  '(muse-html-meta-content-encoding (quote utf-8))
   ;;  '(muse-html-meta-content-type "text/xhtml; charset=utf-8"))

   (add-hook 'muse-mode-hook
    (lambda ()
      (local-set-key (kbd "M-<tab>") 'window->)
      (local-set-key (kbd "M-9") 'move-line-backword)
      (local-set-key (kbd "M-0") 'move-line-foreword)
      (local-set-key (kbd "C-c C-c") 'muse-project-publish)
      ))
   #+end_src
** muse-project-alist
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq muse-project-alist
             '(

           ("cicada"
            ("~/cicada/readings"
             :default "cicada")
            (:base "xelatex"
             :path "~/cicada/readings/xelatex"))

           ("cicada--cn"
            ("~/cicada/readings-chinese"
             :default "cicada-chinese")
            (:base "xelatex"
             :path "~/cicada/readings-chinese/xelatex"))

           ))
   #+end_src
** htmlize
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/htmlize/")

   (require 'htmlize)
   (setq htmlize-output-type 'css)
   ;; (setq htmlize-output-type 'inline-css)
   ;; (setq htmlize-output-type 'font)
   #+end_src
** uniquify
   #+begin_src emacs-lisp :tangle ~/.emacs
   (require 'uniquify)
   ;(setq uniquify-buffer-name-style 'reverse)
   (setq uniquify-buffer-name-style 'forward)
   #+end_src
** hg
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/hg/")
   (require 'mercurial)
   (require 'mq)

   (add-hook 'hg-mode-hook
             (lambda ()
                   (local-set-key (kbd "C-c h l") 'hg-log-repo-and-change-mode)))
   (defun hg-log-repo-and-change-mode ()
     (interactive)
     (hg-log-repo (hg-root))
     (vc-hg-log-view-mode))
   #+end_src
** magit
   * compile by
     EFLAGS="-L ~/.emacs.d/git-modes" make lisp
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/git-modes/")
   (add-to-list 'load-path "~/.emacs.d/magit/")
   (require 'magit)

   ;; And optionally tell `info` about the documentation
   (eval-after-load 'info
     '(progn (info-initialize)
             (add-to-list 'Info-directory-list "~/.emacs.d/magit/")))

   (global-set-key (kbd "C-x g") 'magit-status)
   #+end_src
** send mail
   * Gmail SMTP server address: smtp.gmail.com
     Gmail SMTP user name: Your full Gmail address (e.g. example@gmail.com)
     Gmail SMTP password: Your Gmail password
     Gmail SMTP port: 465
     Gmail SMTP TLS/SSL required: yes
   * Gmail IMAP server address: imap.gmail.com
     Gmail IMAP user name: Your full Gmail address (e.g. "me@gmail.com")
     Gmail IMAP password: Your Gmail password
     Gmail IMAP port: 993
     Gmail IMAP TLS/SSL required: yes
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (setq send-mail-function 'mailclient-send-it)
   (setq send-mail-function 'smtpmail-send-it)
   (setq smtpmail-smtp-server "smtp.gmail.com")
   (setq smtpmail-smtp-service 25)
   #+end_src
** message
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq user-full-name "XIE Yuheng"
         user-mail-address "xyheme@gmail.com"
         message-auto-save-directory "~/mail/draft")
   #+end_src
** [NOT USING] gnus
*** tangle to ~/.emacs
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/gnus/lisp/")
    (require 'gnus-load)
    ;; (setq debug-on-error t)
    #+end_src
*** tangle to ~/.gnus.el
    #+begin_src emacs-lisp :tangle ~/.gnus.el
    (setq user-full-name "XIE Yuheng")
    (setq user-mail-address "xyheme@gmail.com")

    (setq gnus-select-method '(nntp "freenews.netfront.net"))
    ;; (add-to-list 'gnus-secondary-select-methods '(nntp "news.gnus.org"))
    ;; (add-to-list 'gnus-secondary-select-methods '(nntp "forums.sybase.com"))


    ;; 香港新闻组
    ;; news.newsgroup.com.hk
    ;; freenews
    ;; freenews.netfront.net
    ;; sybase新闻组(英文)
    ;; forums.sybase.com
    ;; 以上三个服务器在大陆以外且参预全球转信

    ;; 希网新闻组
    ;; news.cn99.com 或 news.yaako.com
    ;; 大陆唯一参预全球转信的新闻组服务器
    #+end_src
** [NOT USING] bbdb
   #+begin_src emacs-lisp
   (add-to-list 'load-path "~/.emacs.d/bbdb-2.35/lisp/")
   (require 'bbdb)
   (bbdb-initialize 'gnus 'message)
   (setq bbdb-north-american-phone-numbers-p nil)
   #+end_src
** tramp
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq tramp-persistency-file-name "~/.emacs.d/about-tramp/.tramp-connection-history")

   (setq tramp-default-user "xyh"
             tramp-default-host "XYH")

   (setq tramp-default-method "ssh")
   #+end_src
** hlinum
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/hlinum-mode/")
   (require 'hlinum)
   (hlinum-activate)
   #+end_src
* emacs server & eshell
** -------------------------------------
** note
   * 需要與 bash 或 zsh 配合使用
     給 emacsclient 以 "e" 爲其別名
     並注意設置 emacsclient 的命令行參數
   * 但是如果先有一个 emacs-sever
     再打开 emacs 時 就会有警告
     我保留对这个警告的显示
     因为它提示了当前 emacs-sever 的开启状态
     (server-force-delete)
   * 因此常使用的方式是
     将(server-start)写在.emacs中
     将alias e='emacsclient -c -a "" -e \(eshell\)'写在.bashrc中
     第一个 emacs 在终端中用 emacs 打开
     之后在终端中使用 e 就会以这个 emacs 为 sever
     退出这第一个 emacs 之后就会关闭被它打开的 emacs-sever
** emacs server
   #+begin_src emacs-lisp :tangle ~/.emacs
   (server-start)
   ;; (setq server-name "><")
   ;; (server-force-delete)
   #+end_src
** -------------------------------------
** load-path
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/eshell/")
   #+end_src
** hook
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook
    'eshell-mode-hook
    (lambda ()
      (local-set-key (kbd "C-c h")
                     (lambda ()
                           (interactive)
                           (insert
                            (ido-completing-read "eshell history: "
                                             (delete-dups
                                              (ring-elements eshell-history-ring))))))
      (local-set-key (kbd "C-c C-h") 'eshell-list-history)))
   #+end_src
** how to use
*** startup scripts
    *for i use org-mode, this is not very useful*
    like most shells,
    eshell supports both login and profile/rc shell scripts
    The full filepaths for both are stored in the variables
    eshell-login-script and eshell-rc-script
    but by default the files login and profile are stored in ~/.eshell/

    It bears mention that the comment syntax is #
*** jump
    it maintains a ring the last 32 directories seen.

    To view the ring: ‘cd =’
    Changing to an index within the ring: ‘cd -4’
    Note that ‘cd -’ is the same as ‘cd -0’
    Use a regular expression: ‘cd =regexp’

    The ring is saved in ‘~/.eshell/lastdir’.
    You can increase the ring size by setting ‘eshell-last-dir-ring-size’.
    Perhaps this is good enough for you, making autojump unnecessary.
    The only benefit autojump offers is that it sorts the entries
    by how often you switched there instead of when you switched there.
** alias
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; eshell will write the alias definitions to eshell-aliases-file
   (setq eshell-aliases-file "~/.emacs.d/eshell/alias")
   ;; which in turn is governed by the eshell-directory-name
   (setq eshell-directory-name "~/.emacs.d/eshell/")
   #+end_src
   [[~/.emacs.d/eshell/alias]]
   Another useful thing to know is the auto-correcting aliasing.
   If you type an invalid command too many times
   (governed by eshell-bad-command-tolerance, which is 3 by default)
   Eshell will offer to alias it to its intended command for you
** commands history
   to use ido-completing-read to access to eshells history
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook 'eshell-mode-hook
                    (lambda ()
                      (local-set-key (kbd "M-<tab>") 'window->)))
   #+end_src
** [not using] eshell-autojump
   1. Use ‘j’ to list your favorite directories
      (as determined by your usage of ‘cd’).
      Use ‘j regexp’ to jump to your most favorite directory
      matching the regular expression.
   2. Your favorite directories are saved in ‘~/.eshell/autojump’.
   3. Instead of measuring
      how much time you spend in a particular directory,
      I just measure how often
      you switch to a particular directory.
      The code hooks into ‘eshell-directory-change-hook’.
      #+begin_src emacs-lisp :tangle ~/.emacs
      ;; (eval-after-load 'eshell
      ;;   '(require 'eshell-autojump nil t))
      #+end_src
** -------------------------------------
** make multi eshell work much easier
*** note
    通过于窗口管理器(xmonad)合作来完成这个任务
    即 在窗口管理器中绑定使用emacsclient的快捷键
    并让emacsclient在启动时执行(eshell t)
*** experiment
**** about eshell
     #+begin_src emacs-lisp
     (setq eshell-buffer-name "*eshell*")

     ;; 打开名字为*eshell*的eshell
     ;; 如果已经有了就转到那个buffer
     (eshell)
     ;; == (eshell nil)

     ;; 打开名字为*eshell*<3>的eshell
     ;; 如果已经有了就转到那个buffer
     (eshell 3)

     ;; (generate-new-buffer-name "*eshell*")返回一个名字
     ;; 用这个名字打开一个eshell
      (eshell t)
     #+end_src
**** about rename-buffer
     #+begin_src emacs-lisp
     ;; 下面将使 使用已经存在的buffer的名字时不报错
     ;; 而是用generate-new-buffer-name函数生成具有唯一性的新名字
     (rename-buffer "*eshell*" t)


     ;; 已经有名为*eshell*的buffer的时候测试下面三句
     (generate-new-buffer-name "*eshell*")
     (eshell 2)
     (generate-new-buffer-name "*eshell*")

     ;; 已经有名为* eshell*的buffer的时候测试下面一句
     ;; 要知道名字的第一个字符是带空格的buffer是用户在一般情况下不能触及的
     (generate-new-buffer-name " *eshell*")


     ;; 下面这句也调用上面的函数
     ;; 但是是真正打开一个buffer
     ;; 而上面只是返回名字
     (generate-new-buffer "kkk")

     ;; 所以我需要的是下面的一句
     (generate-new-buffer-name "*eshell*")
     #+end_src
**** about buffer-name
     #+begin_src emacs-lisp
     (insert (buffer-name))
     (switch-to-buffer "*eshell*")
     #+end_src
**** about frame-parameter
     #+begin_src emacs-lisp
     (frame-parameter nil 'title)

     (frame-parameter nil 'cursor-type)

     (frame-parameter nil 'name)
     (frame-parameter nil 'explicit-name)

     (set-frame-parameter nil 'name "kkk")
     #+end_src
*** open-eshell-in-emacsclient
    1. 为emacsclient而开的有eshell的frame
       frame name与其中的eshell name统一
    2. 每次为emacsclient而开一个frame之后
       就可以用(frame-parameter nil 'name)来使用这个字符串了
    3. 但是下面解决问题的方法又用到了eshell
       因为emacs的dynamic-scope太让人心烦了
    4. 尽管如此这样也是合理的
       是要在emacsclient中打开eshell
       既然打开了eshell就让这个eshell做点事儿吧
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun open-eshell-in-emacsclient ()
      (progn
            (eshell t)
            (insert "(set-frame-parameter nil 'name (buffer-name))")
            (eshell-send-input)
            (insert "(set-frame-parameter nil 'cursor-type 'hollow)")
            (eshell-send-input)
            ))
    #+end_src
*** my-switch-to-eshell
    下面是黄金搭档``previous-buffer''
    + scheme的repl也是这样开启的
    也就是说C-s C-e这个键绑定的切换函数
    只帮助在当前buffer和主要的那个名叫*eshell*的buffer之间切换
    并且在这之间到别的buffer的切换就将破坏这个函数的效果
    这也许是合理的 也许不是
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-switch-to-eshell ()
      (interactive)

      (cond
       ((not (frame-parameter nil 'explicit-name))
        (eshell))
       (t
        ;; at most, 9 eshell, opened by emacsclient, with eshell as frame-name
        (eshell
         (- (elt (string-to-vector (frame-parameter nil 'name))
                 9)
            48))))

      (local-set-key (kbd "C-s C-e") 'previous-buffer))

    (global-set-key (kbd "C-s C-e") 'my-switch-to-eshell)
    #+end_src
*** eshell/delete-char-or-kill-buffer
    1. (goto-char (point-max)) == (end-of-buffer)
    2. 在emacs中efb的识别方式有很多 比如:
       1. (eq (following-char) 0)
          (char-equal (following-char) 0)
       2. (eq (point-max) (point))
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun eshell/delete-char-or-kill-buffer ()
      (interactive)

      (point-to-register ?e)
      (eshell-bol)

      (if (eq (point-max) (point))
              (progn
            (kill-buffer)
            (delete-frame))
            (progn
              (jump-to-register ?e)
              (delete-char 1))))

    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-d") 'eshell/delete-char-or-kill-buffer)))
    #+end_src
*** eshell-prompt-function
    #+begin_src emacs-lisp :tangle ~/.emacs
    (set 'eshell-prompt-function
      (function
       (lambda ()
         (concat (number-to-string eshell-last-command-status)
                 ": " (eshell/pwd) " "
                 (newline)
                 ;; (if (= (user-uid) 0) " # " " $ ")
                 ))))
    #+end_src
** -------------------------------------
** self-defun (before eshell open)
*** take-opera-downloaded
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-opera-downloaded-taker ()
      (interactive)

      (setq current-path (eshell/pwd))
      (eshell/cd "~/.opera/temporary_downloads/")

      (insert "mv * ")
      (insert current-path)
      (eshell-send-input)

      (insert current-path)
      (eshell-send-input)
      )
    #+end_src
*** ``cd ..''
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-cd-back ()
      (interactive)
      (insert "cd ..")
      (eshell-send-input))
    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "<C-M-backspace>") 'my-cd-back)))
    #+end_src
*** rebinding normal move-beginning-of-line
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-S-a") 'move-beginning-of-line)))
    #+end_src
** init a eshell when open emacs
*** using
    #+begin_src emacs-lisp :tangle ~/.emacs
    (eshell)
    #+end_src
*** init with something (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    ;; for this line in my ~/.xinitrc do not work
    (insert "xmodmap ~/.xmodmap")
    ;; 每次都插入这一句就起到保险的效果
    ;; 同时也给出一个快速重新加载~/.xmodmap的方法
    ;; xmodmap是一个非常底层的工具 并不了解键盘布局的设置
    ;; 对X11来说 键盘布局是建立在一组预设文件上
    ;; 当预设文件加载时 所有通过xmodmap加载的配置都将被覆盖
    ;; 所有进行键盘布局设置的工具都是如此
    ;; 比如当fcitx启动时
    (eshell-send-input)
    #+end_src

    #+begin_src emacs-lisp
    ;; for my ~/.xinitrc do not work
    (insert "xmodmap ~/.xmodmap && \
             xrdb -load ~/.Xresource && \
             ~/wallpaper/random-wallpaper.sh && \
             xcompmgr &")
    (eshell-send-input)
    #+end_src

    每次tangle之后都要重设~/.eshell-open-with-script.sh的权限
    #+begin_src emacs-lisp
    (eshell-command "chmod 777 ~/.eshell-open-with-script.sh")
    #+end_src

    :tangle "~/.eshell-open-with-script.sh"
    #+begin_src sh
    xcompmgr &
    ~/wallpaper/random-wallpaper.sh &
    #+end_src

** var-setting (after open eshell)
*** to avoid completion cycling (using completion cycling)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (setq eshell-cmpl-cycle-completions nil)
    #+end_src
*** visual commands
    1. eshell will run a term session
       when you invoke a command eshell considers visual
       to support these commands
    2. to modify the list of visual commands
       you can alter eshell-visual-commands
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'eshell-visual-commands "ranger")
    (add-to-list 'eshell-visual-commands "w3m")
    #+end_src
*** bash history save
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq eshell-hist-ignoredups t)
    #+end_src
** -------------------------------------
** pcomplete/git
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defconst pcmpl-git-commands
     '("add" "bisect" "branch" "checkout" "clone"
           "commit" "diff" "fetch" "grep"
           "init" "log" "merge" "mv" "pull" "push" "rebase"
           "reset" "rm" "show" "status" "tag" )
     "List of `git' commands")
   (defun pcomplete/git ()
     "Completion for `git'"
     (pcomplete-here* pcmpl-git-commands))
   #+end_src
** -------------------------------------
* looks like
** font
*** <f7>
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defvar *toggle-font-for-the-show* nil)
    (defun toggle-font-for-the-show ()
      (interactive)
      (if (eq *toggle-font-for-the-show* t)
          (progn
            ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 20))
            ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
            (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 20))
            ;; (set-face-attribute 'default nil :family "monofur" :height 140)
            (set-face-attribute 'default nil :family "Envy Code R" :height 140)
            (setq *toggle-font-for-the-show* nil))
          (progn
            ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 32))
            ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 32))
            (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 34))
            ;; (set-face-attribute 'default nil :family "monofur" :height 240)
            (set-face-attribute 'default nil :family "Envy Code R" :height 240)
            (setq *toggle-font-for-the-show* t))))
    (global-set-key (kbd "<f7>") 'toggle-font-for-the-show)
    #+end_src
*** note
    用下面所使用的连个函数配置emacs的字体的时候
    其他一些程序(比如firefox)的字体配置也会跟着改变

    "AR PL SungtiL GB" 文鼎PL简报宋
    "AR PL KaitiM GB" 文鼎PL简中楷

    "AR PL UKai" 文鼎PL中楷
    "AR PL UMing" 文鼎PL细上海宋

    "WenQuanYi Micro Hei" 文泉驿微米黑
    "WenQuanYi Zen Hei" 文泉驿正黑
    "WenQuanYi Bitmap Song" 文泉驿点阵宋体

    (set-fontset-font NAME TARGET FONT-SPEC &optional FRAME ADD)
    + NAME is a fontset name string
      nil for the fontset of FRAME
      or t for the default fontset
    + TARGET
      1. may be a cons: (FROM . TO)
         where FROM and TO are characters
         In that case
         use FONT-SPEC for all characters
         in the range FROM and TO (inclusive)
      2. may be a script name symbol
         In that case
         use FONT-SPEC for all characters
         that belong to the script
      3. may be a charset
         In that case
         use FONT-SPEC for all characters in the charset
      4. may be nil
         In that case
         use FONT-SPEC for any characters
         for that no FONT-SPEC is specified
    use the following function in *ielm* buffer
    to print script name symbol in emacs
    #+begin_src emacs-lisp
    (char-table-extra-slot char-script-table 0)
    #+end_src
*** test
    λλλλλλ|
    中英等宽测试|
    sdasddassaas|
    λλλλλλλλλλλλ|
*** 楷
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 20))
    ;; (set-fontset-font t 'han (font-spec :name "H\-宮書" :size 20))
    #+end_src
*** 宋
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "HanaMinA" :size 32))
    ;; (set-fontset-font t 'han (font-spec :name "HAN NOM A" :size 32))
    ;; (set-fontset-font t 'han (font-spec :name "H\-秀月" :size 32))
    ;; (set-fontset-font t 'han (font-spec :name "simsun" :size 32))
    (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 20))
    #+end_src
*** 黑
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "H\-雲林呉竹体" :size 20))
    ;; (set-fontset-font t 'han (font-spec :name "H\-明蘭" :size 20))
    ;; (set-fontset-font t 'han (font-spec :name "WenQuanYi Micro Hei Mono" :size 20))
    ;; (set-fontset-font t 'han (font-spec :name "H\-儷黑" :size 20))
    ;; (set-fontset-font t 'han (font-spec :name "H\-新雅蘭" :size 20))
    #+end_src
*** 英
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-face-attribute 'default nil :family "monaco" :height 120)
    ;; (set-face-attribute 'default nil :family "mono" :height 120)
    ;; (set-face-attribute 'default nil :family "monofur" :height 140)
    ;; (set-face-attribute 'default nil :family "lmmono10" :height 140)
    ;; (set-face-attribute 'default nil :family "lmmonocaps10" :height 140)
    ;; (set-face-attribute 'default nil :family "lmmonolt10" :height 140)
    (set-face-attribute 'default nil :family "Envy Code R" :height 140)
    #+end_src
*** 符
    #+begin_src emacs-lisp :tangle ~/.emacs
    (set-fontset-font t 'symbol (font-spec :name "mono"))
    ;; (set-fontset-font t 'symbol (font-spec :name "STIXGeneral"))
    #+end_src
*** 希臘
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'greek (font-spec :name "Porson"))
    ;; (set-fontset-font t 'greek (font-spec :name "mono"))
    ;; (set-fontset-font t 'greek (font-spec :name "STIXGeneral"))
    ;; (set-fontset-font t 'greek (font-spec :name "Code2000"))
    ;; (set-fontset-font t 'greek (font-spec :name "ALPHA\-Demo"))
    (set-fontset-font t 'greek (font-spec :name "FreeMono"))

    ;; α  Α     β  Β     γ  Γ     δ  Δ     ε  Ε
    ;; ζ  Ζ     η  Η     θ  Θ     ι  Ι     κ  Κ
    ;; λ  Λ     μ  Μ     ν  Ν     ξ  Ξ     ο  Ο
    ;; π  Π     ρ  Ρ     ς  ΢     σ  Σ     τ  Τ
    ;; υ  Υ     φ  Φ     χ  Χ     ψ  Ψ     ω  Ω
    #+end_src
** theme
   [[~/.emacs.d/theme/molokai/molokai-theme.el]]
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/molokai/")

   (setq molokai-theme-kit t)
   (load-theme 'molokai t)

   ;; (load-file  "~/.emacs.d/theme/chocolate-rain/chocolate-rain.el")


   ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/color-theme-molokai/")
   ;; (load-theme 'molokai t)

   ;; (add-to-list 'load-path "~/.emacs.d/theme/color-theme-6.6.0/")
   ;; (require 'color-theme)
   ;; (color-theme-initialize)
   #+end_src
** translucent
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "<f12>") 'loop-alpha)
   ;; 当前窗口和非当前窗口时透明度
   (setq alpha-list '((85 60) (100 100)))
   (defun loop-alpha ()
     (interactive)
     (let* ((h (car alpha-list))
            (a (car h))
            (ab (car (cdr h))))
           (set-frame-parameter (selected-frame) 'alpha (list a ab))
           (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))
           (setq alpha-list (cdr (append alpha-list (list h))))
           ))
   ;; 启动窗口时时自动开启窗口半透明效果
   (loop-alpha)
   #+end_src
** [not using] frame title
   * display buffer name or absolute file path name in the frame title
   #+begin_src emacs-lisp
   (defun frame-title-string ()
     "Return the file name of current buffer, using ~ if under home directory"
     (let
             ((fname (or
                      (buffer-file-name (current-buffer))
                      (buffer-name)))
              (max-len 100))
           (when (string-match (getenv "HOME") fname)
             (setq fname (replace-match "~" t t fname)))
           (if (> (length fname) max-len)
           (setq fname
                     (concat "..."
                             (substring fname (- (length fname) max-len)))))
           fname))
   ;; (setq frame-title-format '(:eval (frame-title-string)))
   (setq frame-title-format '("emacs-pirate@"(:eval (frame-title-string))))
   #+end_src
** no-bother
   #+begin_src emacs-lisp :tangle ~/.emacs
   (mouse-avoidance-mode 'animate)
   (setq inhibit-startup-message t)
   (setq initial-scratch-message "")

   (tool-bar-mode -1)
   (menu-bar-mode -1)
   (scroll-bar-mode -1)

   (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src
** cursor-type
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (set-frame-parameter nil 'cursor-type 'hollow)
   (set-frame-parameter nil 'cursor-type 'box)
   ;; (set-frame-parameter nil 'cursor-type 'bar)
   ;; (set-frame-parameter nil 'cursor-type '(bar . 2))
   ;; (set-frame-parameter nil 'cursor-type 'hbar)
   ;; (set-frame-parameter nil 'cursor-type '(hbar . 8))
   #+end_src
** rainbow-delimiters
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/rainbow-delimiters/")
   (require 'rainbow-delimiters)

   (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
   (add-hook 'lfe-mode-hook 'rainbow-delimiters-mode)

   ;; (add-hook 'cicada-mode-hook 'rainbow-delimiters-mode)

   ;; (global-rainbow-delimiters-mode)
   #+end_src
* ===================================
