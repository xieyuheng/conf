#+title: init emacs ^-^

* lib

** change-parentheses

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/conf/emacs/xyhlib/")
   (require 'xyhlib)

   (global-set-key (kbd "M-[") 'change-parentheses)
   #+end_src

** member-string?

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun member-string? (x l)
     (cond ((null l) nil)
           ((string-equal x (car l))
            t)
           (:else
            (member-string? x (cdr l)))))
   #+end_src

** <C-f1> & <C-f2>

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-<C-f1> ()
     (interactive)
     (forward-word)
     (delete-char 1)
     (insert "-"))
   (global-set-key (kbd "<C-f1>") 'my-<C-f1>)

   (defun my-<C-f2> ()
     (interactive)
     (forward-word)
     (delete-char 1)
     (insert "_"))
   (global-set-key (kbd "<C-f2>") 'my-<C-f2>)
   #+end_src

** generator

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defvar number-generator:*counter* 0)
   (defun number-generator ()
     (setq number-generator:*counter* (+ number-generator:*counter* 1))
     number-generator:*counter*)
   #+end_src

** needed

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/dash/")
   (require 'dash)

   (add-to-list 'load-path "~/.emacs.d/epl/")
   (require 'epl)

   (add-to-list 'load-path "~/.emacs.d/seq.el/")
   (require 'seq)
   #+end_src

** load xrdb

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun xrdb ()
     (interactive)
     (eshell-command "xrdb ~/.Xresource"))
   #+end_src

* key binding

** unbinding

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; orientally: transpose-words
   (global-set-key (kbd "M-t") 'nil)
   (global-set-key (kbd "M-j") 'nil)
   (global-set-key (kbd "M-k") 'nil)
   (global-set-key (kbd "M-`") 'nil)
   #+end_src

** prefix-command

   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-prefix-command 'C-s-map)
   (global-set-key (kbd "C-s") 'C-s-map)
   ;; used by:
   ;; "C-s C-r" : rename-buffer
   ;; "C-s C-s" : org-edit-src-code
   ;; "C-s C-x" : switch-to-buffer-*scheme*
   ;; "C-s C-c" : switch-to-buffer-*haskell*
   ;; "C-s C-e" : my-switch-to-eshell
   #+end_src

** cruise

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun window-> () (interactive) (other-window +1))
   (defun <-window () (interactive) (other-window -1))

   ;; 没有使用<C-tab>
   ;; 因为<C-tab>需要在 org-mode 中使用
   ;; 因为按<tab>的时候可以不放开 Ctrl 是方便的
   ;; (global-set-key (kbd "M-<tab>") 'window->)
   ;; (global-set-key (kbd "M-<tab>") (lambda () (interactive) (other-window +1)))
   (global-set-key (kbd "C-o") 'window->)

   (global-set-key (kbd "M-=") 'window->)
   (global-set-key (kbd "M--") '<-window)
   ;; (global-set-key (kbd "M-0") 'window->)
   ;; (global-set-key (kbd "M-9") '<-window)

   (global-set-key (kbd "C-x .") 'next-buffer)
   (global-set-key (kbd "C-x ,") 'previous-buffer)

   (global-set-key (kbd "C-M-.") 'next-buffer)
   (global-set-key (kbd "C-M-,") 'previous-buffer)

   (global-set-key (kbd "M-p") 'backward-paragraph)
   (global-set-key (kbd "M-n") 'forward-paragraph)
   #+end_src

** window resizing

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-M-h") 'shrink-window-horizontally)
   (global-set-key (kbd "C-M-l") 'enlarge-window-horizontally)
   (global-set-key (kbd "C-M-j") 'shrink-window)
   (global-set-key (kbd "C-M-k") 'enlarge-window)
   #+end_src

** path

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "<C-M-return>") 'pwd)
   #+end_src

** line wrap

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (global-set-key (kbd "C-M-g") 'global-visual-line-mode)
   (global-set-key (kbd "C-M-g") 'toggle-truncate-lines)
   #+end_src

** line number

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))
   #+end_src

** line height

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq-default line-spacing 20)
   #+end_src


** comment

   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-prefix-command '<menu>-map)
   (global-set-key (kbd "<menu>") '<menu>-map)
   (global-set-key (kbd "<menu> '") 'comment-region)
   (global-set-key (kbd "<menu> ;") 'uncomment-region)

   (global-set-key (kbd "C-.") 'comment-region)
   (global-set-key (kbd "C-,") 'uncomment-region)
   #+end_src

** edit

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; backward-kill-sentence

   ;; (defun say-not-binding ()
   ;;   (interactive)
   ;;   (message "this key have not binding"))

   (global-set-key (kbd "C-x <backspace>") 'delete-backward-char)
   #+end_src

** view

   - 如果不左右 scroll
     emacs 就会自动为把长的行折反到视野中来(org-mode 除外)
   - M-< : beginning-of-buffer
     M-> : end-of-buffer
     + 不要与下面的绑定混淆
       M-, : org-babel-previous-src-block
       M-. : org-babel-next-src-block
   - C-v : scroll-up-command
     M-v : scroll-down-command

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun scroll-right-as-my-wish ()
     (interactive)
     (scroll-left -1 1))
   (defun scroll-left-as-my-wish ()
     (interactive)
     (scroll-left 1 1))
   (global-set-key (kbd "<prior>") 'scroll-right-as-my-wish)
   (global-set-key (kbd "<next>") 'scroll-left-as-my-wish)
   (setq hscroll-step 1
         hscroll-margin 6)
   #+end_src

** query-replace

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq case-fold-search nil)
   (global-set-key (kbd "M-i") 'query-replace)
   (global-set-key (kbd "<C-M-i>") 'replace-string)
   #+end_src

** help

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-/") 'help)
   #+end_src

** C-x C-h

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-x C-h") 'mark-whole-buffer)
   #+end_src

** C-x k

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-x k") 'kill-this-buffer)
   #+end_src

** rename-buffer

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-s C-r") 'rename-buffer)
   #+end_src

** insert (some trick here)

   can't bind C-M-i to new function in normal way

   and TAB == C-i

   one can find:
   (kbd "C-i") == (kbd "TAB") == "	"
   (kbd "C-M-i") == [134217737]
   in elisp-repl

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (define-key input-decode-map [?\C-i] [control-i])
   ;; (global-set-key [control-i] 'insert-newline-below)

   (define-key input-decode-map [134217737] [C-M-i])
   (global-set-key [C-M-i] 'insert-newline-below)

   (defun insert-newline-below ()
     (interactive)
     (insert "\n")
     (backward-char 1))
   #+end_src

** whitespace

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key
    (kbd "C-M-w")
    (lambda ()
      (interactive)
      (message "* (whitespace-cleanup)")
      (whitespace-cleanup)))

   (global-set-key
    (kbd "M-W")
    (lambda ()
      (interactive)
      (message "* (whitespace-cleanup)")
      (whitespace-cleanup)))


   ;; 有了下面的設置 每次 C-x C-s 時 就會自動清除 whitespace
   ;; automatically clean up bad whitespace
   ;; (setq whitespace-action '(auto-cleanup))

   ;; only show bad whitespace
   (setq whitespace-style '(trailing space-before-tab indentation empty space-after-tab))

   (whitespace-mode t)
   (global-whitespace-mode t)
   #+end_src

** save-buffer

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-x C-s") (lambda () (interactive) (save-buffer) (redraw-display)))
   (global-set-key (kbd "C-s C-x") (lambda () (interactive) (save-buffer) (redraw-display)))
   #+end_src

** mouse

   #+begin_src emacs-lisp :tangle ~/.emacs
   (dolist (k '([mouse-1] [down-mouse-1] [M-down-mouse-1] [C-down-mouse-1] [drag-mouse-1] [double-mouse-1] [triple-mouse-1] [M-drag-mouse-1]
                [mouse-2] [down-mouse-2] [M-down-mouse-2] [C-down-mouse-2] [drag-mouse-2] [double-mouse-2] [triple-mouse-2] [M-drag-mouse-2]
                [mouse-3] [down-mouse-3] [M-down-mouse-3] [C-down-mouse-3] [drag-mouse-3] [double-mouse-3] [triple-mouse-3] [M-drag-mouse-3]
                [mouse-4] [down-mouse-4] [M-down-mouse-4] [C-down-mouse-4] [drag-mouse-4] [double-mouse-4] [triple-mouse-4] [M-drag-mouse-4]
                [mouse-5] [down-mouse-5] [M-down-mouse-5] [C-down-mouse-5] [drag-mouse-5] [double-mouse-5] [triple-mouse-5] [M-drag-mouse-5]
                [mouse-6] [down-mouse-6] [M-down-mouse-6] [C-down-mouse-6] [drag-mouse-6] [double-mouse-6] [triple-mouse-6] [M-drag-mouse-6]
                [mouse-7] [down-mouse-7] [M-down-mouse-7] [C-down-mouse-7] [drag-mouse-7] [double-mouse-7] [triple-mouse-7] [M-drag-mouse-7]))
     (global-set-key k (lambda () (interactive))))
   #+end_src

* general setting

** title

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq frame-title-format "%b")
   #+end_src

** variable

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq case-fold-search nil)
   (setq case-replace nil)
   (setq indent-tabs-mode nil)
   (setq-default indent-tabs-mode nil)
   ;; 全局设置上面的变量并没有用
   (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode nil)))

   (fringe-mode '(6 . 6))

   (transient-mark-mode t)

   (setq column-number-mode t)

   (setq mouse-yank-at-point t)

   (setq kill-ring-max 200)

   (setq enable-recursive-minibuffers t)

   ;; (setq scroll-margin 4)
   (setq scroll-margin 7)

   (setq scroll-conservatively 10000)

   ;; (setq default-major-mode 'org-mode)

   (show-paren-mode t)
   (setq show-paren-style 'parentheses)
   #+end_src

** enable disable

   #+begin_src emacs-lisp :tangle ~/.emacs
   (put 'set-goal-column 'disabled nil)
   (put 'narrow-to-region 'disabled nil)
   (put 'upcase-region 'disabled nil)
   (put 'downcase-region 'disabled nil)
   #+end_src

** simple version control

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq make-backup-files nil
         delete-old-versions t)

   ;; (setq  backup-by-copying t
   ;;        version-control t
   ;;        kept-new-versions 10
   ;;        kept-old-versions 0
   ;;        dired-kept-versions 1)
   #+end_src

** variable about mode

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq modes-about-lisp
         '(scheme-mode
           jojo-mode
           esse-mode
           inferior-scheme-mode

           lisp-mode
           lisp-interaction-mode

           emacs-lisp-mode
           ielm-mode
           inferior-emacs-lisp-mode
           ))

   (setq modes-about-haskell
         '(haskell-mode
           inferior-haskell-mode
           ))

   (setq modes-about-C
         '(c-mode
           ))
   #+end_src

** kill-buffer-query-functions

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq kill-buffer-query-functions nil)
   #+end_src

** tab-width

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq tab-width 2)
   #+end_src

** bell

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq visible-bell t)
   #+end_src

** autosave file

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq create-lockfiles 'nil)

   ;; Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.
   (custom-set-variables
     '(auto-save-file-name-transforms '((".*" "~/.emacs.d/autosaves/\\1" t)))
     '(backup-directory-alist '((".*" . "~/.emacs.d/backups/"))))

   ;; create the autosave dir if necessary, since emacs won't.
   (make-directory "~/.emacs.d/autosaves/" t)
   #+end_src

* input-method

** x-gtk-use-native-input

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq x-gtk-use-native-input t)
   #+end_src

** for lambda

   #+begin_src emacs-lisp :tangle ~/.emacs
   (quail-define-package
    "greek-simple" "greek" "greek-simple-title" t
    "simple greek"
    nil t nil nil nil nil nil nil nil nil t)

   (quail-define-rules
    ("\\l" ?λ))

   (set-input-method "greek-simple")

   (global-set-key (kbd "C-\\") 'toggle-input-method-with-message)

   (defun toggle-input-method-with-message ()
     (interactive)
     (toggle-input-method)
     (if (eq current-input-method nil)
         (message "input method turned off")
         (message current-input-method)))

   (add-hook 'text-mode-hook (lambda () (interactive) (toggle-input-method)))
   #+end_src

* indent-guide

** [no] indent-guide

   #+begin_src emacs-lisp :tangle no
   (add-to-list 'load-path "~/.emacs.d/indent-guide/")
   (require 'indent-guide)
   (indent-guide-global-mode)
   ;; (setq indent-guide-char ":")
   ;; (setq indent-guide-delay 0)
   (set-face-foreground 'indent-guide-face "#333333")
   (setq indent-guide-recursive t)
   #+end_src

* paren-face

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (add-to-list 'load-path "~/.emacs.d/paren-face/")
  ;; (require 'paren-face)

  ;; (global-paren-face-mode -1)
  #+end_src

* language

** edit sexp

*** load-path
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/edit-sexp/")
    #+end_src

*** mark and cruise

    - the follow functions are belong to lisp.el

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (global-set-key (kbd "s-z") 'mark-defun)
    ;; (global-set-key (kbd "s-a") 'mark-sexp)
    ;;
    ;; (global-set-key (kbd "s-w") 'backward-sexp)
    ;; (global-set-key (kbd "s-s") 'forward-sexp)
    ;;
    ;; (defun in-> () (interactive) (down-list))
    ;; (global-set-key (kbd "s-e") 'in->)
    ;;
    ;; (defun <-out () (interactive) (backward-up-list))
    ;; (global-set-key (kbd "s-q") '<-out)
    ;;
    ;; (defun out-> () (interactive) (up-list))
    ;; (global-set-key (kbd "s-d") 'out->)


    ;; (global-set-key (kbd "s-z") 'mark-defun)
    (global-set-key (kbd "M-a") 'mark-sexp)

    (global-set-key (kbd "M-e") 'backward-sexp)
    (global-set-key (kbd "M-s") 'forward-sexp)

    (defun in-> () (interactive) (down-list))
    ;; (global-set-key (kbd "M-e") 'in->)

    (defun <-out () (interactive) (backward-up-list))
    (global-set-key (kbd "M-q") '<-out)

    (defun out-> () (interactive) (up-list))
    ;; (global-set-key (kbd "s-d") 'out->)


    ;; the following is for emacs-nox which can not see s-
    (define-key input-decode-map [134217825] [M-a])
    (global-set-key [M-a] 'mark-sexp)

    ;; (global-set-key (kbd "C-M-p") 'backward-sexp)
    ;; (global-set-key (kbd "C-M-n") 'forward-sexp)

    ;; (global-set-key (kbd "C-M-f") 'in->)

    ;; (global-set-key (kbd "C-M-b") '<-out)
    #+end_src

*** paredit
    file:~/.emacs.d/edit-sexp/paredit.el
    #+begin_src emacs-lisp :tangle ~/.emacs
    (autoload 'enable-paredit-mode
        "paredit"
      "Turn on pseudo-structural editing of Lisp code." t)

    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    (add-hook 'jojo-mode-hook             #'enable-paredit-mode)
    (add-hook 'esse-mode-hook             #'enable-paredit-mode)
    (add-hook 'inferior-scheme-mode-hook  #'enable-paredit-mode)

    (add-hook 'racket-repl-mode-hook      #'enable-paredit-mode)
    (add-hook 'racket-mode-hook           #'enable-paredit-mode)


    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    ;; (add-hook 'slime-repl-mode-hook       #'enable-paredit-mode)

    (add-hook 'shen-mode-hook             #'enable-paredit-mode)
    (add-hook 'inferior-shen-mode-hook    #'enable-paredit-mode)


    ;; (add-hook 'ielm-mode-hook             #'enable-paredit-mode)

    ;; the following is about the *scratch* buffer
    ;; (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    ;; 不知道为什么这里就算使用 maybe-map-paredit-newline 也总是绑定不到 RET
    ;; 只有在下面的 mode 中不使用 enable-paredit-mode
    ;; *scratch* buffer 中的 RET 才能正常
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)


    ;; (add-hook 'haskell-mode-hook          #'enable-paredit-mode)

    ;; (add-hook 'c-mode-hook                #'enable-paredit-mode)


    (defun maybe-map-paredit-newline ()
      (cond
        ((memq major-mode '(inferior-scheme-mode
                            inferior-shen-mode
                            inferior-emacs-lisp-mode
                            lisp-interaction-mode
                            inferior-haskell-mode))
         (local-set-key (kbd "RET") 'comint-send-input))
        ((memq major-mode '(scheme-mode
                            jojo-mode
                            esse-mode
                            emacs-lisp-mode
                            lisp-mode
                            lisp-interaction-mode))
         (local-set-key (kbd "RET") 'paredit-newline))
        ))
    (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

    ;; for i want to use paredit a lot of place out of LISP
    ;; i comment out the binding of:
    ;; ";" -> paredit-semicolon
    ;; "M-;" -> paredit-comment-dwim
    ;; in the paredit.el
    (defun maybe-map-paredit-semicolon ()
      (cond
        ((memq major-mode modes-about-lisp)
         (progn
           (local-set-key (kbd ";") 'paredit-semicolon)
           (local-set-key (kbd "M-;") 'paredit-comment-dwim)))
        ))
    (add-hook 'paredit-mode-hook 'maybe-map-paredit-semicolon)
    #+end_src

*** >< a easier way to insert "(" ")" (not using)
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (defun my-insert-9 () (interactive) (insert "9"))
    (defun my-insert-0 () (interactive) (insert "0"))

    (add-hook 'scheme-mode-hook
              (lambda ()
                    (local-set-key (kbd "9") 'paredit-open-round)
                    (local-set-key (kbd "0") 'paredit-close-round)
                    (local-set-key (kbd "(") 'my-insert-9)
                    (local-set-key (kbd ")") 'my-insert-0)
                    ))
    #+end_src

*** mini-parentheses-editor
    parentheses /pəˈrɛnθəsiːz/
    is plural form of parenthesis /pəˈrɛnθəsɪs/
    #+begin_src emacs-lisp :tangle ~/.emacs
    (global-set-key (kbd "M-(")         'paredit-wrap-round)
    ;; (global-set-key (kbd "M-{")         'paredit-wrap-round)
    (global-set-key (kbd "C-M-9")       'paredit-wrap-round)
    (global-set-key (kbd "M-c")         'paredit-splice-sexp)
    (global-set-key (kbd "M-r")         'paredit-raise-sexp)

    (global-set-key (kbd "<C-right>")   'paredit-forward-slurp-sexp)
    (global-set-key (kbd "<C-left>")    'paredit-forward-barf-sexp)
    (global-set-key (kbd "M-l")   'paredit-forward-slurp-sexp)
    (global-set-key (kbd "M-h")    'paredit-forward-barf-sexp)

    (global-set-key (kbd "M-\"")        'paredit-meta-doublequote)

    (global-set-key (kbd "<C-M-right>") 'paredit-backward-barf-sexp)
    (global-set-key (kbd "<C-M-left>")  'paredit-backward-slurp-sexp)
    (global-set-key (kbd "C-M-l") 'paredit-backward-barf-sexp)
    (global-set-key (kbd "C-M-h")  'paredit-backward-slurp-sexp)

    ;; (global-set-key (kbd "C-d")         'paredit-forward-delete)
    ;; (global-set-key (kbd "<backspace>") 'paredit-backward-delete)
    ;; (global-set-key (kbd "C-k")         'paredit-kill)
    #+end_src

*** >< paredit-everywhere
    :tangle ~/.emacs
    #+begin_src emacs-lisp
    (require 'mini-paredit)

    (add-hook 'haskell-mode-hook            'mini-paredit-mode)
    (add-hook 'inferior-haskell-mode-hook   'mini-paredit-mode)

    (add-hook 'c-mode-hook                  'mini-paredit-mode)

    (add-hook 'lua-mode-hook                'mini-paredit-mode)

    (add-hook 'sml-mode-hook                'mini-paredit-mode)

    (add-hook 'coffee-mode-hook             'mini-paredit-mode)
    #+end_src

*** >< experiment
    1. 从 simple.el 中可以学到很多
       file:/usr/local/share/emacs/24.3/lisp/simple.el.gz
       尤其是当找到一个函数是在这里定义的时候

    下面是三组有用的函数
    其中 what-cursor-position 是在 simple.el 中定义的
    #+begin_src emacs-lisp
    (looking-at "")
    (what-cursor-position)
    (insert (what-cursor-position))
    (setq kkk (what-cursor-position))
    (insert kkk)

    (following-char)
    (memq 67 '("C"))
    (char-to-string 67)

    (point)

    (message "kkk")
    #+end_src

** eopl

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'auto-mode-alist '("\\.eopl\\'" . js-mode))
   #+end_src

** scheme

*** load-path

    - some scheme related files are under this dir

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/scheme/")
    (add-to-list 'load-path "~/.emacs.d/scheme/cmuscheme-init-repl/")
    #+end_src

*** scheme-mode
    file used by cmuscheme to init a *scheme* buffer
    for a prescribed interpreter's repl

    one can change the directory to save these files
    by editing the function ``scheme-start-file'' in cmuscheme.el
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-ikarus.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-csi.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-guile.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-petite.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-racket.scm
    file:/home/xyh/.emacs.d/scheme/cmuscheme-init-repl/init-mit-scheme.scm
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'cmuscheme)

    (setq scheme-program-name "scheme")
    (setq auto-mode-alist (cons `("\\.sld$" . scheme-mode) auto-mode-alist))
    (setq auto-mode-alist (cons `("\\.ss$" . scheme-mode) auto-mode-alist))
    (setq auto-mode-alist (cons `("\\.sls$" . scheme-mode) auto-mode-alist))

    (defun switch-to-buffer-*scheme* ()
      (interactive)
      (switch-to-scheme 1) ;; (switch-to-buffer "*scheme*")
      (local-set-key (kbd "C-s C-d") 'previous-buffer))
    (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*scheme*)

    (defun split-window-with-named-buffer (buffer-name-string)
      (interactive)
      (cond
       ((= 1 (count-windows))
            (progn
              ;; 下面这两个的组合总能行为正确
              (split-window-vertically (floor (* 0.68 (window-height))))
              (other-window 1)
              (switch-to-buffer buffer-name-string)
              (other-window -1)))

       ;; 只允许出现一个 scheme 窗口
       ;; 因此当发现有别的窗口的时候就在那个窗口中打开所需要的 buffer
       ((not (cl-find buffer-name-string
                  (mapcar (lambda (w) (buffer-name (window-buffer w)))
                          (window-list))
                  :test 'equal))
            (progn
              (other-window 1)
              (switch-to-buffer buffer-name-string)
              (other-window -1)))))

    (defun scheme-send-last-sexp-split-window ()
      (interactive)
      (scheme-send-last-sexp)
      (split-window-with-named-buffer "*scheme*"))

    (defun scheme-send-definition-split-window ()
      (interactive)
      (scheme-send-definition)
      (split-window-with-named-buffer "*scheme*"))

    (add-hook
     'inferior-scheme-mode-hook
     (lambda ()
       (local-set-key (kbd "C-c C-k")
                      (lambda ()
                        (interactive)
                        (kill-buffer)
                        (run-scheme scheme-program-name)))))

    (defun scheme-easy-to-eval ()
      (interactive)
      (if (>= (+ 1 (point))
              (point-max))
          (message "C-<tab> : last sexp is evaled")
          (let ()
            (forward-sexp)
            (scheme-send-last-sexp-split-window))))

    (add-hook
     'scheme-mode-hook
     (lambda ()
       (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
       (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
       (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)
       (local-set-key (kbd "{") (lambda () (interactive) (insert "{}") (backward-char 1)))
       (local-set-key (kbd "}") 'out->)
       ))
    #+end_src

*** scheme-here
    #+begin_src emacs-lisp :tangle ~/.emacs
    (require 'scheme-here)
    (add-hook 'inferior-scheme-mode-hook
              (lambda ()
                    (define-key scheme-mode-map (kbd "C-s C-a") 'scheme-here-send-sexp)))
    #+end_src

*** scheme-add-keywords
    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; scheme-mode 中原本的实现不是如此
    (defun scheme-add-keywords (face-name keyword-rules)
      (let* ((keyword-list (mapcar #'(lambda (x)
                                       (symbol-name (cdr x)))
                                   keyword-rules))
             (keyword-regexp (concat "(\\("
                                     (regexp-opt keyword-list)
                                     "\\)[ \n]")))
        (font-lock-add-keywords 'scheme-mode
                                `((,keyword-regexp 1 ',face-name))))
      (mapc #'(lambda (x)
                (put (cdr x)
                     'scheme-indent-function
                     (car x)))
            keyword-rules))

    ;; 前面的数字被认为是参数项的个数
    ;; 参数项完全换行时强缩进 其他项弱缩进
    ;; 非语法关键词 所有项在完全换行时都不缩进
    (scheme-add-keywords
     'font-lock-keyword-face
     '(
       ;; the little prover
       (2 . dethm)
       (1 . J-Bob/step)
       (1 . J-Bob/prove)
       (1 . J-Bob/define)

       ;; 下面 scheme 中需要高亮的词
       (0 . set!)
       (0 . set-car!)
       (0 . set-cdr!)
       (0 . vector-set!)
       (1 . quote)
       (1 . quasiquote)
       (1 . unquote)
       (1 . if)
       (1 . apply)
       (1 . letrec*)
       (1 . while)
       ;; 来自扩展的
       (1 . letcc)
       (1 . pmatch)
       (2 . pmatch-who)
       (0 . guard)
       (0 . add-to-list!)
       (0 . add-to-list-end!)
       (0 . append!)
       (0 . insert-a-val-to-a-field-of-a-wlist!)
       (0 . to-a-field-of-a-wlist--let-us-insert-a-val!)

       ;; 来自 ikarus
       (1 . make-parameter)
       (1 . parameterize)

       ;; 下面 scheme 中我还没用到以后可能需要高亮的词
       (1 . when)
       (1 . unless)
       (2 . let1)
       (1 . error)

       ;; 下面是我的解释器中需要高亮的词
       (1 . λ)
       (0 . begin*)
       (1 . def)
       (1 . doc)
       (2 . rewrite-doc)

       ;;
       (2 . ==)
       (1 . fresh)
       (0 . conde)
       (0 . condi)
       (1 . run*)
       (1 . ando+)
       (1 . oro+)
       (0 . ando)
       (0 . oro)
       (0 . trunk)
       (1 . case-inf)

       ;; 下面是 mk 的元代码中需要高亮的词
       ;; [(lambdag@ (p) e) (lambda (p) e)]
       ;; (1 . lambdag@)
       ;; [(lambdaf@ () e) (lambda () e)]
       ;; (1 . lambdaf@)

       (1 . λᴳ)
       (1 . λ~)

       ;;
       (0 . set-pointer!)
       (1 . define-pointer)
       ;; 下面是 vvv-mimic-ccc.scm 中需要高亮的词
       (0 . vons)
       (0 . vnr)
       (0 . v0r)
       (0 . v1r)
       (0 . v2r)
       (0 . v3r)
       (0 . v4r)
       (0 . v5r)
       (0 . v6r)
       (0 . v7r)
       (0 . v8r)
       (0 . v9r)
       (0 . set-vnr!)
       (0 . set-v0r!)
       (0 . set-v1r!)
       (0 . set-v2r!)
       (0 . set-v3r!)
       (0 . set-v4r!)
       (0 . set-v5r!)
       (0 . set-v6r!)
       (0 . set-v7r!)
       (0 . set-v8r!)
       (0 . set-v9r!)

       (0 . vonz)
       (0 . vnz)
       (0 . v0z)
       (0 . v1z)
       (0 . v2z)
       (0 . v3z)
       (0 . v4z)
       (0 . v5z)
       (0 . v6z)
       (0 . v7z)
       (0 . v8z)
       (0 . v9z)
       (0 . set-vnz!)
       (0 . set-v0z!)
       (0 . set-v1z!)
       (0 . set-v2z!)
       (0 . set-v3z!)
       (0 . set-v4z!)
       (0 . set-v5z!)
       (0 . set-v6z!)
       (0 . set-v7z!)
       (0 . set-v8z!)
       (0 . set-v9z!)

       (0 . conz)
       (0 . caz)
       (0 . cdz)
       (0 . set-caz!)
       (0 . set-cdz!)

       ;; 其它可能临时用到的高亮
       (0 . *λ)
       (0 . *l)

       (1 . define-primitive)

       ;; racket
       ;; (1 . require)
       ;; (1 . provide)
       (1 . module)
       (1 . module+)
       (1 . module*)

       (1 . class)
       (2 . class*)
       (1 . interface)
       (2 . mixin)
       (1 . define/public)
       (1 . define/override)
       (1 . new)
       (1 . send)
       (0 . :)
       (1 . ::)
       (1 . super)
       (1 . test-case)
       (0 . check-expect)
       (2 . check-error)

       (1 . match)
       (1 . match*)
       (0 . match-lambda**)
       (0 . fun)
       (1 . just-fun)
       (1 . define/match)

       (2 . syntax-case)
       (1 . syntax-parse)

       (1 . orz)
       (0 . note)

       (1 . type)
       (1 . data)
       (0 . example)
       (0 . effect)
       (2 . oer)

       (1 . create)
       (1 . apply-creator-list)
       (1 . process)
       (1 . apply-processor-list)
       (1 . settle)
       (1 . apply-settler-list)

       (1 . with-handlers)
       (1 . raise)

       (0 . try)
       (1 . back-to-last-try)

       ;; cicada
       (1 . create-primitive-function)

       (2 . define-function)
       (2 . define-variable)
       (2 . define-primitive-function)

       (0 . here)
       (0 . !td)
       (0 . @t)
       (0 . @d)

       (1 . vector-map)

       (1 . match-let)
       (1 . match-let*)

       (2 . deftype)
       (0 . app)
       (1 . with-syntax)

       (0 . ret)
       (0 . return)
       (1 . do/monad)
       (1 . define-monad)

       (0 . ~)
       ;; (0 . +)
       (0 . /)
       (0 . \?)
       (0 . *)
       (0 . !)
       (0 . @)
       (0 . $)
       (0 . \#)
       (0 . &)
       (0 . ^)
       (0 . -)
       (0 . %)
       ;; (0 . =)

       (0 . <)
       (0 . >)

       (0 . =>)
       (0 . =<)
       (0 . <=)
       (0 . >=)

       (1 . define-type)
       (1 . define-data)
       (3 . datatype)
       (3 . define-datatype)
       (1 . define-jojo)
       (1 . define-function)

       (1 . map!)

       (0 . var)
       (0 . set)
       (1 . get)

       (0 . tail-call)
       (0 . string)

       (2 . defun)
       (2 . declare)
       (1 . defvar)
       (0 . run)
       (0 . clib)

       (0 . ifte)
       (0 . if3)

       (1 . debug0)

       (1 . with)

       (0 . part)

       (0 . extend-from)

       (0 . lhs)
       (0 . rhs)

       (1 . in)
       (0 . map)

       (0 . use-modules)

       (1 . connect-db)

       (2 . define-class)

       (1 . +fun)
       (1 . +theorem)

       (1 . +data)
       (1 . +union)
       (1 . +fun)

       (1 . fixpoint)

       ;; pie
       (1 . which-Nat)
       (1 . iter-Nat)
       (1 . rec-Nat)
       (1 . ind-Nat)

       (1 . which-List)
       (1 . iter-List)
       (1 . rec-List)
       (1 . ind-List)

       (2 . ind-Vec)

       (1 . =)
       (1 . the)
       (1 . check-same)
       (1 . claim)
       (1 . Pi)
       (1 . Pi*)
       (1 . lambda*)
       (1 . Pi/implicit)
       (1 . lambda/implicit)
       (1 . Pi/vague)
       (1 . lambda/vague)
       (1 . forall)
       (1 . Sigma)
       (1 . same)
       (1 . cong)
       (1 . replace)
       (1 . implicit)

       (0 . comments)
       (0 . assert-equal)
       (0 . assert-not-equal)

       (1 . Self)
       (1 . Iota)
       (1 . check)
       (1 . Check)
       (0 . object)

       (1 . induction)
       (1 . recursion)
       ))
    #+end_src

** pie

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq auto-mode-alist (cons `("\\.pie$" . scheme-mode) auto-mode-alist))
   #+end_src

** racket
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/racket-mode/")

   (require 'racket-mode)

   ;; (setq auto-mode-alist (cons `("\\.rkt$" . scheme-mode) auto-mode-alist))
   (setq auto-mode-alist (cons `("\\.rkt$" . racket-mode) auto-mode-alist))

   ;; (defun switch-to-buffer-*racket* ()
   ;;   (interactive)
   ;;   (let ()
   ;;     (switch-to-buffer racket--repl-buffer-name t)
   ;;     (with-current-buffer racket--repl-buffer-name
   ;;       (goto-char (point-max))))
   ;;   (local-set-key (kbd "C-s C-d") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-d") 'switch-to-buffer-*racket*)
   #+end_src

** lisp
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (setq inferior-lisp-program "lisp")
   (setq inferior-lisp-program "sbcl")
   ;; (setq inferior-lisp-program "ecl")
   ;; (setq inferior-lisp-program "ccl")

   ;; (defun lisp-easy-to-eval ()
   ;;  (interactive)
   ;;  (if (>= (+ 1 (point))
   ;;          (point-max))
   ;;      (message "C-<tab> : last sexp is evaled")
   ;;    (let ()
   ;;      (forward-sexp)
   ;;      (slime-eval-last-expression))))

   (add-hook
    'lisp-mode-hook
    (lambda ()
      (local-set-key (kbd "M-i") 'query-replace)
      ;; (local-set-key (kbd "C-<tab>") 'lisp-easy-to-eval)
      ))
   #+end_src

** lisp-add-keywords
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun lisp-add-keywords (face-name keyword-rules)
     (let* ((keyword-list
             (mapcar #'(lambda (x)
                         (symbol-name (cdr x)))
                     keyword-rules))
            (keyword-regexp
             (concat "(\\("
                     (regexp-opt keyword-list)
                     "\\)[ \n]")))
       (font-lock-add-keywords
        'lisp-mode
        `((,keyword-regexp 1 ',face-name))))
     (mapc #'(lambda (x)
               (put (cdr x)
                    'lisp-indent-function
                    (car x)))
           keyword-rules))

   ;; note that
   ;; a macro will be turned into keyword by slime
   ;; slime will override the following definition
   ;; but slime does not help some of the colors
   (lisp-add-keywords
    'font-lock-keyword-face
    '(
      (0 . quote)
      (0 . function)
      (0 . values)

      (1 . defin)
      (1 . with)

      (1 . apply)
      (1 . funcall)

      (2 . deftest)
      (3 . ensure)

      (1 . cat)
      (1 . orz)

      (1 . add1!)
      (1 . sub1!)
      (2 . set!)
      (2 . set-car!)
      (2 . set-cdr!)
      (2 . set-end-car!)
      (2 . set-end-cdr!)

      (1 . multiple-value-let)
      ;; (1 . let-fun)
      (1 . help)

      (0 . put)
      (1 . match)
      ))
   #+end_src

** slime

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/slime/")

   ;; (setq slime-contribs '(slime-fancy))

   ;; (require 'slime)

   ;; (setf common-lisp-hyperspec-root "/home/xyh/sd0/lang/lisp/docs/hyperspec/"
   ;;     slime-complete-symbol-function 'slime-fuzzy-complete-symbol
   ;;      lisp-indent-function 'common-lisp-indent-function)

   ;; (add-hook 'slime-repl-mode-hook
   ;;          (lambda ()
   ;;            (local-set-key (kbd "C-M-.") 'next-buffer)
   ;;            (local-set-key (kbd "C-M-,") 'previous-buffer)
   ;;            (local-set-key (kbd "C-c C-k") 'slime-restart-inferior-lisp)))
   #+end_src

** elisp
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-elisp-mode-keywords()
     (font-lock-add-keywords
      nil
      '(("\\<\\(setq\\)" . 'font-lock-keyword-face))))
   (add-hook 'emacs-lisp-mode-hook 'my-elisp-mode-keywords)
   #+end_src

** emacs-lisp-add-keywords
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun emacs-lisp-add-keywords (face-name keyword-rules)
     (let* ((keyword-list
             (mapcar #'(lambda (x)
                         (symbol-name (cdr x)))
                     keyword-rules))
            (keyword-regexp
             (concat "(\\("
                     (regexp-opt keyword-list)
                     "\\)[ \n]")))
       (font-lock-add-keywords
        'emacs-lisp-mode
        `((,keyword-regexp 1 ',face-name))))
     (mapc #'(lambda (x)
               (put (cdr x)
                    'emacs-lisp-indent-function
                    (car x)))
           keyword-rules))

   (emacs-lisp-add-keywords
    'font-lock-keyword-face
    '(
      (1 . add-hook)
      ))
   #+end_src

** general seting
   Non-nil means print recursive structures using #N= and #N# syntax.
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq print-circle t)
   #+end_src

** ielm = run-elisp
   * 不知道哪个傻逼起的 ielm 这个名字
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun run-elisp ()
     (interactive)
     (ielm))

   (defun switch-to-buffer-*elisp-repl* ()
     (interactive)
     (if (member-string? "*elisp-repl*" (mapcar 'buffer-name (buffer-list)))
             (switch-to-buffer "*elisp-repl*")
           (progn
             (ielm)
             (rename-buffer "*elisp-repl*")))
     (local-set-key (kbd "C-s e") 'previous-buffer))
   (global-set-key (kbd "C-s e") 'switch-to-buffer-*elisp-repl*)
   #+end_src

** shen
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/shen-mode/")
   (require 'shen-mode)
   (require 'inf-shen) ; <- for interaction with an external shen process

   ;; (defun switch-to-buffer-*inferior-shen* ()
   ;;   (interactive)
   ;;   (if (member-string? "*inferior-shen*" (mapcar 'buffer-name (buffer-list)))
   ;;           (switch-to-buffer "*inferior-shen*")
   ;;         (switch-to-shen t))
   ;;   (local-set-key (kbd "C-s C-w") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-w") 'switch-to-buffer-*inferior-shen*)
   #+end_src

** clojure

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/clojure-mode/")
   (require 'clojure-mode)

   (add-hook 'clojure-mode-hook #'enable-paredit-mode)
   (add-hook
    'clojure-mode-hook
    (lambda ()
      ;; (paren-face-mode)
      (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
      (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
      (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)))

   (defun run-clojure ()
     (interactive)
     ;; (run-scheme "java -cp /home/xyh/lang/clojure/clojure-1.8.0/clojure-1.8.0.jar clojure.main")
     (run-scheme "lein repl"))
   #+end_src

** julia

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/julia-emacs/")
   (require 'julia-mode)
   #+end_src

** cicada

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cicada-mode/")
   (require 'cicada-mode)

   (add-to-list 'interpreter-mode-alist '("cicada" . cicada-mode))

   (add-hook
    'cicada-mode-hook
    (lambda ()
      (turn-off-indent)))

   (add-to-list 'auto-mode-alist '("\\.cs\\'" . cicada-mode))
   (add-to-list 'auto-mode-alist '("\\.sc\\'" . cicada-mode))
   (add-to-list 'auto-mode-alist '("\\.cic\\'" . cicada-mode))
   (add-to-list 'auto-mode-alist '("\\.jo\\'" . cicada-mode))
   (add-to-list 'auto-mode-alist '("\\.grammar\\'" . cicada-mode))
   (add-to-list 'auto-mode-alist '("\\.table\\'" . cicada-mode))
   #+end_src

** sql

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook
    'sql-mode-hook
    (lambda ()
      (turn-off-indent)
      ))
   #+end_src

** jojo

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/jojo-mode/")
   (require 'jojo-mode)

   (add-to-list 'interpreter-mode-alist '("jojo" . jojo-mode))

   (add-hook 'jojo-mode-hook #'enable-paredit-mode)

   ;; (setq auto-mode-alist (cons `("\\.jo" . jojo-mode) auto-mode-alist))

   (add-hook
    'jojo-mode-hook
    (lambda ()
      ;; (paren-face-mode)
      ;; (turn-off-indent)
      (local-set-key (kbd "C-x C-e") 'scheme-send-last-sexp-split-window)
      (local-set-key (kbd "C-c C-e") 'scheme-send-definition-split-window)
      (local-set-key (kbd "C-<tab>") 'scheme-easy-to-eval)
      (local-set-key (kbd "{") (lambda ()
                                 (interactive)
                                 (insert "{}") (backward-char 1)))
      (local-set-key (kbd "}") 'out->)))
   #+end_src

** elm

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/elm/")
   (add-to-list 'load-path "~/.emacs.d/elm/elm-mode/")
   (add-to-list 'load-path "~/.emacs.d/elm/f.el/")
   (add-to-list 'load-path "~/.emacs.d/elm/s.el/")
   (require 'elm-mode)
   (add-hook
    'elm-mode-hook
    (lambda ()
      (turn-off-indent)
      (local-set-key (kbd "RET")
                     (lambda ()
                       (interactive)
                       (insert "\n")))))
   #+end_src

** s.el

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/s.el/")
   (require 's)
   #+end_src

** web

*** js-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook
     'js-mode-hook
     (lambda ()
       ;; (setq comment-style 'extra)
       (setq js-indent-level 2)))

    ;; (add-to-list 'auto-mode-alist '("\\.js\\'" . js-mode))
    #+end_src

*** emmet-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/emmet-mode")
    (require 'emmet-mode)

    (add-hook 'web-mode-hook 'emmet-mode)
    (add-hook
     'web-mode-hook
     (lambda ()
       (electric-indent-local-mode -1)))

    ;; (add-hook 'css-mode-hook  'emmet-mode)

    (add-to-list 'emmet-jsx-major-modes 'js-jsx-mode)
    (add-hook
     'js-jsx-mode-hook
     (lambda ()
       (define-key js-jsx-mode-map (kbd "C-j") 'emmet-expand-line)))

    (add-hook
     'typescript-mode-hook
     (lambda ()
       (define-key typescript-mode-map (kbd "C-j") 'emmet-expand-line)))
    #+end_src

*** js2-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/js2-mode/")
    (require 'js2-mode)

    (add-hook
     'js2-mode-hook
     (lambda ()
       ;; (setq comment-style 'extra)
       ;; (setq comment-style 'multi-char)
       (setq js2-basic-offset 2)
       (js2-mode-hide-warnings-and-errors)))

    ;; (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    #+end_src

*** typescript-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/typescript.el/")
    (require 'typescript-mode)

    (add-hook
     'typescript-mode-hook
     (lambda ()
       (setq typescript-indent-level 2)
       (setq tab-width 2)))

    (add-to-list 'auto-mode-alist '("\\.js\\'" . typescript-mode))
    (add-to-list 'auto-mode-alist '("\\.mjs\\'" . typescript-mode))
    (add-to-list 'auto-mode-alist '("\\.cjs\\'" . typescript-mode))
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))
    (add-to-list 'auto-mode-alist '("\\.d.ts\\'" . typescript-mode))
    #+end_src

*** nodejs-repl

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/nodejs-repl/")
    ;; (require 'nodejs-repl)
    ;; ;; (global-set-key (kbd "C-s C-n") 'nodejs-repl)
    ;; (setq nodejs-repl-command "node")
    #+end_src

*** flycheck

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'load-path "~/.emacs.d/flycheck/")
    ;; (require 'let-alist)
    ;; (require 'flycheck)
    ;;
    ;; (add-hook 'js-mode-hook
    ;;           (lambda () (flycheck-mode t)))
    ;; ;; (global-flycheck-mode)
    #+end_src

*** coffee-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/coffee-mode/")
    (require 'coffee-mode)
    (add-to-list 'auto-mode-alist '("\\.coffee\\'" . coffee-mode))
    (custom-set-variables '(coffee-tab-width 2))

    (add-hook
     'coffee-mode-hook
     (lambda ()
       (turn-off-indent)
       (local-set-key (kbd "<return>") 'newline)
       ))
    #+end_src

*** web-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/web-mode/")
    (require 'web-mode)

    (define-key web-mode-map (kbd "C-c C-c") 'web-mode-tag-match)

    (setq web-mode-enable-auto-indentation nil)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-style-padding 0)
    (setq web-mode-script-padding 0)

    (add-to-list 'auto-mode-alist '("\\.svelte\\'" . web-mode))
    #+end_src

*** css-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq css-indent-offset 2)
    #+end_src

*** html-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'auto-mode-alist '("\\.mimor\\'" . html-mode))

    (add-hook
     'html-mode-hook
     (lambda ()
       (set (make-local-variable 'sgml-basic-offset) 2)
       ))
    #+end_src

*** jsx

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js-jsx-mode))
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . js-jsx-mode))
    ;; (add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
    ;; (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
    #+end_src

*** vue

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'auto-mode-alist '("\\.vue\\'" . web-mode))
    #+end_src

*** prettier

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/prettier-emacs/")

    (require 'prettier-js)
    ;; (add-hook 'js2-mode-hook 'prettier-js-mode)
    ;; (add-hook 'js-mode-hook 'prettier-js-mode)
    ;; (add-hook 'typescript-mode-hook 'prettier-js-mode)
    ;; (add-hook 'web-mode-hook 'prettier-js-mode)
    #+end_src

** php

   https://github.com/emacs-php/php-mode/wiki/Manual-installation

   #+begin_src emacs-lisp :tangle ~/.emacs
   (when (file-directory-p "~/.emacs.d/php-mode")
     (load "~/.emacs.d/php-mode/lisp/php-mode-autoloads.el"))
   #+end_src

** markdown

*** edit-indirect

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/edit-indirect/")
    (require 'edit-indirect)

    (define-key edit-indirect-mode-map
      (kbd "C-s C-s") 'edit-indirect-commit)
    #+end_src

*** markdown

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/markdown-mode/")

    (autoload 'markdown-mode "markdown-mode"
      "Major mode for editing Markdown files" t)
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

    (setq markdown-fontify-code-blocks-natively t)

    (custom-set-faces
     '(fixed-pitch ((t (:family (face-attribute 'default :family))))))

    (add-hook
     'markdown-mode-hook
     (lambda ()
       (local-set-key (kbd "C-s C-s") 'markdown-edit-code-block)
       (local-set-key (kbd "M-p") 'backward-paragraph)
       (local-set-key (kbd "M-n") 'forward-paragraph)
       (set-face-attribute 'markdown-header-face-1 nil :foreground "#DFAF8F")
       (set-face-attribute 'markdown-header-face-2 nil :foreground "#BFEBBF")
       (set-face-attribute 'markdown-header-face-3 nil :foreground "#7CB8BB")
       (set-face-attribute 'markdown-header-face-4 nil :foreground "#D0BF8F")
       (set-face-attribute 'markdown-header-face-5 nil :foreground "#93E0E3")
       (set-face-attribute 'markdown-header-face-6 nil :foreground "#9FC59F")
       ;; (set-face-attribute 'markdown-header-delimiter-face nil :foreground 'unspecified)
       ))
    #+end_src

** xml

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq nxml-child-indent 4)
   (setq nxml-attribute-indent 2)

   ;; (add-to-list 'auto-mode-alist '("\\.xml\\'" . nxml-mode))

   (setq rng-nxml-auto-validate-flag nil)

   (setq nxml-tab-flag t)

   (setq nxml-backtab-state 1)

   (add-hook
    'nxml-mode-hook
    (lambda ()
      (local-set-key
       (kbd "<backtab>")
       (lambda ()
         (interactive)
         (cond
           ((eq nxml-backtab-state 1)
            (message "nxml-show-all")
            (nxml-show-all)
            (setq nxml-backtab-state 2))
           ((eq nxml-backtab-state 2)
            (message "nxml-hide-all-text-content")
            (nxml-hide-all-text-content)
            (setq nxml-backtab-state 1)))))
      (local-set-key
       (kbd "<tab>")
       (lambda ()
         (interactive)
         (message "nxml-show")
         (nxml-show)))
      (local-set-key (kbd "RET") 'electric-newline-and-maybe-indent)))

   (add-to-list 'load-path "~/.emacs.d/rnc-mode/")
   (require 'rnc-mode)

   (add-to-list 'auto-mode-alist '("\\.rnc\\'" . rnc-mode))
   #+end_src

** myxml-mode

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/myxml-mode/")
   (require 'myxml-mode)

   (define-key myxml-mode-map (kbd "C-c C-c") 'myxml-mode-tag-match)
   (setq myxml-mode-enable-auto-indentation nil)

   (add-to-list 'auto-mode-alist '("\\.xml\\'" . myxml-mode))

   (add-hook
    'myxml-mode-hook
    (lambda ()
      (electric-indent-local-mode -1)
      (turn-off-indent)
      (setq myxml-mode-markup-indent-offset 2)
      (setq myxml-mode-css-indent-offset 2)
      (setq myxml-mode-code-indent-offset 2)
      (setq myxml-mode-style-padding 0)
      (setq myxml-mode-script-padding 0)))
   #+end_src

** txt

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'auto-mode-alist '("\\.txt\\'" . text-mode))
   #+end_src

** return-stack
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/return-stack-mode/")
   (require 'return-stack-mode)
   #+end_src

** python

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook
    'python-mode-hook
    (lambda ()
      (setq forward-sexp-function nil)))

   (setq python-shell-interpreter "ipython"
         python-shell-interpreter-args "--simple-prompt -i")

   (setq python-indent-guess-indent-offset nil)
   (setq python-indent-offset 4)
   #+end_src

** rust

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/rust-mode/")
   (autoload 'rust-mode "rust-mode" nil t)
   (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
   (setq rust-indent-offset 4)
   #+end_src

** go

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/go-mode/")
   (require 'go-mode)

   (add-hook
    'go-mode-hook
    (lambda ()
      (setq tab-width 4)
      (setq indent-tabs-mode nil)))
   #+end_src

** forth
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/forth-mode/")

   (require 'forth-mode)
   (require 'forth-block-mode)
   (require 'forth-interaction-mode)

   ;; (defun switch-to-buffer-*forth* ()
   ;;   (interactive)
   ;;   (if (member-string? "*forth*" (mapcar 'buffer-name (buffer-list)))
   ;;       (switch-to-buffer "*forth*")
   ;;       (let ((forth-name (read-from-minibuffer "run which forth? : ")))
   ;;         (run-forth forth-name)))
   ;;   (local-set-key (kbd "C-s C-f") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-f") 'switch-to-buffer-*forth*)

   (add-to-list 'auto-mode-alist '("\\.frt$" . forth-mode))
   (add-to-list 'auto-mode-alist '("\\.fth$" . forth-mode))
   (add-to-list 'auto-mode-alist '("\\.feline" . forth-mode))
   #+end_src

** tcl
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq tcl-application "tclsh")


   (defun tcl-eval-defun-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-eval-defun))

   (defun tcl-send-line ()
     (interactive)
     (move-beginning-of-line nil)
     (cua-set-mark)
     (move-end-of-line nil)
     (tcl-eval-region (region-beginning) (region-end))
     (cua-set-mark))

   (defun tcl-send-line-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-send-line))

   (defun tcl-send-line-and-goto-next-line ()
     (interactive)
     (tcl-send-line)
     (next-line))

   (defun tcl-send-line-and-goto-next-line-split-window ()
     (interactive)
     (split-window-with-named-buffer "*inferior-tcl*")
     (tcl-send-line)
     (next-line))

   (add-hook
    'tcl-mode-hook
    (function (lambda ()
      ;; note that how a function definition in tcl is viewed as a line
      (local-set-key (kbd "C-<tab>") 'tcl-send-line-and-goto-next-line-split-window)
      (local-set-key (kbd "C-x C-e") 'tcl-send-line-split-window)
      (local-set-key (kbd "C-c C-e") 'tcl-eval-defun-split-window)
      )))
   #+end_src

** sml
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/sml/")
   ;; (defun switch-to-buffer-about-sml ()
   ;;   (interactive)
   ;;   (cond ((member-string? "*hamlet*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*hamlet*"))
   ;;         ((member-string? "*mosml*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*mosml*"))
   ;;         ((member-string? "*poly*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*poly*"))
   ;;         ((member-string? "*sml*" (mapcar 'buffer-name (buffer-list)))
   ;;          (switch-to-buffer "*sml*"))
   ;;         (else
   ;;          ;; (run-sml "sml" "")
   ;;          (run-sml "hamlet" "")
   ;;          ))
   ;;   ;; 然后总能通过向左一个 buffer 回到之前的 buffer
   ;;   ;; 这是笨的解决方法，某些情况下一定会出问题
   ;;   (local-set-key (kbd "C-s C-q") 'previous-buffer))
   ;; (global-set-key (kbd "C-s C-q") 'switch-to-buffer-about-sml)

   (autoload 'sml-mode "sml-mode" "Major mode for editing SML." t)
   (autoload 'run-sml "sml-proc" "Run an inferior SML process." t)
   (add-to-list 'auto-mode-alist '("\\.\\(sml\\|sig\\)\\'" . sml-mode))

   (setq sml-program-name "sml")
   ;; (setq sml-program-name "hamlet")

   (require 'sml-mode)

   (add-hook
    'sml-mode-hook
    (lambda ()
      (define-key sml-mode-map (kbd "C-x C-e") 'sml-send-function)
      (turn-off-indent)))
   #+end_src

** ocaml-mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/ocaml-mode/")

   (add-to-list 'auto-mode-alist '("\\.ml[iylp]?$" . caml-mode))
   (autoload 'caml-mode "caml" "Major mode for editing OCaml code." t)
   (autoload 'run-caml "inf-caml" "Run an inferior OCaml process." t)
   (autoload 'camldebug "camldebug" "Run ocamldebug on program." t)
   (add-to-list 'interpreter-mode-alist '("ocamlrun" . caml-mode))
   (add-to-list 'interpreter-mode-alist '("ocaml" . caml-mode))


   ;; (if window-system (require 'caml-hilit))
   (if window-system (require 'caml-font))

   (defun switch-to-buffer-*inferior-caml* ()
      (interactive)
     (if (member-string? "*inferior-caml*" (mapcar 'buffer-name (buffer-list)))
          (switch-to-buffer "*inferior-caml*")
        (run-caml "ocaml"))
      (local-set-key (kbd "C-s C-q") 'previous-buffer))
    (global-set-key (kbd "C-s C-q") 'switch-to-buffer-*inferior-caml*)

   (defun caml-eval-phrase-split-window ()
     (interactive)
     (caml-eval-phrase 1)
     (split-window-with-named-buffer "*inferior-caml*"))

   (add-hook
    'caml-mode-hook
    (lambda ()
      (local-set-key (kbd "C-x C-e") 'caml-eval-phrase-split-window)
      (local-set-key (kbd "C-<tab>") 'caml-eval-phrase-split-window)
      (local-set-key (kbd "<return>") 'electric-newline-and-maybe-indent)
      (turn-off-indent)
      (setq comment-style 'multi-line)))
   #+end_src

** asm
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/asm-mode/")

   ;; may set this variable in `asm-mode-set-comment-hook',
   ;; which is called near the beginning of mode initialization.
   (add-hook 'asm-mode-set-comment-hook
             (lambda ()
                   (setq asm-comment-char ?\#)
                   ))

   (defun asm-indent-line-by-line ()
     (interactive)
     (asm-indent-line)
     (next-line))

   (add-hook 'asm-mode-hook
             (lambda ()
                   (local-set-key (kbd "C-<tab>") 'asm-indent-line-by-line)
                   ))
   #+end_src

** fasm
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/fasm-mode/")
   (require 'fasm-mode)
   (add-to-list 'auto-mode-alist '("\\.fasm$" . fasm-mode))
   (add-to-list 'auto-mode-alist '("\\.inc$"  . fasm-mode))
   (add-to-list 'auto-mode-alist '("\\.s$"    . fasm-mode))

   (defun fasm-indent-line-and-next-line ()
     (interactive)
     (fasm-indent-line)
     (next-line))

   (add-hook 'fasm-mode-hook
             (lambda ()
                   ;; (setq tab-width 13)
                   ;; (setq indent-tabs-mode t)
                   ;; (local-set-key (kbd "<tab>") 'fasm-indent-line)
                   ;; (local-set-key (kbd "C-<tab>") 'fasm-indent-line-and-next-line)
                   ;; (turn-off-indent)
                   ))
   #+end_src

** nasm
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/nasm/")
   (autoload 'nasm-mode "~/.emacs.d/nasm/nasm-mode.el" "" t)

   (add-to-list 'auto-mode-alist '("\\.asm\\'" . nasm-mode))
   (add-to-list 'auto-mode-alist '("\\.nasm\\'" . nasm-mode))

   ;; To set your own indentation level to LEVEL:
   ;; (add-hook 'nasm-mode-hook
   ;;           (lambda () (setq-default nasm-basic-offset LEVEL)))
   (add-hook 'nasm-mode-hook
             (lambda ()
                   (setq-default nasm-basic-offset 13)
                   (turn-off-indent)
                   ))
   #+end_src

** clean

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/clean-mode/")
   (setq auto-mode-alist
         (append auto-mode-alist
                 '(("\\.icl$"  . clean-mode)
                   ("\\.dcl$"  . clean-mode)
                   ("\\.prj$"  . clean-project-mode))))

   (autoload 'clean-mode "clean-mode"
      "Major mode for editing Clean scripts." t)
   (autoload 'clean-project-mode "clean-project-mode"
      "Major mode for editing Clean Project Scripts." t)

   (add-hook 'clean-mode-hook
             (lambda ()
               ;; (local-set-key (kbd "M-n") 'forward-paragraph)
               ;; (local-set-key (kbd "M-p") 'backward-paragraph)
               ;; (local-set-key (kbd "<return>") 'newline)
               (turn-off-indent)
               ))
   #+end_src

** haskell

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/haskell-mode/")
   (require 'haskell-mode)
   (setq haskell-program-name "ghci")

   ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
   ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
   ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)

   (add-hook 'haskell-mode-hook
             (lambda ()
               ;; (local-set-key (kbd "M-n") 'forward-paragraph)
               ;; (local-set-key (kbd "M-p") 'backward-paragraph)
               ;; (local-set-key (kbd "<return>") 'newline)
               (turn-off-indent)
               ))

   (defun haskell-split-window ()
     (interactive)
     (cond
      ((= 1 (count-windows))
           (split-window-vertically (floor (* 0.68 (window-height))))
           (other-window 1)
           (switch-to-buffer "*haskell*")
           (other-window 1))
      ((not (cl-find "*haskell*"
                      (mapcar (lambda (w) (buffer-name (window-buffer w)))
                              (window-list))
                      :test 'equal))
           (other-window 1)
           (switch-to-buffer "*haskell*")
           (other-window -1))))


   (defun switch-to-buffer-*haskell* ()
     (interactive)
     (progn
           (setq the-buffer-before-switch-to-buffer-*haskell*
             (current-buffer))
           (if (cl-find "*haskell*"
                    (mapcar (lambda (w) (buffer-name w))
                            (buffer-list))
                    :test 'equal)
           (switch-to-buffer "*haskell*")
             (progn (run-haskell) (delete-other-windows)))
           (local-set-key (kbd "C-s C-h") (lambda ()
                                            (interactive)
                                            (switch-to-buffer the-buffer-before-switch-to-buffer-*haskell*)))))

   (global-set-key (kbd "C-s C-h") 'switch-to-buffer-*haskell*)
   #+end_src

** agda

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/agda-mode/")

   (autoload 'agda2-mode "agda2-mode"
     "Major mode for editing Agda files (version ≥ 2)." t)

   (add-to-list 'auto-mode-alist '("\\.l?agda\\'" . agda2-mode))
   (modify-coding-system-alist 'file "\\.l?agda\\'" 'utf-8)

   (require 'agda2)

   (add-hook
    'agda2-mode-hook
    (lambda ()
      (turn-off-indent)))
   #+end_src

** idris

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/prop-menu-el/")
   (require 'prop-menu)

   (add-to-list 'load-path "~/.emacs.d/idris-mode/")
   (add-to-list 'auto-mode-alist '("\\.idr$" . idris-mode))
   (require 'idris-mode)

   (add-hook
    'idris-mode-hook
    (lambda ()
      (local-set-key (kbd "M-n") 'forward-paragraph)
      (local-set-key (kbd "M-p") 'backward-paragraph)
      (local-set-key (kbd "<return>") 'electric-newline-and-maybe-indent)
      (turn-off-indent)
      ))
   #+end_src

** purescript

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/purescript-mode/")
   (require 'purescript-mode-autoloads)
   (add-to-list 'Info-default-directory-list "~/.emacs.d/purescript-mode/")

   (add-hook
    'purescript-mode-hook
    (lambda ()
      ;; (local-set-key (kbd "M-n") 'forward-paragraph)
      ;; (local-set-key (kbd "M-p") 'backward-paragraph)
      ;; (local-set-key (kbd "<return>") 'newline)
      (turn-off-indent)
      ))
   #+end_src

** erlang

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/erlmode/")
   ;; (require 'erlmode-start)
   #+end_src

** elixir

*** smartparens

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/smartparens/")
    (require 'smartparens-config)
    #+end_src

*** company-mode

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/company-mode/")
    (require 'company)

    (defun init-company ()
      (setq company-idle-delay 0.3)
      (require 'color)
      (let ((bg (face-attribute 'default :background)))
        (custom-set-faces
         `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
         `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
         `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
         `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
         `(company-tooltip-common ((t (:inherit font-lock-constant-face)))))))
    #+end_src

*** elixir-mode & alchemist

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/pkg-info.el/")
    (add-to-list 'load-path "~/.emacs.d/emacs-elixir/")
    (add-to-list 'load-path "~/.emacs.d/alchemist.el/")

    (require 'elixir-mode)

    (add-to-list
     'elixir-mode-hook
     (lambda ()
       (alchemist-mode)
       (company-mode)
       (init-company)
       (smartparens-mode)
       (local-set-key (kbd "<return>") 'newline)))

    (require 'alchemist)

    ;; (setq alchemist-goto-erlang-source-dir
    ;;       "~/sd0/lange/rlang/imp/otp")
    ;; (setq alchemist-goto-elixir-source-dir
     ;;     "~/sd0/lang/elixir/imp/elixir")
    #+end_src

** pony

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/ponylang-mode/")
   (require 'ponylang-mode)

   (add-hook
    'ponylang-mode-hook
    (lambda ()
      (set-variable 'indent-tabs-mode nil)
      (set-variable 'tab-width 2)))
   #+end_src

** graphql

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/graphql-mode/")
   (require 'graphql-mode)
   #+end_src

** prolog

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/prolog/prolog-mode/")
   (require 'prolog)

   (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
   (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)

   (setq prolog-system 'swi)
   (setq prolog-indent-width 2)

   (setq auto-mode-alist
         (append '(("\\.pl$" . prolog-mode))
                 auto-mode-alist))
   (add-hook
    'prolog-mode-hook
    (lambda ()
      (local-set-key (kbd "M-i") 'query-replace)
      (local-set-key (kbd "C-c C-k")
                     (lambda ()
                       (interactive)
                       (run-prolog t)
                       (other-window -1)))))

   (add-hook
    'prolog-inferior-mode-hook
    (lambda ()
      (local-set-key (kbd "C-c C-k")
                     (lambda ()
                       (interactive)
                       (run-prolog t)))))
   #+end_src

** c

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (setq c-default-style "k&r")
   ;; (setq c-default-style "user")
   (setq c-default-style "bsd")
   ;; (setq c-default-style "stroustrup")
   ;; (setq c-default-style "whitesmith")
   ;; (setq c-default-style "ellemtel")
   ;; (setq c-default-style "linux")

   (setq c-basic-offset 2)
   (add-hook
    'c-mode-hook
    (lambda ()
      ;; (setq comment-style 'extra)
      (setq comment-start "//")
      (setq comment-end "")))
   #+end_src

** c++

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/modern-cpp-font-lock/")
   (require 'modern-cpp-font-lock)
   (modern-c++-font-lock-global-mode t)
   #+end_src

** java

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-indent-setup ()
     (c-set-offset 'arglist-intro '+))

   (add-hook 'java-mode-hook 'my-indent-setup)
   ;; (add-hook
   ;;  'java-mode-hook
   ;;  (lambda ()
   ;;    (interactive)

   ;;    ))
   #+end_src

** scala

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/emacs-scala-mode/")
   (require 'scala-mode)
   #+end_src

** ruby

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/inf-ruby/")
   (require 'inf-ruby)
   (autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
   (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

   (add-to-list 'load-path "~/.emacs.d/enhanced-ruby-mode/")
   (require 'enh-ruby-mode)
   (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
   (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
   (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))

   ;; (defun ruby-send-line ()
   ;;   (interactive)
   ;;   (move-beginning-of-line nil)
   ;;   (cua-set-mark)
   ;;   (move-end-of-line nil)
   ;;   (ruby-send-region (region-beginning) (region-end))
   ;;   (cua-set-mark)
   ;;   (move-end-of-line nil))

   ;; (defun ruby-easy-to-eval ()
   ;;   (interactive)
   ;;   (if (>= (+ 1 (point))
   ;;           (point-max))
   ;;       (message "C-<tab> : last sexp is evaled")
   ;;       (let ()
   ;;         (ruby-send-line)
   ;;         (next-line)
   ;;         (move-end-of-line nil))))

   ;; (add-hook
   ;;  'ruby-mode-hook
   ;;  (lambda ()
   ;;    (local-set-key (kbd "C-<tab>") 'ruby-easy-to-eval)))
   #+end_src

** lua

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/lua-mode/")

   (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
   (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
   (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))

   (add-hook 'lua-mode-hook  (lambda ()
           (define-key lua-mode-map (kbd "C-<tab>") 'lua-send-current-line)
           (define-key lua-mode-map (kbd "C-x C-e") 'lua-send-defun)
           (define-key lua-mode-map (kbd "C-x C-r") 'lua-send-region)
           (define-key lua-mode-map (kbd "C-c C-e") 'lua-send-defun)
           (define-key lua-mode-map (kbd "C-c C-r") 'lua-send-region)
           ))
   #+end_src

** yaml

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/yaml-mode/")
   (require 'yaml-mode)
   (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))

   (add-hook
    'yaml-mode-hook
    (lambda ()
      (origami-mode)))
   #+end_src

** makefile
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun insert-tab ()
     (interactive)
     (insert 9))


   (add-hook 'makefile-mode-hook
             '(lambda ()
                    (local-set-key (kbd "<tab>") 'insert-tab)))
   #+end_src

** cmake
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/cmake-mode/")
   (require 'cmake-mode)
   #+end_src

** protobuf

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/protobuf/")
   (require 'protobuf-mode)

   (add-to-list 'auto-mode-alist '("\\.proto$" . protobuf-mode))
   #+end_src

** BNF
   #+begin_src emacs-lisp :tangle ~/.emacs
   (define-generic-mode 'bnf-mode
    () ;; comment char: inapplicable because # must be at start of line
    nil ;; keywords
    '(
      ("^#.*" . 'font-lock-comment-face) ;; comments at start of line
      ;; ("^<[^ \t\n]*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
      ;; ("<[^ \t\n]*?>" . 'font-lock-builtin-face) ;; other nonterminals
      ;; 下面的版本中<>里可以有空格
      ("^<.*?>" . 'font-lock-function-name-face) ;; LHS nonterminals
      ("<.*?>" . 'font-lock-builtin-face) ;; other nonterminals
      ("::=" . 'font-lock-const-face) ;; "goes-to" symbol
      ("\|" . 'font-lock-warning-face) ;; "OR" symbol
      )
    '("\\.bnf\\'") ;; filename suffixes
    nil ;; extra function hooks
    "Major mode for BNF highlighting.")
   #+end_src

** fish
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/fish-mode/")
   (require 'fish-mode)
   #+end_src

** jq

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/jq-mode/")
   (autoload 'jq-mode "jq-mode.el"
       "Major mode for editing jq files" t)
   (add-to-list 'auto-mode-alist '("\\.jq$" . jq-mode))
   #+end_src

* yasnippet

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (add-to-list 'load-path "~/.emacs.d/yasnippet")
  ;; (require 'yasnippet)
  ;; (yas-global-mode 1)
  ;; (setq yas-indent-line nil)
  ;; (setq yas-also-indent-empty-lines nil)
  ;; (setq yas-also-auto-indent-first-line nil)
  #+end_src

* comment

  #+begin_src emacs-lisp :tangle ~/.emacs
  (global-set-key (kbd "M-.") 'comment-dwim)
  ;; (global-set-key (kbd "M-,") 'org-babel-previous-src-block)
  #+end_src

* org-mode

** change                             :no:

   - (org-escape-code-in-region (point-min) (point-max))
     in org-edit-src-code
     in lisp/org-src.el

** path

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/org/lisp/")
   ;; a compiled version of org mode is installed
   (require 'org)

   ;; (add-to-list 'load-path "~/.emacs.d/htmlize/")
   (add-to-list 'load-path "~/.emacs.d/emacs-htmlize/")
   (require 'htmlize)

   ;; (setq htmlize-output-type 'css)
   ;; (setq htmlize-output-type 'inline-css)
   ;; (setq htmlize-output-type 'font)
   #+end_src

** export

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-html-head-include-default-style nil)

   ;; (setq org-html-preamble t)
   ;; (setq org-html-preamble-format
   ;;       '(("en" ".")))

   ;; (setq org-html-postamble t)
   ;; (setq org-html-postamble-format
   ;;       '(("en" ".")))
   #+end_src

** publishing

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-export-headline-levels 5)

   (setq org-publish-project-alist
         '(("the-little-language-designer"
            :base-directory "~/cicada-nymph/"
            :publishing-directory "~/cicada-nymph/"
            :publishing-function org-html-publish-to-html
            :section-numbers nil
            :with-toc nil
            :html-head "<link rel=\"stylesheet\"
                       href=\"../other/mystyle.css\"
                       type=\"text/css\"/>")))
   #+end_src

** **-in-org
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun **-in-org ()
     "abc ==> *abc*"
     (interactive)
     (progn
           (insert "*")
           (org-end-of-line)
           (insert "*")))
   #+end_src

** key binding
   #+begin_src emacs-lisp :tangle ~/.emacs
   (eval-after-load 'org
     '(progn

       ;; **-in-org
       (define-key org-mode-map (kbd "M-*") '**-in-org)

       ;; cruise
       (define-key org-mode-map (kbd "M-n") 'outline-next-visible-heading)
       (define-key org-mode-map (kbd "M-p") 'outline-previous-visible-heading)
       ;; (define-key org-mode-map (kbd "M-n") 'org-forward-paragraph)
       ;; (define-key org-mode-map (kbd "M-p") 'org-backward-paragraph)
       (define-key org-mode-map (kbd "<M-up>") nil)
       (define-key org-mode-map (kbd "<M-down>") nil)

       (define-key org-mode-map (kbd "M-e") 'backward-sexp)

       ;; text migration
       ;; ``org-metaup'' and ``org-metadown''
       ;; are really dangerous functions
       ;; so it should be as hard as possible to mis-type it
       (define-key org-mode-map (kbd "C-M-p") 'org-metaup)
       (define-key org-mode-map (kbd "C-M-n") 'org-metadown)

       (define-key org-mode-map (kbd "M-l") 'org-metaright)
       (define-key org-mode-map (kbd "M-h") 'org-metaleft)

       (define-key org-mode-map (kbd "M-S-l") 'org-metashiftright)
       (define-key org-mode-map (kbd "M-S-h") 'org-metashiftleft)

       ;; in babel
       (define-key org-mode-map (kbd "M-.") 'org-babel-next-src-block)
       (define-key org-mode-map (kbd "M-,") 'org-babel-previous-src-block)
       (define-key org-mode-map (kbd "C-s C-s") 'org-edit-src-code)
       ;; (turn-off-indent)
       ))

   (add-hook
    'org-src-mode-hook
    (lambda ()
      (local-set-key (kbd "C-s C-s") 'org-edit-src-exit)
      ))
   #+end_src

** variable
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook 'org-mode-hook
         (lambda ()
           (setq case-fold-search nil)))

   (setq org-startup-indented nil)
   (setq org-babel-no-eval-on-ctrl-c-ctrl-c t)
   ;; (setq org-agenda-window-setup )
   ;; (setq org-agenda-restore-windows-after-quit )

   ;; (setq org-hide-leading-stars t)
   ;; (setq org-odd-levels-only t)

   (setq org-hide-leading-stars nil)
   (setq org-odd-levels-only nil)
   #+end_src

** todo-keyword

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-todo-keywords
         '((sequence "[TODO]" "|" "[NOTE]")))
   #+end_src

** tag
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-tags-column 38)
   #+end_src

** [babel] load-language
   #+begin_src emacs-lisp :tangle ~/.emacs
   (org-babel-do-load-languages
      'org-babel-load-languages
      '())
   #+end_src

** [babel] edit

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook
    'org-mode-hook
    (lambda ()
      (setq org-src-preserve-indentation nil)
      (setq org-src-do-not-insert-comma t)
      (setq org-edit-src-content-indentation 0)
      (setq org-src-fontify-natively t)
      ;; if turn on, the structure-template-alist will be unable to use
      ;; (setq org-src-tab-acts-natively t)
      (setq org-src-window-setup 'current-window)
      (setq org-src-ask-before-returning-to-edit-buffer nil)))
   #+end_src

** [babel] structure-template-alist

*** [note]
    1. C-c C-v d
       org-babel-demarcate-block
    2. begin_src <lang-name> 会去搜索<lang-name>的 major-mode
       只要能搜索到就都能用编辑功能
    3. ob-<lang-name>.el 是用来提供更多的关于语言的其他功能的

*** basic
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-basic
          '(
            ;; just src
            ("sf" "#+end_src\n?\n#+begin_src" "<src lang=\"?\">\n\n</src>")
            ("s" "#+begin_src\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; picture
            ("picturef" "#+end_src\n?\n#+begin_src picture" "<src lang=\"?\">\n\n</src>")
            ("picture" "#+begin_src picture\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; not using
            ;; ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
            ;; ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
            ;; ("C" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
            ;; ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
            ;; ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM" "<verbatim>\n?\n</verbatim>")
            ;; ("l" "#+BEGIN_LaTeX\n?\n#+END_LaTeX" "<literal style=\"latex\">\n?\n</literal>")
            ;; ("L" "#+LaTeX: " "<literal style=\"latex\">?</literal>")
            ;; ("h" "#+BEGIN_HTML\n?\n#+END_HTML" "<literal style=\"html\">\n?\n</literal>")
            ;; ("H" "#+HTML: " "<literal style=\"html\">?</literal>")
            ;; ("a" "#+BEGIN_ASCII\n?\n#+END_ASCII")
            ;; ("A" "#+ASCII: ")
            ;; ("i" "#+INDEX: ?" "#+INDEX: ?")
            ;; ("I" "#+INCLUDE: %file ?" "<include file=%file markup=\"?\">")

            ))
    #+end_src

*** erlang-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-erlang-family
          '(
            ;; perl
            ("plf" "#+end_src\n?\n#+begin_src prolog" "<src lang=\"?\">\n\n</src>")
            ("pl" "#+begin_src prolog\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; erlang
            ("erlangf" "#+end_src\n?\n#+begin_src erlang" "<src lang=\"?\">\n\n</src>")
            ("erlang" "#+begin_src erlang\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; elixir
            ("exf" "#+end_src\n?\n#+begin_src elixir" "<src lang=\"?\">\n\n</src>")
            ("ex" "#+begin_src elixir\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** lisp-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-lisp-family
          '(
            ;; scheme
            ("ssf" "#+end_src\n?\n#+begin_src scheme" "<src lang=\"?\">\n\n</src>")
            ("ss" "#+begin_src scheme\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; jojo
            ("jof" "#+end_src\n?\n#+begin_src jojo" "<src lang=\"?\">\n\n</src>")
            ("jo" "#+begin_src jojo\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; rust
            ("rsf" "#+end_src\n?\n#+begin_src rust" "<src lang=\"?\">\n\n</src>")
            ("rs" "#+begin_src rust\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; racket
            ("srf" "#+end_src\n?\n#+begin_src racket" "<src lang=\"?\">\n\n</src>")
            ("sr" "#+begin_src racket\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; lisp
            ("lispf" "#+end_src\n?\n#+begin_src lisp" "<src lang=\"?\">\n\n</src>")
            ("lisp" "#+begin_src lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; shen
            ("shenf" "#+end_src\n?\n#+begin_src shen" "<src lang=\"?\">\n\n</src>")
            ("shen" "#+begin_src shen\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; clojure
            ("clojuref" "#+end_src\n?\n#+begin_src clojure" "<src lang=\"?\">\n\n</src>")
            ("clojure" "#+begin_src clojure\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; emacs-lisp
            ("seef" "#+end_src\n?\n#+begin_src emacs-lisp :tangle ~/.emacs" "<src lang=\"?\">\n\n</src>")
            ("see" "#+begin_src emacs-lisp :tangle ~/.emacs\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("sef" "#+end_src\n?\n#+begin_src emacs-lisp" "<src lang=\"?\">\n\n</src>")
            ("se" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** forth-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-forth-family
          '(
            ;; cicada
            ("cnf" "#+end_src\n?\n#+begin_src cicada" "<src lang=\"?\">\n\n</src>")
            ("cn" "#+begin_src cicada\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; scala
            ("slf" "#+end_src\n?\n#+begin_src scala" "<src lang=\"?\">\n\n</src>")
            ("sl" "#+begin_src scala\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; forth
            ("forthf" "#+end_src\n?\n#+begin_src forth" "<src lang=\"?\">\n\n</src>")
            ("forth" "#+begin_src forth\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** ml-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-ml-family
          '(
            ;; sml
            ("smlf" "#+end_src\n?\n#+begin_src sml" "<src lang=\"?\">\n\n</src>")
            ("sml" "#+begin_src sml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; caml
            ("camlf" "#+end_src\n?\n#+begin_src caml" "<src lang=\"?\">\n\n</src>")
            ("caml" "#+begin_src caml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** asm-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-asm-family
          '(
            ;; fasm
            ("fasmf" "#+end_src\n?\n#+begin_src fasm" "<src lang=\"?\">\n\n</src>")
            ("fasm" "#+begin_src fasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; nasm
            ("nasmf" "#+end_src\n?\n#+begin_src nasm" "<src lang=\"?\">\n\n</src>")
            ("nasm" "#+begin_src nasm\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** mark-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-mark-language
          '(
            ;; yaml
            ("yamlf" "#+end_src\n?\n#+begin_src yaml" "<src lang=\"?\">\n\n</src>")
            ("yaml" "#+begin_src yaml\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; css
            ("cssf" "#+end_src\n?\n#+begin_src css" "<src lang=\"?\">\n\n</src>")
            ("css" "#+begin_src css\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; bnf
            ("bnff" "#+end_src\n?\n#+begin_src bnf" "<src lang=\"?\">\n\n</src>")
            ("bnf" "#+begin_src bnf\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** c-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-c-family
          '(
            ;; c
            ("cf" "#+end_src\n?\n#+begin_src c" "<src lang=\"?\">\n\n</src>")
            ("c" "#+begin_src c\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; cpp
            ("cppf" "#+end_src\n?\n#+begin_src cpp" "<src lang=\"?\">\n\n</src>")
            ("cpp" "#+begin_src cpp\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; java
            ("javaf" "#+end_src\n?\n#+begin_src java" "<src lang=\"?\">\n\n</src>")
            ("java" "#+begin_src java\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; js
            ("jsf" "#+end_src\n?\n#+begin_src js" "<src lang=\"?\">\n\n</src>")
            ("js" "#+begin_src js\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; ts
            ("tsf" "#+end_src\n?\n#+begin_src typescript" "<src lang=\"?\">\n\n</src>")
            ("ts" "#+begin_src typescript\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; coffeescript
            ("cof" "#+end_src\n?\n#+begin_src coffee" "<src lang=\"?\">\n\n</src>")
            ("co" "#+begin_src coffee\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; py
            ("pyf" "#+end_src\n?\n#+begin_src python" "<src lang=\"?\">\n\n</src>")
            ("py" "#+begin_src python\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; lua
            ("luaf" "#+end_src\n?\n#+begin_src lua" "<src lang=\"?\">\n\n</src>")
            ("lua" "#+begin_src lua\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; perl
            ("perlf" "#+end_src\n?\n#+begin_src perl" "<src lang=\"?\">\n\n</src>")
            ("perl" "#+begin_src perl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; shell
            ("shf" "#+end_src\n?\n#+begin_src sh" "<src lang=\"?\">\n\n</src>")
            ("sh" "#+begin_src sh\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** human-language
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-human-language
          '(
            ;; lojban
            ("ljf" "#+end_src\n?\n#+begin_src lojban" "<src lang=\"?\">\n\n</src>")
            ("lj" "#+begin_src lojban\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** haskell
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-haskell-family
          '(
            ;; haskell
            ("hsf" "#+end_src\n?\n#+begin_src haskell" "<src lang=\"?\">\n\n</src>")
            ("hs" "#+begin_src haskell\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; agda
            ("agf" "#+end_src\n?\n#+begin_src agda2" "<src lang=\"?\">\n\n</src>")
            ("ag" "#+begin_src agda2\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; idris
            ("idf" "#+end_src\n?\n#+begin_src idris" "<src lang=\"?\">\n\n</src>")
            ("id" "#+begin_src idris\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ))
    #+end_src

*** other-family
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-other-family
          '(
            ;; fish
            ("fishf" "#+end_src\n?\n#+begin_src fish" "<src lang=\"?\">\n\n</src>")
            ("fish" "#+begin_src fish\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; sql
            ("sqlf" "#+end_src\n?\n#+begin_src sql" "<src lang=\"?\">\n\n</src>")
            ("sql" "#+begin_src sql\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; ruby
            ("rubyf" "#+end_src\n?\n#+begin_src ruby" "<src lang=\"?\">\n\n</src>")
            ("ruby" "#+begin_src ruby\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; tcl
            ("tclf" "#+end_src\n?\n#+begin_src tcl" "<src lang=\"?\">\n\n</src>")
            ("tcl" "#+begin_src tcl\n?\n#+end_src" "<src lang=\"?\">\n\n</src>")

            ;; for many kinds of conf-modes
            ("conff" "#+end_src\n?\n#+begin_src conf :tangle " "<src lang=\"?\">\n\n</src>")
            ("conf" "#+begin_src conf :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("confuf" "#+end_src\n?\n#+begin_src conf-unix :tangle " "<src lang=\"?\">\n\n</src>")
            ("confu" "#+begin_src conf-unix :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ("confxf" "#+end_src\n?\n#+begin_src conf-xdefaults :tangle " "<src lang=\"?\">\n\n</src>")
            ("confx" "#+begin_src conf-xdefaults :tangle \n?\n#+end_src" "<src lang=\"?\">\n\n</src>")
            ))
    #+end_src

*** main
    #+begin_src emacs-lisp :tangle ~/.emacs
    (setq org-structure-template-alist
          (append
           org-structure-template-basic

           org-structure-template-mark-language
           org-structure-template-human-language

           org-structure-template-lisp-family
           org-structure-template-forth-family
           org-structure-template-ml-family
           org-structure-template-erlang-family

           org-structure-template-asm-family
           org-structure-template-c-family

           org-structure-template-haskell-family

           org-structure-template-other-family

           ))
    #+end_src

** [babel] evaluation
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-hook 'org-mode-hook
   ;;           (lambda ()
   ;;             (setq org-confirm-babel-evaluate nil)))

   ;; default arguments to use when evaluating a source block
   (setq org-babel-default-header-args
         '((:session . "none")
           (:results . "replace")
           (:exports . "code")
           (:cache   . "no")
           (:noweb   . "yes")
           (:hlines  . "no")
           (:tangle  . "no")

           ;; shebang `#!' needs the following
           ;; (:padline . "no")

           (:padline . "yes")
           ))
   #+end_src

** [agenda] setting

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq org-agenda-files "~/.emacs.d/agenda/file-name-list")
   (global-set-key (kbd "C-M-o") 'org-cycle-agenda-files)
   (global-set-key (kbd "C-c a") 'org-agenda)

   ;; (define-prefix-command 'C-o-map)
   ;; (global-set-key (kbd "C-o") 'C-o-map)
   ;; (global-set-key (kbd "C-o C-b") 'org-iswitchb)

   (eval-after-load 'org
     '(progn
       (define-key org-mode-map (kbd "C-c C-l") 'org-toggle-link-display)))
   #+end_src

** [agenda] org-agenda-files
   tangle take too long so just edit
   file:~/.org-agenda-files

* folding

** origami.el

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/origami.el/")
   (require 'origami)

   (add-hook
    'origami-mode-hook
    (lambda ()
      (local-set-key (kbd "C-<tab>") 'origami-toggle-node)
      (local-set-key (kbd "<backtab>") 'origami-toggle-all-nodes)))
   #+end_src

** hideshow

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-hook
   ;;  'prog-mode-hook
   ;;  (lambda ()
   ;;    (hs-minor-mode)))

   ;; ;; hs-show-all
   ;; ;; hs-hide-all

   ;; ;; hs-show-block
   ;; ;; hs-hide-block

   ;; (global-set-key (kbd "C-<tab>") 'hs-toggle-hiding)
   #+end_src

* app

** w3m

   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/emacs-w3m/")
   (require 'w3m-load)

   (setq w3m-home-page "file:///home/xyh/.w3m/bookmark.html")

   ;; (setq browse-url-browser-function 'w3m-browse-url)
   ;; (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t)

   ;; optional keyboard short-cut

   (add-hook
    'w3m-mode-hook
    (lambda ()


      (local-set-key (kbd "h") 'backward-char)
      (local-set-key (kbd "l") 'forward-char)
      (local-set-key (kbd "j") 'next-line)
      (local-set-key (kbd "k") 'previous-line)

      (local-set-key (kbd "<left>") 'w3m-view-previous-page)
      (local-set-key (kbd "<right>") 'w3m-view-next-page)

      (local-set-key (kbd "<down>") 'forward-paragraph)
      (local-set-key (kbd "<up>") 'backward-paragraph)

      (local-set-key (kbd "M-n") 'forward-paragraph)
      (local-set-key (kbd "M-p") 'backward-paragraph)

      (local-set-key (kbd "RET") 'w3m-view-this-url)
      (local-set-key (kbd "M-RET") 'w3m-view-this-url-new-session)

      ;; bookmark
      (local-set-key (kbd "b") 'w3m-bookmark-view-new-session)
      (local-set-key (kbd "C-M-b") 'w3m-bookmark-edit)
      ;; tab
      (local-set-key (kbd "<C-tab>") 'w3m-next-buffer)
      (local-set-key (kbd "<C-iso-lefttab>") 'w3m-previous-buffer)
      ;; 獲取當前光標下的 url
      ;; 光標下沒有就獲取當前的 url
      ;; 點擊回車編輯 html
      (local-set-key (kbd "e") 'w3m-edit-url)

      ;; give back keys
      (local-set-key (kbd "C-t") 'isearch-forward)
      (local-set-key (kbd "M-s") 'forward-sexp)))
   #+end_src

** hippie-expand
   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-h") 'hippie-expand)

   (setq hippie-expand-try-functions-list
         '(try-expand-dabbrev
           try-expand-dabbrev-visible
           try-expand-dabbrev-all-buffers
           try-expand-dabbrev-from-kill
           try-expand-all-abbrevs
           try-expand-list
           try-expand-line
           ;; pcomplete
           try-complete-lisp-symbol-partially
           try-complete-lisp-symbol
           ;; try-complete-file-name-partially
           ;; try-complete-file-name
           ))
   #+end_src

** primary-clipboard-yank
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; ;; (eshell-command &optional COMMAND ARG)
   ;; ;; Execute the Eshell command string COMMAND
   ;; ;; With prefix ARG, insert output into the current buffer at point

   ;; (shell-command "xterm &")
   ;; (eshell-command "xterm &")

   ;; ;; 下面这句会开一个 out-put-buffer 然后显示输出的东西
   ;; (eshell-command "parcellite -p")
   ;; ;; == (eshell-command "parcellite -p" nil)


   ;; ;; 下面这个不开 out-put-buffer 会把光标停在粘贴的东西前面
   ;; (eshell-command "parcellite -p" nil)


   ;; ;; (eshell-command-result "parcellite -p")
   ;; ;; 下面这个会把光标停在粘贴的东西后面
   ;; (insert (eshell-command-result "parcellite -p"))

   ;; ;; 下面这个函数虽然跑的快
   ;; ;; 但是从 emacs 的 kill-ring 中粘贴东西的时候却会死掉
   ;; ;; (insert (shell-command-to-string "parcellite -p"))

   (defun primary-clipboard-yank ()
     (interactive)
     ;; (insert (eshell-command-result "clipit -p"))
     (insert (eshell-command-result "xclip -o"))
     )
   (global-set-key (kbd "C-M-y") 'primary-clipboard-yank)
   #+end_src

** gc-cons-threshold

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; default 800000 -- 0.76 MB
   (setq gc-cons-threshold 800000)
   #+end_src

** cua-selection-mode
   #+begin_src emacs-lisp :tangle ~/.emacs
   (cua-selection-mode 1)
   #+end_src

** uniquify
   #+begin_src emacs-lisp :tangle ~/.emacs
   (require 'uniquify)
   ;(setq uniquify-buffer-name-style 'reverse)
   (setq uniquify-buffer-name-style 'forward)
   #+end_src

** region-state
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/region-state/")
   (require 'region-state)
   (region-state-mode)
   (setq region-state-display-place 'echo-area)
   ;; (setq region-state-display-place 'header-line)
   ;; (setq region-state-display-place 'mode-line)
   #+end_src

* M-x

** default

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (global-set-key (kbd "M-x") 'execute-extended-command)
   #+end_src

** smex
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/smex/")
   (require 'smex)

   (global-set-key (kbd "M-x") 'smex)
   (global-set-key (kbd "M-z") 'smex-major-mode-commands)
   #+end_src

** helm

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/emacs-async/")
   ;; (require 'async)

   ;; (add-to-list 'load-path "~/.emacs.d/helm/")
   ;; (require 'helm-config)
   ;; (helm-mode 1)

   ;; (global-set-key (kbd "M-x") 'helm-M-x)
   ;; (global-set-key (kbd "C-x C-y") 'helm-show-kill-ring)
   ;; (global-set-key (kbd "C-x C-f") 'helm-find-files)
   ;; (global-set-key (kbd "C-x C-b") 'helm-mini)

   ;; (setq helm-buffers-fuzzy-matching t
   ;;       helm-recentf-fuzzy-match    t)

   ;; (add-hook
   ;;  'helm-after-initialize-hook
   ;;  (lambda ()
   ;;    (define-key helm-map (kbd "C-h") 'helm-execute-persistent-action)))
   #+end_src

* search

** default

   #+begin_src emacs-lisp :tangle ~/.emacs
   (global-set-key (kbd "C-t") 'isearch-forward)
   (global-set-key (kbd "C-s C-o") 'helm-occur)

   (add-hook
    'isearch-mode-hook
    (lambda ()
      (define-key isearch-mode-map (kbd "C-t") 'isearch-repeat-forward)))
   #+end_src

* irc

** irc-freenode-channel-list

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defvar irc-freenode-channel-list
     (list "#cicada-language"
           "#archlinux-cn"
           "#archlinux-cn-offtopic"))
   #+end_src

** irc-anarchyplanet-channel-list

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defvar irc-anarchyplanet-channel-list
     (list "#anarchyplanet"))
   #+end_src

** erc

   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun irc ()
     (interactive)
     (erc-tls :server "irc.libera.chat"
              :port 6697
              :full-name "xieyuheng"
              :nick "xieyuheng"))


   (setq erc-autojoin-channels-alist
         '(("irc.libera.chat"
            "#cicada-language"
            "#cicada-lang"
            "##prolog"
            "#archlinux-cn-offtopic")))
   #+end_src

* ranger

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/ranger.el/")
  (require 'ranger)

  (global-set-key (kbd "C-s C-w") 'ranger)

  (add-hook
   'ranger-mode-hook
   (lambda ()
     (local-set-key (kbd "C-s C-w") 'other-window)
     (local-set-key (kbd "C-x C-s") (lambda () (interactive)))
     (local-set-key (kbd "C-s C-x") (lambda () (interactive)))))

  (setq ranger-hide-cursor nil)
  (setq ranger-modify-header nil)
  (setq ranger-preview-file t)
  (setq ranger-show-literal nil)
  (setq ranger-parent-depth 0)
  (setq ranger-width-preview 0.7)
  (setq ranger-preview-delay 0.01)
  #+end_src

* looks like

** window

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq default-frame-alist '((fullscreen . maximized)))
   (setq initial-frame-alist '((fullscreen . maximized)))
   ;; (custom-set-variables '(default-frame-alist (quote ((fullscreen . maximized)))))
   ;; (custom-set-variables '(initial-frame-alist (quote ((fullscreen . maximized)))))
   #+end_src

** hl -- highlighting current line

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (add-to-list 'load-path "~/.emacs.d/hl-line/")
   ;; (require 'hl-line)
   ;; (global-hl-line-mode 1)
   #+end_src

** line-spacing

   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq-default line-spacing 0.2)
   #+end_src

** font

*** [note]

    #+begin_src emacs-lisp
    (char-table-extra-slot char-script-table 0)
    #+end_src

*** 楷

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "MS Song" :size 30))
    ;; (set-fontset-font t 'han (font-spec :name "H-宮書" :size 28))
    ;; (set-fontset-font t 'han (font-spec :name "H-宮書" :size 50))
    (set-fontset-font t 'han (font-spec :name "霞鹜文楷" :size 50))
    #+end_src

*** 宋

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "H-秀月" :size 40))
    ;; (set-fontset-font t 'han (font-spec :name "臺灣新細明體" :size 26))
    #+end_src

*** 黑

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'han (font-spec :name "H-雲林呉竹体" :size 26))
    ;; (set-fontset-font t 'han (font-spec :name "Sarasa Mono SC" :size 30))

    ;; (set-fontset-font t 'han (font-spec :name "H-明蘭" :size 44))
    ;; (set-fontset-font t 'han (font-spec :name "H-新雅蘭" :size 44))

    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Thin" :size 44))
    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Light" :size 44))

    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC DemiLight" :size 28))
    ;; (set-fontset-font t 'han (font-spec :name "Sarasa Mono SC" :size 44))

    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Medium" :size 26))
    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Bold" :size 26))
    ;; (set-fontset-font t 'han (font-spec :name "Noto Sans CJK TC Black" :size 26))
    #+end_src

*** test 等宽测试

    中英等宽测试|
    sdasddassaas|
    iiiiiiiiiiii|
    λλλλλλλλλλλλ|

*** english

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; 【“”""】【。.】【，,】【!！】【0 o】
    ;; [1i]

    ;; ~!@#$%^&*+=
    ;; 01234567890
    ;; -- ~~ __
    ;; ___---___---
    ;; >< <> -> =>
    ;; () [] {}
    ;; ;: "@" '@'
    ;; 1lJL qp QP o0O 8B 08
    ;; ,.  `'
    ;; <: :>
    ;; |- |--
    ;; <- ->
    ;; |- |--
    ;; |- |--

    ;; (set-face-attribute 'default nil :family "Input" :height 130)
    ;; (set-face-attribute 'default nil :family "Hack" :height 140)
    ;; (set-face-attribute 'default nil :family "Terminus (TTF)" :height 190)
    ;; (set-face-attribute 'default nil :family "xos4 Terminus" :height 200)
    ;; (set-face-attribute 'default nil :family "PragmataPro Mono" :height 200)
    ;; (set-face-attribute 'default nil :family "monofur" :height 160)
    ;; (set-face-attribute 'default nil :family "Monofur Nerd Font" :height 160)

    ;; (set-face-attribute 'default nil :family "monaco" :height 140)
    ;; (set-face-attribute 'default nil :family "Fixedsys Excelsior 3.01" :height 190)
    (set-face-attribute 'default nil :family "Fira Code" :height 150)
    ;; (set-face-attribute 'default nil :family "Fira Mono" :height 190)
    ;; (set-face-attribute 'default nil :family "Sarasa Mono SC" :height 190)

    ;; (set-face-attribute 'default nil :family "Source Code Pro" :height 180)
    ;; (set-face-attribute 'default nil :family "mononoki" :height 180)
    ;; (set-face-attribute 'default nil :family "Noto Mono" :height 180)
    #+end_src

*** symbol

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (set-fontset-font t 'symbol (font-spec :name "Noto Mono"))
    ;; (set-fontset-font t 'symbol (font-spec :name "Sarasa Mono SC"))
    (set-fontset-font t 'symbol (font-spec :name "Fira Code"))
    ;; (set-fontset-font t 'symbol (font-spec :name "Noto Emoji"))
    #+end_src

*** ligature

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'load-path "~/.emacs.d/ligature.el")
    (require 'ligature)

    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))

    (setq cascadia-code-ligatures
          '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
            ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
            "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
            "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
            "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
            "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
            "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
            "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
            ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
            "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
            "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
            "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
            "://"))

    (setq fira-code-ligatures
          '("www" "**" "***" "**/" "*>" "*/" "{-" "::"
            ":::" ":=" "!!" "!=" "!==" "-}" "----" "-->" "->" "->>"
            "|-" "|="
            "|}" "|]" "{|" "[|"
            "-<" "-<<" "-~" "#{" "#[" "##" "###" "####" "#(" "#?" "#_"

            "#_(" ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*" "/**"
            "/>" "//" "///" "&&" "||" "||=" "|=" "|>" "^=" "$>"
            "++" "+++" "+>" "=:=" "==" "===" "==>" "=>" "=>>" "<="

            "=<<" "=/=" ">-" ">=" ">=>" ">>" ">>-" ">>=" ">>>" "<*"
            "<*>" "<|" "<|>" "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"

            "<+>"
            "<="
            "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<"
            "<~" "<~~" "</" "</>" "~@" "~-" "~>" "~~" "~~>" "%%"
            ))

    (ligature-set-ligatures 'prog-mode fira-code-ligatures)
    (ligature-set-ligatures 'markdown-mode fira-code-ligatures)
    (ligature-set-ligatures 'org-mode fira-code-ligatures)

    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t)
    #+end_src

** theme

*** molokai-theme

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/molokai-theme/")
    ;; (load-theme 'molokai t)

    ;; (add-to-list 'load-path "~/.emacs.d/theme/molokai-theme/")
    ;; (require 'molokai-theme-kit)
    #+end_src

*** zenburn

    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/zenburn-emacs/")
    (load-theme 'zenburn t)
    #+end_src

*** anti-zenburn

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/anti-zenburn-theme/")
    ;; (load-theme 'anti-zenburn t)
    #+end_src

*** tao

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/tao-theme-emacs/")
    ;; (add-to-list 'load-path "~/.emacs.d/theme/tao-theme-emacs/")
    ;; (load-theme 'tao-yang t)
    ;; (load-theme 'tao-yin t)
    #+end_src

*** github-modern

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/github-theme/")
    ;; (load-theme 'github-modern t)
    #+end_src

*** subatomic

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/subatomic/")
    ;; (load-theme 'subatomic t)
    #+end_src

*** arjen-grey

    #+begin_src emacs-lisp :tangle ~/.emacs
    ;; (add-to-list 'custom-theme-load-path "~/.emacs.d/theme/arjen-grey-theme/")
    ;; (load-theme 'arjen-grey t)
    #+end_src

** translucent

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; 当前窗口和非当前窗口时透明度
   (setq translucent-pair '(90 90))

   (setq alpha-list `(,translucent-pair (100 100)))
   (defun translucent ()
     (interactive)
     (let* ((h (car alpha-list))
            (a (car h))
            (ab (car (cdr h))))
           (set-frame-parameter (selected-frame) 'alpha (list a ab))
           (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))
           (setq alpha-list (cdr (append alpha-list (list h))))))
   (global-set-key (kbd "<f9>") 'translucent)

   (setq alpha-list-on `((100 100) ,translucent-pair))
   (defun translucent-on ()
     (interactive)
     (let* ((h (car alpha-list-on))
            (a (car h))
            (ab (car (cdr h))))
           (set-frame-parameter (selected-frame) 'alpha (list a ab))
           (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

   (setq alpha-list-off `(,translucent-pair (100 100)))
   (defun translucent-off ()
     (interactive)
     (let* ((h (car alpha-list-off))
            (a (car h))
            (ab (car (cdr h))))
           (set-frame-parameter (selected-frame) 'alpha (list a ab))
           (add-to-list 'default-frame-alist (cons 'alpha (list a ab)))))

   ;; (translucent-on)
   (translucent-off)
   #+end_src

** no-bother
   #+begin_src emacs-lisp :tangle ~/.emacs
   (mouse-avoidance-mode 'animate)
   (setq inhibit-startup-message t)
   (setq initial-scratch-message "")

   (tool-bar-mode -1)
   (menu-bar-mode -1)
   (scroll-bar-mode -1)

   (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

** cursor
   #+begin_src emacs-lisp :tangle ~/.emacs
   (blink-cursor-mode -1)

   ;; (set-frame-parameter nil 'cursor-type 'hollow)
   (set-frame-parameter nil 'cursor-type 'box)
   ;; (set-frame-parameter nil 'cursor-type 'bar)
   ;; (set-frame-parameter nil 'cursor-type '(bar . 2))
   ;; (set-frame-parameter nil 'cursor-type 'hbar)
   ;; (set-frame-parameter nil 'cursor-type '(hbar . 8))
   #+end_src

** fullscreen
   #+begin_src emacs-lisp :tangle ~/.emacs
   (setq frame-resize-pixelwise t)
   #+end_src

* emacs server & eshell

** [note]
   * 需要與 bash 或 zsh 配合使用
     給 emacsclient 以 "e" 爲其別名
     並注意設置 emacsclient 的命令行參數
   * 但是如果先有一个 emacs-sever
     再打开 emacs 時 就会有警告
     我保留对这个警告的显示
     因为它提示了当前 emacs-sever 的开启状态
     (server-force-delete)
   * 因此常使用的方式是
     将(server-start)写在.emacs 中
     将 alias e='emacsclient -c -a "" -e \(eshell\)'写在.bashrc 中
     第一个 emacs 在终端中用 emacs 打开
     之后在终端中使用 e 就会以这个 emacs 为 sever
     退出这第一个 emacs 之后就会关闭被它打开的 emacs-sever

** emacs server
   #+begin_src emacs-lisp :tangle ~/.emacs
   (server-start)
   ;; (setq server-name "><")
   ;; (server-force-delete)
   #+end_src

** load-path
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-to-list 'load-path "~/.emacs.d/eshell/")
   (require 'eshell)
   #+end_src

** hook
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook
    'eshell-mode-hook
    (lambda ()
      (local-set-key (kbd "C-c h")
                     (lambda ()
                           (interactive)
                           (insert
                            (ido-completing-read "eshell history: "
                                             (delete-dups
                                              (ring-elements eshell-history-ring))))))
      (local-set-key (kbd "C-c C-h") 'eshell-list-history)))
   #+end_src

** [note] how to use

*** startup scripts
    *for i use org-mode, this is not very useful*
    like most shells,
    eshell supports both login and profile/rc shell scripts
    The full filepaths for both are stored in the variables
    eshell-login-script and eshell-rc-script
    but by default the files login and profile are stored in ~/.eshell/

    It bears mention that the comment syntax is #

*** jump
    it maintains a ring the last 32 directories seen.

    To view the ring: ‘cd =’
    Changing to an index within the ring: ‘cd -4’
    Note that ‘cd -’ is the same as ‘cd -0’
    Use a regular expression: ‘cd =regexp’

    The ring is saved in ‘~/.eshell/lastdir’.
    You can increase the ring size by setting ‘eshell-last-dir-ring-size’.
    Perhaps this is good enough for you, making autojump unnecessary.
    The only benefit autojump offers is that it sorts the entries
    by how often you switched there instead of when you switched there.

** alias
   * the auto-correcting aliasing
     if you type an invalid command too many times
     (governed by eshell-bad-command-tolerance, which is 3 by default)
     Eshell will offer to alias it to its intended command for you
   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; eshell will write the alias definitions to eshell-aliases-file
   (setq eshell-aliases-file "~/.emacs.d/eshell/alias")
   ;; which in turn is governed by the eshell-directory-name
   (setq eshell-directory-name "~/.emacs.d/eshell/")
   #+end_src

** commands history
   * to use ido-completing-read to access to eshells history
   #+begin_src emacs-lisp :tangle ~/.emacs
   (add-hook 'eshell-mode-hook
                    (lambda ()
                      (local-set-key (kbd "M-<tab>") 'window->)))
   #+end_src

* make multi eshell work much easier

** eshell/delete-char-or-kill-buffer
   1. (goto-char (point-max)) == (end-of-buffer)
   2. 在 emacs 中 efb 的识别方式有很多 比如:
      1. (eq (following-char) 0)
         (char-equal (following-char) 0)
      2. (eq (point-max) (point))
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun eshell/delete-char-or-kill-buffer ()
     (interactive)

     (point-to-register ?e)
     (eshell-bol)

     (if (eq (point-max) (point))
             (progn
           (kill-buffer)
           (delete-frame))
           (progn
             (jump-to-register ?e)
             (delete-char 1))))

   (add-hook 'eshell-mode-hook
             (lambda ()
                   (local-set-key (kbd "C-d") 'eshell/delete-char-or-kill-buffer)))
   #+end_src

** eshell-prompt-function
   #+begin_src emacs-lisp :tangle ~/.emacs
   (set 'eshell-prompt-function
        (lambda ()
          (concat "\n"
                  (if (eq eshell-last-command-status 0)
                      ""
                      (number-to-string eshell-last-command-status))
                  "  "
                  (if (= (user-uid) 0)
                      "[root]  "
                      "")
                  (eshell/pwd)
                  "\n"
                  )))
   #+end_src

** self-defun [before eshell]

*** my-cd-back
    #+begin_src emacs-lisp :tangle ~/.emacs
    (defun my-cd-back ()
      (interactive)
      (insert "cd ..")
      (eshell-send-input))
    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "<C-M-backspace>") 'my-cd-back)))
    #+end_src

*** rebinding normal move-beginning-of-line
    #+begin_src emacs-lisp :tangle ~/.emacs
    (add-hook 'eshell-mode-hook
              (lambda ()
                    (local-set-key (kbd "C-S-a") 'move-beginning-of-line)))
    #+end_src

** [open|new]-eshell-for-frame

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; in ~/.xbindkeysrc.scm
   ;; I have the following
   ;; (xbindkey '(shift mod4 x) "LC_CTYPE=zh_CN.UTF-8 emacsclient -c -e \"(open-eshell-for-frame :on)\"")
   ;; (xbindkey '(mod4 t) "LC_CTYPE=zh_CN.UTF-8 emacsclient -t -e \"(open-eshell-for-frame :on)\"")

   (defun frame-eshell-name ()
     (concatenate 'string "eshell:" (frame-parameter nil 'name)))

   (defun open-eshell-for-frame (&optional translucent)
     (let ()
       (eshell t)
       (delete-region 1 (buffer-size))
       (insert "* (eshell)\n"
               "  eshell number " (frame-parameter nil 'name) "\n"
               "  the main eshell for this frame\n")
       (eshell-interrupt-process)))

   ;; can be used in 'emacs -nw'
   (defun new-eshell-for-frame (&optional translucent)
     (interactive)
     (let* ((.sub-number-string (number-to-string (number-generator))))
       (eshell t)
       (delete-region 1 (buffer-size))
       (insert "* (eshell)\n"
               "  eshell number " (frame-parameter nil 'name) "\n"
               "  eshell sub-number " .sub-number-string "\n"
               "  a sub eshell of this frame\n")
       (eshell-interrupt-process)))

   (global-set-key (kbd "C-s e") 'new-eshell-for-frame)
   #+end_src

** my-switch-to-eshell
   * 下面是黄金搭档 previous-buffer
   #+begin_src emacs-lisp :tangle ~/.emacs
   (defun my-switch-to-eshell ()
     (interactive)
     (cond
       ((not (member-string? (frame-eshell-name) (mapcar 'buffer-name (buffer-list))))
        (open-eshell-for-frame))
       (:else
        (switch-to-buffer (frame-eshell-name))))
     (local-set-key (kbd "C-s C-e") 'previous-buffer))
   (global-set-key (kbd "C-s C-e") 'my-switch-to-eshell)
   #+end_src

** init call to (open-eshell-for-frame)

   #+begin_src emacs-lisp :tangle ~/.emacs
   ;; (open-eshell-for-frame :off)
   #+end_src

* scratch

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (setq initial-buffer-choice "~/.emacs.d/scratch/scratch.org")
  (setq initial-buffer-choice "~/todo/TODO.md")
  #+end_src

* ag

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/ag.el/")
  (require 'ag)
  #+end_src

* projectile

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (add-to-list 'load-path "~/.emacs.d/projectile/")
  ;; (require 'projectile)

  ;; (projectile-mode 1)
  #+end_src

* ggtags

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; (add-to-list 'load-path "~/.emacs.d/ggtags/")
  ;; (require 'ggtags)

  ;; (add-hook 'c-mode-common-hook
  ;;           (lambda ()
  ;;             (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
  ;;               (ggtags-mode 1))))
  #+end_src

* ido

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/ido-vertical-mode/")
  (require 'ido-vertical-mode)
  (ido-mode 1)
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
  #+end_src

* pomidor

  #+begin_src emacs-lisp :tangle ~/.emacs
  ;; ;; (add-to-list 'load-path "~/.emacs.d/pomidor/")
  ;; (require 'pomidor)

  ;; (setq pomidor-sound-tick nil
  ;;       pomidor-sound-tack nil
  ;;       ;; pomidor-sound-overwork (expand-file-name (concat pomidor-dir "overwork.wav"))
  ;;       ;; pomidor-sound-break-over (expand-file-name (concat (getenv "HOME") "/Music/overwork.wav"))
  ;;       )

  ;; ;; (pomidor)
  #+end_src

* hl-todo

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/hl-todo/")
  (require 'hl-todo)

  (global-hl-todo-mode)

  (define-key hl-todo-mode-map (kbd "C-c p") 'hl-todo-previous)
  (define-key hl-todo-mode-map (kbd "C-c n") 'hl-todo-next)
  (define-key hl-todo-mode-map (kbd "C-c o") 'hl-todo-occur)
  #+end_src

* pinky-mode

  #+begin_src emacs-lisp :tangle ~/.emacs
  (add-to-list 'load-path "~/.emacs.d/pinky-mode/")
  (require 'pinky-mode)
  #+end_src

* auto revert

  #+begin_src emacs-lisp :tangle ~/.emacs
  (global-auto-revert-mode t)
  (setq auto-revert-interval 1)
  #+end_src

* package

  #+begin_src emacs-lisp :tangle ~/.emacs
  (require 'package)
  ;; (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3") ; see remark below
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
  #+end_src
